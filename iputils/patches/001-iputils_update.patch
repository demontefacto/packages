diff -Naur iputils-s20151218.orig/arping.c iputils-s20151218/arping.c
--- iputils-s20151218.orig/arping.c	2015-12-17 15:45:51.000000000 +0000
+++ iputils-s20151218/arping.c	2016-05-17 23:17:09.000000000 +0000
@@ -11,18 +11,14 @@
  */
 
 #include <stdlib.h>
-#include <sys/param.h>
-#include <sys/socket.h>
-#include <linux/sockios.h>
-#include <sys/file.h>
-#include <sys/time.h>
-#include <sys/signal.h>
-#include <sys/ioctl.h>
+#include <time.h>
+#include <signal.h>
 #include <net/if.h>
 #include <linux/if_packet.h>
 #include <linux/if_ether.h>
 #include <net/if_arp.h>
-#include <sys/uio.h>
+#include <sys/ioctl.h>
+#include <sys/param.h>
 #ifdef CAPABILITIES
 #include <sys/prctl.h>
 #include <sys/capability.h>
@@ -90,7 +86,7 @@
 struct sockaddr_storage me;
 struct sockaddr_storage he;
 
-struct timeval start, last;
+struct timespec start, last;
 
 int sent, brd_sent;
 int received, brd_recv, req_recv;
@@ -271,7 +267,7 @@
 	      struct sockaddr_ll *ME, struct sockaddr_ll *HE)
 {
 	int err;
-	struct timeval now;
+	struct timespec now;
 	unsigned char buf[256];
 	struct arphdr *ah = (struct arphdr*)buf;
 	unsigned char *p = (unsigned char *)(ah+1);
@@ -299,7 +295,7 @@
 	memcpy(p, &dst, 4);
 	p+=4;
 
-	gettimeofday(&now, NULL);
+	clock_gettime(CLOCK_MONOTONIC, &now);
 	err = sendto(s, buf, p-buf, 0, (struct sockaddr*)HE, SLL_LEN(ah->ar_hln));
 	if (err == p-buf) {
 		last = now;
@@ -335,29 +331,52 @@
 	exit(!received);
 }
 
+static void timespec_sub(struct timespec *a, struct timespec *b,
+			 struct timespec *res)
+{
+	res->tv_sec = a->tv_sec - b->tv_sec;
+	res->tv_nsec = a->tv_nsec - b->tv_nsec;
+	if (a->tv_nsec < b->tv_nsec) {
+		res->tv_sec--;
+		res->tv_nsec += 1000000000;
+	}
+}
+
+static int timespec_later(struct timespec *a, struct timespec *b)
+{
+	return (a->tv_sec > b->tv_sec) ||
+		((a->tv_sec == b->tv_sec) && (a->tv_nsec > b->tv_nsec));
+}
+
 void catcher(void)
 {
-	struct timeval tv, tv_s, tv_o;
+	struct timespec ts, ts_s, ts_o;
 
-	gettimeofday(&tv, NULL);
+	clock_gettime(CLOCK_MONOTONIC, &ts);
 
 	if (start.tv_sec==0)
-		start = tv;
+		start = ts;
 
-	timersub(&tv, &start, &tv_s);
-	tv_o.tv_sec = timeout;
-	tv_o.tv_usec = 500 * 1000;
+	timespec_sub(&ts, &start, &ts_s);
+	ts_o.tv_sec = timeout;
+	ts_o.tv_nsec = 500 * 1000000;
 
-	if (count-- == 0 || (timeout && timercmp(&tv_s, &tv_o, >)))
+	if (timeout && timespec_later(&ts_s, &ts_o))
 		finish();
 
-	timersub(&tv, &last, &tv_s);
-	tv_o.tv_sec = 0;
+	timespec_sub(&ts, &last, &ts_s);
+	ts_o.tv_sec = 0;
 
-	if (last.tv_sec==0 || timercmp(&tv_s, &tv_o, >)) {
+	if (last.tv_sec==0 || timespec_later(&ts_s, &ts_o)) {
+		if (!timeout && (sent == count))
+			finish();
 		send_pack(s, src, dst,
 			  (struct sockaddr_ll *)&me, (struct sockaddr_ll *)&he);
-		if (count == 0 && unsolicited)
+		if ((sent == count) && unsolicited)
+			/* We usually wait for an extra iteration
+			 * after sending the last request to see if we
+			 * get a reply, but we don't need to in
+			 * unsolicited mode */
 			finish();
 	}
 	alarm(1);
@@ -375,12 +394,12 @@
 
 int recv_pack(unsigned char *buf, int len, struct sockaddr_ll *FROM)
 {
-	struct timeval tv;
+	struct timespec ts;
 	struct arphdr *ah = (struct arphdr*)buf;
 	unsigned char *p = (unsigned char *)(ah+1);
 	struct in_addr src_ip, dst_ip;
 
-	gettimeofday(&tv, NULL);
+	clock_gettime(CLOCK_MONOTONIC, &ts);
 
 	/* Filter out wild packets */
 	if (FROM->sll_pkttype != PACKET_HOST &&
@@ -456,8 +475,8 @@
 			printf("]");
 		}
 		if (last.tv_sec) {
-			long usecs = (tv.tv_sec-last.tv_sec) * 1000000 +
-				tv.tv_usec-last.tv_usec;
+			long usecs = (ts.tv_sec-last.tv_sec) * 1000000 +
+				(ts.tv_nsec-last.tv_nsec+500) / 1000;
 			long msecs = (usecs+500)/1000;
 			usecs -= msecs*1000 - 500;
 			printf(" %ld.%03ldms\n", msecs, usecs);
@@ -467,6 +486,8 @@
 		fflush(stdout);
 	}
 	received++;
+	if (timeout && (received == count))
+		finish();
 	if (FROM->sll_pkttype != PACKET_HOST)
 		brd_recv++;
 	if (ah->ar_op == htons(ARPOP_REQUEST))
@@ -490,10 +511,6 @@
 	SYSFS_DEVATTR_IFINDEX,
 	SYSFS_DEVATTR_FLAGS,
 	SYSFS_DEVATTR_ADDR_LEN,
-#if 0
-	SYSFS_DEVATTR_TYPE,
-	SYSFS_DEVATTR_ADDRESS,
-#endif
 	SYSFS_DEVATTR_BROADCAST,
 	SYSFS_DEVATTR_NUM
 };
@@ -525,17 +542,6 @@
 		.name		= "flags",
 		.handler	= sysfs_devattr_ulong_hex,
 	},
-#if 0
-	[SYSFS_DEVATTR_TYPE] = {
-		.name		= "type",
-		.handler	= sysfs_devattr_ulong_dec,
-	},
-	[SYSFS_DEVATTR_ADDRESS] = {
-		.name		= "address",
-		.handler	= sysfs_devattr_macaddr,
-		.free		= 1,
-	},
-#endif
 	[SYSFS_DEVATTR_BROADCAST] = {
 		.name		= "broadcast",
 		.handler	= sysfs_devattr_macaddr,
@@ -596,7 +602,7 @@
 #ifndef WITHOUT_IFADDRS
 	int rc;
 	struct ifaddrs *ifa0, *ifa;
-	int count = 0;
+	int n = 0;
 
 	rc = getifaddrs(&ifa0);
 	if (rc) {
@@ -622,11 +628,11 @@
 
 		device.ifa = ifa;
 
-		if (count++)
+		if (n++)
 			break;
 	}
 
-	if (count == 1 && device.ifa) {
+	if (n == 1 && device.ifa) {
 		device.ifindex = if_nametoindex(device.ifa->ifa_name);
 		if (!device.ifindex) {
 			perror("arping: if_nametoindex");
@@ -724,7 +730,7 @@
 	struct sysfs_class_device *dev;
 	struct sysfs_attribute *dev_attr;
 	struct sysfs_devattr_values sysfs_devattr_values;
-	int count = 0;
+	int n = 0;
 
 	if (!device.sysfs) {
 		device.sysfs = malloc(sizeof(*device.sysfs));
@@ -798,7 +804,7 @@
 		memcpy(device.sysfs, &sysfs_devattr_values, sizeof(*device.sysfs));
 		sysfs_devattr_values_init(&sysfs_devattr_values, 0);
 
-		if (count++)
+		if (n++)
 			break;
 
 		continue;
@@ -806,7 +812,7 @@
 		sysfs_devattr_values_init(&sysfs_devattr_values, 1);
 	}
 
-	if (count == 1) {
+	if (n == 1) {
 		device.ifindex = device.sysfs->value[SYSFS_DEVATTR_IFINDEX].ulong;
 		device.name = device.sysfs->ifname;
 	}
@@ -842,7 +848,7 @@
 	size_t ifrsize = sizeof(*ifr);
 	struct ifconf ifc;
 	static struct ifreq ifrbuf;
-	int count = 0;
+	int n = 0;
 
 	s = socket(AF_INET, SOCK_DGRAM, 0);
 	if (s < 0) {
@@ -856,7 +862,7 @@
 		strncpy(ifrbuf.ifr_name, device.name, sizeof(ifrbuf.ifr_name) - 1);
 		if (check_device_by_ioctl(s, &ifrbuf))
 			goto out;
-		count++;
+		n++;
 	} else {
 		do {
 			int rc;
@@ -892,14 +898,14 @@
 			if (check_device_by_ioctl(s, &ifrbuf))
 				continue;
 			memcpy(&ifrbuf.ifr_name, ifr->ifr_name, sizeof(ifrbuf.ifr_name));
-			if (count++)
+			if (n++)
 				break;
 		}
 	}
 
 	close(s);
 
-	if (count == 1) {
+	if (n == 1) {
 		device.ifindex = ifrbuf.ifr_ifindex;
 		device.name = ifrbuf.ifr_name;
 	}
@@ -1085,30 +1091,24 @@
 	}
 
 	if (inet_aton(target, &dst) != 1) {
-		struct hostent *hp;
-		char *idn = target;
+		struct addrinfo hints = {
+			.ai_family = AF_INET,
+			.ai_socktype = SOCK_RAW,
 #ifdef USE_IDN
-		int rc;
-
-		rc = idna_to_ascii_lz(target, &idn, 0);
-
-		if (rc != IDNA_SUCCESS) {
-			fprintf(stderr, "arping: IDN encoding failed: %s\n", idna_strerror(rc));
-			exit(2);
-		}
+			.ai_flags = AI_IDN | AI_CANONIDN
 #endif
-
-		hp = gethostbyname2(idn, AF_INET);
-		if (!hp) {
-			fprintf(stderr, "arping: unknown host %s\n", target);
+		};
+		struct addrinfo *result;
+		int status;
+
+		status = getaddrinfo(target, NULL, &hints, &result);
+		if (status) {
+			fprintf(stderr, "arping: %s: %s\n", target, gai_strerror(status));
 			exit(2);
 		}
 
-#ifdef USE_IDN
-		free(idn);
-#endif
-
-		memcpy(&dst, hp->h_addr, 4);
+		memcpy(&dst, &((struct sockaddr_in *) result->ai_addr)->sin_addr, sizeof dst);
+		freeaddrinfo(result);
 	}
 
 	if (source && inet_aton(source, &src) != 1) {
@@ -1215,16 +1215,22 @@
 		socklen_t alen = sizeof(from);
 		int cc;
 
+		sigemptyset(&sset);
+		sigaddset(&sset, SIGALRM);
+		sigaddset(&sset, SIGINT);
+		/* Unblock SIGALRM so that the previously called alarm()
+		 * can prevent recvfrom from blocking forever in case the
+		 * inherited procmask is blocking SIGALRM and no packet
+		 * is received. */
+		sigprocmask(SIG_UNBLOCK, &sset, &osset);
+
 		if ((cc = recvfrom(s, packet, sizeof(packet), 0,
 				   (struct sockaddr *)&from, &alen)) < 0) {
 			perror("arping: recvfrom");
 			continue;
 		}
 
-		sigemptyset(&sset);
-		sigaddset(&sset, SIGALRM);
-		sigaddset(&sset, SIGINT);
-		sigprocmask(SIG_BLOCK, &sset, &osset);
+		sigprocmask(SIG_BLOCK, &sset, NULL);
 		recv_pack(packet, cc, (struct sockaddr_ll *)&from);
 		sigprocmask(SIG_SETMASK, &osset, NULL);
 	}
diff -Naur iputils-s20151218.orig/clockdiff.c iputils-s20151218/clockdiff.c
--- iputils-s20151218.orig/clockdiff.c	2015-12-17 15:45:51.000000000 +0000
+++ iputils-s20151218/clockdiff.c	2016-05-17 23:17:09.000000000 +0000
@@ -14,7 +14,6 @@
 #include <netinet/ip.h>
 #include <netinet/ip_icmp.h>
 #define TSPTYPES
-#include <protocols/timed.h>
 #include <fcntl.h>
 #include <netdb.h>
 #include <arpa/inet.h>
@@ -45,11 +44,11 @@
 	} \
 }
 
-int in_cksum(u_short *addr, int len)
+int in_cksum(unsigned short *addr, int len)
 {
 	union word {
 		char	c[2];
-		u_short	s;
+		unsigned short	s;
 	} u;
 	int sum = 0;
 
@@ -72,7 +71,7 @@
 			/*
 			 * Odd number of bytes.
 			 */
-			u.c[0] = *(u_char *)addr;
+			u.c[0] = *(unsigned char *)addr;
 	}
 	if (len == -1) {
 		/* The last mbuf has odd # of bytes. Follow the
@@ -113,7 +112,7 @@
 
 int measure_delta;
 int measure_delta1;
-static u_short seqno, seqno0, acked;
+static unsigned short seqno, seqno0, acked;
 long rtt = 1000;
 long min_rtt;
 long rtt_sigma = 0;
@@ -133,7 +132,7 @@
 	long min1, min2, diff;
 	long delta1, delta2;
 	struct timeval tv1, tout;
-	u_char packet[PACKET_IN], opacket[64];
+	unsigned char packet[PACKET_IN], opacket[64];
 	struct icmphdr *icp = (struct icmphdr *) packet;
 	struct icmphdr *oicp = (struct icmphdr *) opacket;
 	struct iphdr *ip = (struct iphdr *) packet;
@@ -195,7 +194,7 @@
 		(void)gettimeofday (&tv1, (struct timezone *)0);
 		*(__u32*)(oicp+1) = htonl((tv1.tv_sec % (24*60*60)) * 1000
 					  + tv1.tv_usec / 1000);
-		oicp->checksum = in_cksum((u_short *)oicp, sizeof(*oicp) + 12);
+		oicp->checksum = in_cksum((unsigned short *)oicp, sizeof(*oicp) + 12);
 
 		count = sendto(sock_raw, (char *)opacket, sizeof(*oicp)+12, 0,
 			       (struct sockaddr *)addr, sizeof(struct sockaddr_in));
@@ -310,7 +309,7 @@
 	long min1, min2, diff;
 	long delta1, delta2;
 	struct timeval tv1, tout;
-	u_char packet[PACKET_IN], opacket[64];
+	unsigned char packet[PACKET_IN], opacket[64];
 	struct icmphdr *icp = (struct icmphdr *) packet;
 	struct icmphdr *oicp = (struct icmphdr *) opacket;
 	struct iphdr *ip = (struct iphdr *) packet;
@@ -373,7 +372,7 @@
 		gettimeofday (&tv1, NULL);
 		((__u32*)(oicp+1))[0] = htonl((tv1.tv_sec % (24*60*60)) * 1000
 					      + tv1.tv_usec / 1000);
-		oicp->checksum = in_cksum((u_short *)oicp, sizeof(*oicp)+12);
+		oicp->checksum = in_cksum((unsigned short *)oicp, sizeof(*oicp)+12);
 
 		count = sendto(sock_raw, (char *)opacket, sizeof(*oicp)+12, 0,
 			       (struct sockaddr *)addr, sizeof(struct sockaddr_in));
@@ -551,7 +550,9 @@
 main(int argc, char *argv[])
 {
 	int measure_status;
-	struct hostent * hp;
+	struct addrinfo hints = { .ai_family = AF_INET, .ai_socktype = SOCK_RAW, .ai_flags = AI_CANONNAME };
+	struct addrinfo *result;
+	int status;
 	char hostname[MAX_HOSTNAMELEN];
 	int s_errno = 0;
 	int n_errno = 0;
@@ -599,23 +600,23 @@
 	id = getpid();
 
 	(void)gethostname(hostname,sizeof(hostname));
-	hp = gethostbyname(hostname);
-	if (hp == NULL) {
-		fprintf(stderr, "clockdiff: %s: my host not found\n", hostname);
+	status = getaddrinfo(hostname, NULL, &hints, &result);
+	if (status) {
+		fprintf(stderr, "clockdiff: %s: %s\n", hostname, gai_strerror(status));
+		exit(2);
+	}
+	myname = strdup(result->ai_canonname);
+	freeaddrinfo(result);
+
+	status = getaddrinfo(argv[1], NULL, &hints, &result);
+	if (status) {
+		fprintf(stderr, "clockdiff: %s: %s\n", argv[1], gai_strerror(status));
 		exit(1);
 	}
-	myname = strdup(hp->h_name);
+	hisname = strdup(result->ai_canonname);
 
-	hp = gethostbyname(argv[1]);
-	if (hp == NULL) {
-		fprintf(stderr, "clockdiff: %s: host not found\n", argv[1]);
-		exit(1);
-	}
-	hisname = strdup(hp->h_name);
-
-	memset(&server, 0, sizeof(server));
-	server.sin_family = hp->h_addrtype;
-	memcpy(&(server.sin_addr.s_addr), hp->h_addr, 4);
+	memcpy(&server, result->ai_addr, sizeof server);
+	freeaddrinfo(result);
 
 	if (connect(sock_raw, (struct sockaddr*)&server, sizeof(server)) == -1) {
 		perror("connect");
diff -Naur iputils-s20151218.orig/doc/arping.8 iputils-s20151218/doc/arping.8
--- iputils-s20151218.orig/doc/arping.8	1970-01-01 00:00:00.000000000 +0000
+++ iputils-s20151218/doc/arping.8	2016-07-16 01:02:34.457253757 +0000
@@ -0,0 +1,109 @@
+.\" This manpage has been automatically generated by docbook2man 
+.\" from a DocBook document.  This tool can be found at:
+.\" <http://shell.ipoline.com/~elmert/comp/docbook2X/> 
+.\" Please send any bug reports, improvements, comments, patches, 
+.\" etc. to Steve Cheng <steve@ggi-project.org>.
+.TH "ARPING" "8" "" "iputils-160308" "System Manager's Manual: iputils"
+.SH NAME
+arping \- send ARP REQUEST to a neighbour host
+.SH SYNOPSIS
+
+\fBarping\fR [\fB-AbDfhqUV\fR] [\fB-c \fIcount\fB\fR] [\fB-w \fIdeadline\fB\fR] [\fB-s \fIsource\fB\fR] \fB-I \fIinterface\fB\fR \fB\fIdestination\fB\fR
+
+.SH "DESCRIPTION"
+.PP
+Ping \fIdestination\fR on device \fIinterface\fR by ARP packets,
+using source address \fIsource\fR.
+.SH "OPTIONS"
+.TP
+\fB-A\fR
+The same as \fB-U\fR, but ARP REPLY packets used instead
+of ARP REQUEST.
+.TP
+\fB-b\fR
+Send only MAC level broadcasts. Normally \fBarping\fR starts
+from sending broadcast, and switch to unicast after reply received.
+.TP
+\fB-c \fIcount\fB\fR
+Stop after sending \fIcount\fR ARP REQUEST
+packets. With 
+\fIdeadline\fR
+option, instead wait for
+\fIcount\fR ARP REPLY packets, or until the timeout expires.
+.TP
+\fB-D\fR
+Duplicate address detection mode (DAD). See 
+RFC2131, 4.4.1.
+Returns 0, if DAD succeeded i.e. no replies are received
+.TP
+\fB-f\fR
+Finish after the first reply confirming that target is alive.
+.TP
+\fB-I \fIinterface\fB\fR
+Name of network device where to send ARP REQUEST packets.
+.TP
+\fB-h\fR
+Print help page and exit.
+.TP
+\fB-q\fR
+Quiet output. Nothing is displayed.
+.TP
+\fB-s \fIsource\fB\fR
+IP source address to use in ARP packets.
+If this option is absent, source address is:
+.RS
+.TP 0.2i
+\(bu
+In DAD mode (with option \fB-D\fR) set to 0.0.0.0.
+.TP 0.2i
+\(bu
+In Unsolicited ARP mode (with options \fB-U\fR or \fB-A\fR)
+set to \fIdestination\fR.
+.TP 0.2i
+\(bu
+Otherwise, it is calculated from routing tables.
+.RE
+.TP
+\fB-U\fR
+Unsolicited ARP mode to update neighbours' ARP caches.
+No replies are expected.
+.TP
+\fB-V\fR
+Print version of the program and exit.
+.TP
+\fB-w \fIdeadline\fB\fR
+Specify a timeout, in seconds, before
+\fBarping\fR
+exits regardless of how many
+packets have been sent or received. In this case
+\fBarping\fR
+does not stop after
+\fIcount\fR
+packet are sent, it waits either for
+\fIdeadline\fR
+expire or until
+\fIcount\fR
+probes are answered.
+.SH "SEE ALSO"
+.PP
+\fBping\fR(8),
+\fBclockdiff\fR(8),
+\fBtracepath\fR(8).
+.SH "AUTHOR"
+.PP
+\fBarping\fR was written by
+Alexey Kuznetsov
+<kuznet@ms2.inr.ac.ru>.
+It is now maintained by
+YOSHIFUJI Hideaki
+<yoshfuji@skbuff.net>.
+.SH "SECURITY"
+.PP
+\fBarping\fR requires CAP_NET_RAW capability
+to be executed. It is not recommended to be used as set-uid root,
+because it allows user to modify ARP caches of neighbour hosts.
+.SH "AVAILABILITY"
+.PP
+\fBarping\fR is part of \fIiputils\fR package
+and the latest versions are  available in source form at
+http://www.skbuff.net/iputils/iputils-current.tar.bz2.
diff -Naur iputils-s20151218.orig/doc/arping.sgml iputils-s20151218/doc/arping.sgml
--- iputils-s20151218.orig/doc/arping.sgml	2015-12-17 15:45:51.000000000 +0000
+++ iputils-s20151218/doc/arping.sgml	2016-05-17 23:17:09.000000000 +0000
@@ -58,8 +58,8 @@
 Stop after sending <replaceable/count/ ARP REQUEST
 packets. With 
 <link linkend="arping.deadline"><replaceable/deadline/</link>
-option, <command/arping/ waits for
-<replaceable/count/ ARP REPLY packets, until the timeout expires.
+option, instead wait for
+<replaceable/count/ ARP REPLY packets, or until the timeout expires.
   </para></listitem>
  </varlistentry>
 
diff -Naur iputils-s20151218.orig/doc/clockdiff.8 iputils-s20151218/doc/clockdiff.8
--- iputils-s20151218.orig/doc/clockdiff.8	1970-01-01 00:00:00.000000000 +0000
+++ iputils-s20151218/doc/clockdiff.8	2016-07-16 01:02:35.127248591 +0000
@@ -0,0 +1,81 @@
+.\" This manpage has been automatically generated by docbook2man 
+.\" from a DocBook document.  This tool can be found at:
+.\" <http://shell.ipoline.com/~elmert/comp/docbook2X/> 
+.\" Please send any bug reports, improvements, comments, patches, 
+.\" etc. to Steve Cheng <steve@ggi-project.org>.
+.TH "CLOCKDIFF" "8" "" "iputils-160308" "System Manager's Manual: iputils"
+.SH NAME
+clockdiff \- measure clock difference between hosts
+.SH SYNOPSIS
+
+\fBclockdiff\fR [\fB-o\fR] [\fB-o1\fR] \fB\fIdestination\fB\fR
+
+.SH "DESCRIPTION"
+.PP
+\fBclockdiff\fR Measures clock difference between us and
+\fIdestination\fR with 1 msec resolution using ICMP TIMESTAMP
+[2]
+packets or, optionally, IP TIMESTAMP option
+[3]
+option added to ICMP ECHO.
+[1]
+.SH "OPTIONS"
+.TP
+\fB-o\fR
+Use IP TIMESTAMP with ICMP ECHO instead of ICMP TIMESTAMP
+messages. It is useful with some destinations, which do not support
+ICMP TIMESTAMP (f.e. Solaris <2.4).
+.TP
+\fB-o1\fR
+Slightly different form of \fB-o\fR, namely it uses three-term
+IP TIMESTAMP with prespecified hop addresses instead of four term one.
+What flavor works better depends on target host. Particularly,
+\fB-o\fR is better for Linux.
+.SH "WARNINGS"
+.TP 0.2i
+\(bu
+Some nodes (Cisco) use non-standard timestamps, which is allowed
+by RFC, but makes timestamps mostly useless.
+.TP 0.2i
+\(bu
+Some nodes generate messed timestamps (Solaris>2.4), when
+run \fBxntpd\fR. Seems, its IP stack uses a corrupted clock source,
+which is synchronized to time-of-day clock periodically and jumps
+randomly making timestamps mostly useless. Good news is that you can
+use NTP in this case, which is even better.
+.TP 0.2i
+\(bu
+\fBclockdiff\fR shows difference in time modulo 24 days.
+.SH "SEE ALSO"
+.PP
+\fBping\fR(8),
+\fBarping\fR(8),
+\fBtracepath\fR(8).
+.SH "REFERENCES"
+.PP
+[1] ICMP ECHO,
+RFC0792, page 14.
+.PP
+[2] ICMP TIMESTAMP,
+RFC0792, page 16.
+.PP
+[3] IP TIMESTAMP option,
+RFC0791, 3.1, page 16.
+.SH "AUTHOR"
+.PP
+\fBclockdiff\fR was compiled by
+Alexey Kuznetsov
+<kuznet@ms2.inr.ac.ru>. It was based on code borrowed
+from BSD \fBtimed\fR daemon.
+It is now maintained by
+YOSHIFUJI Hideaki
+<yoshfuji@skbuff.net>.
+.SH "SECURITY"
+.PP
+\fBclockdiff\fR requires CAP_NET_RAW capability
+to be executed. It is safe to be used as set-uid root.
+.SH "AVAILABILITY"
+.PP
+\fBclockdiff\fR is part of \fIiputils\fR package
+and the latest versions are  available in source form at
+http://www.skbuff.net/iputils/iputils-current.tar.bz2.
diff -Naur iputils-s20151218.orig/doc/docbook2man-spec.pl iputils-s20151218/doc/docbook2man-spec.pl
--- iputils-s20151218.orig/doc/docbook2man-spec.pl	2015-12-17 15:45:51.000000000 +0000
+++ iputils-s20151218/doc/docbook2man-spec.pl	2016-05-17 23:17:09.000000000 +0000
@@ -266,7 +266,7 @@
 .\\" etc. to Steve Cheng <steve\@ggi-project.org>.
 _END_BANNER
 
-	my $manpage_date = `date "+%d %B %Y"`;
+	my $manpage_date = (@ARGV == 1) ? $ARGV[0] : `date "+%d %B %Y"`;
 		
 	output '.TH "';
 	
@@ -280,7 +280,7 @@
 	}
 	
 	output  '" "', fold_string($manpage_sect), 
-		'" "', fold_string(`date "+%d %B %Y"`), 
+		'" "', fold_string($manpage_date),
 		'" "', $manpage_misc, 
 		'" "', $manpage_manual, 
 		"\"\n";
diff -Naur iputils-s20151218.orig/doc/.gitignore iputils-s20151218/doc/.gitignore
--- iputils-s20151218.orig/doc/.gitignore	1970-01-01 00:00:00.000000000 +0000
+++ iputils-s20151218/doc/.gitignore	2016-05-17 23:17:09.000000000 +0000
@@ -0,0 +1,2 @@
+*.html
+*.8
diff -Naur iputils-s20151218.orig/doc/index.html iputils-s20151218/doc/index.html
--- iputils-s20151218.orig/doc/index.html	1970-01-01 00:00:00.000000000 +0000
+++ iputils-s20151218/doc/index.html	2016-07-16 01:02:47.447153591 +0000
@@ -0,0 +1,175 @@
+<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN""http://www.w3.org/TR/html4/loose.dtd">
+<HTML
+><HEAD
+><TITLE
+>System Manager's Manual: iputils</TITLE
+><META
+NAME="GENERATOR"
+CONTENT="Modular DocBook HTML Stylesheet Version 1.79"><LINK
+REL="NEXT"
+TITLE="ping"
+HREF="r3.html"></HEAD
+><BODY
+CLASS="REFERENCE"
+BGCOLOR="#FFFFFF"
+TEXT="#000000"
+LINK="#0000FF"
+VLINK="#840084"
+ALINK="#0000FF"
+><DIV
+CLASS="NAVHEADER"
+><TABLE
+SUMMARY="Header navigation table"
+WIDTH="100%"
+BORDER="0"
+CELLPADDING="0"
+CELLSPACING="0"
+><TR
+><TD
+WIDTH="10%"
+ALIGN="left"
+VALIGN="bottom"
+>&nbsp;</TD
+><TD
+WIDTH="80%"
+ALIGN="center"
+VALIGN="bottom"
+></TD
+><TD
+WIDTH="10%"
+ALIGN="right"
+VALIGN="bottom"
+><A
+HREF="r3.html"
+ACCESSKEY="N"
+>Next</A
+></TD
+></TR
+></TABLE
+><HR
+ALIGN="LEFT"
+WIDTH="100%"></DIV
+><DIV
+CLASS="REFERENCE"
+><A
+NAME="INDEX"
+></A
+><DIV
+CLASS="TITLEPAGE"
+><H1
+CLASS="TITLE"
+>I. System Manager's Manual: iputils</H1
+><DIV
+CLASS="TOC"
+><DL
+><DT
+><B
+>Table of Contents</B
+></DT
+><DT
+><A
+HREF="r3.html"
+>ping</A
+>&nbsp;--&nbsp;send ICMP ECHO_REQUEST to network hosts</DT
+><DT
+><A
+HREF="r483.html"
+>arping</A
+>&nbsp;--&nbsp;send ARP REQUEST to a neighbour host</DT
+><DT
+><A
+HREF="r641.html"
+>clockdiff</A
+>&nbsp;--&nbsp;measure clock difference between hosts</DT
+><DT
+><A
+HREF="r736.html"
+>rarpd</A
+>&nbsp;--&nbsp;answer RARP REQUESTs</DT
+><DT
+><A
+HREF="r835.html"
+>tracepath</A
+>&nbsp;--&nbsp;traces path to a network host discovering MTU along this path</DT
+><DT
+><A
+HREF="r942.html"
+>traceroute6</A
+>&nbsp;--&nbsp;traces path to a network host</DT
+><DT
+><A
+HREF="r1007.html"
+>tftpd</A
+>&nbsp;--&nbsp;Trivial File Transfer Protocol server</DT
+><DT
+><A
+HREF="r1080.html"
+>ninfod</A
+>&nbsp;--&nbsp;Respond to IPv6 Node Information Queries</DT
+><DT
+><A
+HREF="r1149.html"
+>rdisc</A
+>&nbsp;--&nbsp;network router discovery daemon</DT
+><DT
+><A
+HREF="r1293.html"
+>pg3</A
+>&nbsp;--&nbsp;send stream of UDP packets</DT
+></DL
+></DIV
+></DIV
+></DIV
+><DIV
+CLASS="NAVFOOTER"
+><HR
+ALIGN="LEFT"
+WIDTH="100%"><TABLE
+SUMMARY="Footer navigation table"
+WIDTH="100%"
+BORDER="0"
+CELLPADDING="0"
+CELLSPACING="0"
+><TR
+><TD
+WIDTH="33%"
+ALIGN="left"
+VALIGN="top"
+>&nbsp;</TD
+><TD
+WIDTH="34%"
+ALIGN="center"
+VALIGN="top"
+>&nbsp;</TD
+><TD
+WIDTH="33%"
+ALIGN="right"
+VALIGN="top"
+><A
+HREF="r3.html"
+ACCESSKEY="N"
+>Next</A
+></TD
+></TR
+><TR
+><TD
+WIDTH="33%"
+ALIGN="left"
+VALIGN="top"
+>&nbsp;</TD
+><TD
+WIDTH="34%"
+ALIGN="center"
+VALIGN="top"
+>&nbsp;</TD
+><TD
+WIDTH="33%"
+ALIGN="right"
+VALIGN="top"
+>ping</TD
+></TR
+></TABLE
+></DIV
+></BODY
+></HTML
+>
\ No newline at end of file
diff -Naur iputils-s20151218.orig/doc/Makefile iputils-s20151218/doc/Makefile
--- iputils-s20151218.orig/doc/Makefile	2015-12-17 15:45:51.000000000 +0000
+++ iputils-s20151218/doc/Makefile	2016-05-17 23:17:09.000000000 +0000
@@ -1,3 +1,5 @@
+SHELL:=/bin/bash #required for pushd and popd
+
 SGMLFILES=$(shell echo *.sgml)
 HTMLFILES=$(subst .sgml,.html,$(SGMLFILES)) index.html
 MANFILES=$(subst .sgml,.8,$(SGMLFILES))
@@ -6,35 +8,50 @@
 
 html: $(HTMLFILES) iputils.html
 
-man: $(MANFILES)
+man: $(MANFILES) fix_sgml2man
 
 # docbook scripts are incredibly dirty in the sense that they leak
 # lots of some strange temporary junk directories and files.
 # So, scope it to a temporary dir and clean all after each run.
 
+SETUP_TMPDIR = \
+	t="tmp.db2html.$@"; \
+	rm -rf $$t; \
+	mkdir $$t; \
+	pushd $$t >/dev/null
+CLEAN_TMPDIR = \
+	popd >/dev/null; \
+	rm -rf $$t
+
+MAKE_HTML = \
+	@set -e; \
+	$(SETUP_TMPDIR); \
+	docbook2html ../$<; \
+	mv *.html ..; \
+	$(CLEAN_TMPDIR)
+
 $(HTMLFILES): index.db
-	@-rm -rf tmp.db2html
-	@mkdir tmp.db2html
-	@set -e; cd tmp.db2html; docbook2html ../$< ; mv *.html ..
-	@-rm -rf tmp.db2html
+	$(MAKE_HTML)
 
 iputils.html: iputils.db
-	@-rm -rf tmp.db2html
-	@mkdir tmp.db2html
-	@set -e; cd tmp.db2html; docbook2html -u -o html ../$< ; mv html/$@ ..
-	@-rm -rf tmp.db2html
+	$(MAKE_HTML)
 
 # docbook2man produces utterly ugly output and I did not find
 # any way to customize this but hacking backend perl script a little.
 # Well, hence...
 
 $(MANFILES): index.db
-	@-mkdir tmp.db2man
-	@set -e; cd tmp.db2man; nsgmls ../$< | sgmlspl ../docbook2man-spec.pl ;	mv $@ ..
-	@-rm -rf tmp.db2man
+	@set -e; \
+	$(SETUP_TMPDIR); \
+	nsgmls ../$< | sgmlspl ../docbook2man-spec.pl ""; \
+	mv $@ ..; \
+	$(CLEAN_TMPDIR)
+
+fix_sgml2man:
+	@sed -i -e 's!\\fB\\fIdestination\\fB\\fR \[\\fB/\\fIport\\fB\\fR\]!\\fB\\fIdestination\\fB\\fR[\\fB/\\fIport\\fB\\fR]!g' tracepath.8
 
 clean:
-	@rm -rf $(MANFILES) $(HTMLFILES) iputils.html tmp.db2html tmp.db2man
+	@rm -rf $(MANFILES) $(HTMLFILES) iputils.html tmp.db2html* tmp.db2man*
 
 snapshot:
 	@date "+%y%m%d" > snapshot.db
diff -Naur iputils-s20151218.orig/doc/ninfod.8 iputils-s20151218/doc/ninfod.8
--- iputils-s20151218.orig/doc/ninfod.8	1970-01-01 00:00:00.000000000 +0000
+++ iputils-s20151218/doc/ninfod.8	2016-07-16 01:02:35.307247203 +0000
@@ -0,0 +1,72 @@
+.\" This manpage has been automatically generated by docbook2man 
+.\" from a DocBook document.  This tool can be found at:
+.\" <http://shell.ipoline.com/~elmert/comp/docbook2X/> 
+.\" Please send any bug reports, improvements, comments, patches, 
+.\" etc. to Steve Cheng <steve@ggi-project.org>.
+.TH "NINFOD" "8" "" "iputils-160308" "System Manager's Manual: iputils"
+.SH NAME
+ninfod \- Respond to IPv6 Node Information Queries
+.SH SYNOPSIS
+
+\fBninfod\fR [\fB-dhv\fR] [\fB-p \fIpidfile\fB\fR] [\fB-u \fIuser\fB\fR]
+
+.SH "DESCRIPTION"
+.PP
+Responds to IPv6 Node Information Queries (RFC4620) from clients.
+Queries can be sent by various implementations of \fBping6\fR command.
+.SH "OPTIONS"
+.TP
+\fB-a\fR
+Debug mode.  Do not go background.
+.TP
+\fB-h\fR
+Show help.
+.TP
+\fB-v\fR
+Verbose mode.
+.TP
+\fB-u \fIuser\fB\fR
+Run as another user.
+\fIuser\fR can either be username or user ID.
+.TP
+\fB-p \fIpidfile\fB\fR
+File for process-id storage.
+\fIuser\fR is required to be able to create the file.
+.SH "SEE ALSO"
+.PP
+\fBping\fR(8).
+.SH "AUTHOR"
+.PP
+\fBninfod\fR was written by USAGI/WIDE Project.
+.SH "COPYING"
+.PP
+
+.nf
+Copyright (C) 2012 YOSHIFUJI Hideaki.
+Copyright (C) 2002 USAGI/WIDE Project.
+All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions
+are met:
+1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+   notice, this list of conditions and the following disclaimer in the
+   documentation and/or other materials provided with the distribution.
+3. Neither the name of the project nor the names of its contributors
+   may be used to endorse or promote products derived from this software
+   without specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE PROJECT AND CONTRIBUTORS ``AS IS'' AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ARE DISCLAIMED.  IN NO EVENT SHALL THE PROJECT OR CONTRIBUTORS BE LIABLE
+FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+SUCH DAMAGE.
+.fi
diff -Naur iputils-s20151218.orig/doc/pg3.8 iputils-s20151218/doc/pg3.8
--- iputils-s20151218.orig/doc/pg3.8	1970-01-01 00:00:00.000000000 +0000
+++ iputils-s20151218/doc/pg3.8	2016-07-16 01:02:34.927250133 +0000
@@ -0,0 +1,86 @@
+.\" This manpage has been automatically generated by docbook2man 
+.\" from a DocBook document.  This tool can be found at:
+.\" <http://shell.ipoline.com/~elmert/comp/docbook2X/> 
+.\" Please send any bug reports, improvements, comments, patches, 
+.\" etc. to Steve Cheng <steve@ggi-project.org>.
+.TH "PG3" "8" "" "iputils-160308" "System Manager's Manual: iputils"
+.SH NAME
+pg3, ipg, pgset \- send stream of UDP packets
+.SH SYNOPSIS
+
+\fBsource ipg\fR
+
+
+\fBpg\fR
+
+
+\fBpgset\fR \fB\fICOMMAND\fB\fR
+
+.SH "DESCRIPTION"
+.PP
+\fBipg\fR is not a program, it is script which should be sourced
+to \fBbash\fR. When sourced it loads module \fIpg3\fR and
+exports a few of functions accessible from parent shell. These macros
+are \fBpg\fR to start packet injection and to get the results of run;
+and \fBpgset\fR to setup packet generator.
+.PP
+\fBpgset\fR can send the following commands to module \fIpg3\fR:
+.SH "COMMAND"
+.TP
+\fBodev \fIDEVICE\fB\fR
+Name of Ethernet device to test. See
+warning below.
+.TP
+\fBpkt_size \fIBYTES\fB\fR
+Size of packet to generate. The size includes all the headers: UDP, IP,
+MAC, but does not account for overhead internal to medium, i.e. FCS
+and various paddings.
+.TP
+\fBfrags \fINUMBER\fB\fR
+Each packet will contain \fINUMBER\fR of fragments.
+Maximal amount for linux-2.4 is 6. Far not all the devices support
+fragmented buffers.
+.TP
+\fBcount \fINUMBER\fB\fR
+Send stream of \fINUMBER\fR of packets and stop after this.
+.TP
+\fBipg \fITIME\fB\fR
+Introduce artificial delay between packets of \fITIME\fR
+microseconds.
+.TP
+\fBdst \fIIP_ADDRESS\fB\fR
+Select IP destination where the stream is sent to.
+Beware, never set this address at random. \fBpg3\fR is not a toy,
+it creates really tough stream. Default value is 0.0.0.0.
+.TP
+\fBdst \fIMAC_ADDRESS\fB\fR
+Select MAC destination where the stream is sent to.
+Default value is 00:00:00:00:00:00 in hope that this will not be received
+by any node on LAN.
+.TP
+\fBstop\fR
+Abort packet injection.
+.SH "WARNING"
+.PP
+When output device is set to some random device different
+of hardware Ethernet device, \fBpg3\fR will crash kernel.
+.PP
+Do not use it on VLAN, ethertap, VTUN and other devices,
+which emulate Ethernet not being real Ethernet in fact.
+.SH "AUTHOR"
+.PP
+\fBpg3\fR was written by Robert Olsson <robert.olsson@its.uu.se>.
+.SH "SECURITY"
+.PP
+This can be used only by superuser.
+.PP
+This tool creates floods of packets which is unlikely to be handled
+even by high-end machines. For example, it saturates gigabit link with
+60 byte packets when used with Intel's e1000. In face of such stream
+switches, routers and end hosts may deadlock, crash, explode.
+Use only in test lab environment.
+.SH "AVAILABILITY"
+.PP
+\fBpg3\fR is part of \fIiputils\fR package
+and the latest versions are  available in source form at
+http://www.skbuff.net/iputils/iputils-current.tar.bz2.
diff -Naur iputils-s20151218.orig/doc/ping.8 iputils-s20151218/doc/ping.8
--- iputils-s20151218.orig/doc/ping.8	1970-01-01 00:00:00.000000000 +0000
+++ iputils-s20151218/doc/ping.8	2016-07-16 01:02:35.017249439 +0000
@@ -0,0 +1,447 @@
+.\" This manpage has been automatically generated by docbook2man 
+.\" from a DocBook document.  This tool can be found at:
+.\" <http://shell.ipoline.com/~elmert/comp/docbook2X/> 
+.\" Please send any bug reports, improvements, comments, patches, 
+.\" etc. to Steve Cheng <steve@ggi-project.org>.
+.TH "PING" "8" "" "iputils-160308" "System Manager's Manual: iputils"
+.SH NAME
+ping \- send ICMP ECHO_REQUEST to network hosts
+.SH SYNOPSIS
+
+\fBping\fR [\fB-aAbBdDfhLnOqrRUvV46\fR] [\fB-c \fIcount\fB\fR] [\fB-F \fIflowlabel\fB\fR] [\fB-i \fIinterval\fB\fR] [\fB-I \fIinterface\fB\fR] [\fB-l \fIpreload\fB\fR] [\fB-m \fImark\fB\fR] [\fB-M \fIpmtudisc_option\fB\fR] [\fB-N \fInodeinfo_option\fB\fR] [\fB-w \fIdeadline\fB\fR] [\fB-W \fItimeout\fB\fR] [\fB-p \fIpattern\fB\fR] [\fB-Q \fItos\fB\fR] [\fB-s \fIpacketsize\fB\fR] [\fB-S \fIsndbuf\fB\fR] [\fB-t \fIttl\fB\fR] [\fB-T \fItimestamp option\fB\fR] [\fB\fIhop\fB\fR\fI ...\fR] \fB\fIdestination\fB\fR
+
+.SH "DESCRIPTION"
+.PP
+\fBping\fR uses the ICMP protocol's mandatory ECHO_REQUEST
+datagram to elicit an ICMP ECHO_RESPONSE from a host or gateway.
+ECHO_REQUEST datagrams (``pings'') have an IP and ICMP
+header, followed by a struct timeval and then an arbitrary
+number of ``pad'' bytes used to fill out the packet.
+.PP
+\fBping\fR works with both IPv4 and IPv6. Using only one of them
+explicitly can be enforced by specifying \fB-4\fR or \fB-6\fR.
+.PP
+\fBping\fR can also send IPv6 Node Information Queries (RFC4620).
+Intermediate \fIhop\fRs may not be allowed, because IPv6 source routing was deprecated (RFC5095).
+.SH "OPTIONS"
+.TP
+\fB-4\fR
+Use IPv4 only.
+.TP
+\fB-6\fR
+Use IPv6 only.
+.TP
+\fB-a\fR
+Audible ping.
+.TP
+\fB-A\fR
+Adaptive ping. Interpacket interval adapts to round-trip time, so that
+effectively not more than one (or more, if preload is set) unanswered probe
+is present in the network. Minimal interval is 200msec for not super-user.
+On networks with low rtt this mode is essentially equivalent to flood mode.  
+.TP
+\fB-b\fR
+Allow pinging a broadcast address.
+.TP
+\fB-B\fR
+Do not allow \fBping\fR to change source address of probes.
+The address is bound to one selected when \fBping\fR starts.
+.TP
+\fB-c \fIcount\fB\fR
+Stop after sending \fIcount\fR ECHO_REQUEST
+packets. With 
+\fIdeadline\fR
+option, \fBping\fR waits for
+\fIcount\fR ECHO_REPLY packets, until the timeout expires.
+.TP
+\fB-d\fR
+Set the SO_DEBUG option on the socket being used.
+Essentially, this socket option is not used by Linux kernel. 
+.TP
+\fB-D\fR
+Print timestamp (unix time + microseconds as in gettimeofday) before
+each line.
+.TP
+\fB-f\fR
+Flood ping. For every ECHO_REQUEST sent a period ``.'' is printed,
+while for ever ECHO_REPLY received a backspace is printed.
+This provides a rapid display of how many packets are being dropped.
+If interval is not given, it sets interval to zero and
+outputs packets as fast as they come back or one hundred times per second,
+whichever is more.
+Only the super-user may use this option with zero interval.
+.TP
+\fB-F \fIflow label\fB\fR
+IPv6 only.
+Allocate and set 20 bit flow label (in hex) on echo request packets.
+If value is zero, kernel allocates random flow label.
+.TP
+\fB-h\fR
+Show help.
+.TP
+\fB-i \fIinterval\fB\fR
+Wait \fIinterval\fR seconds between sending each packet.
+The default is to wait for one second between each packet normally,
+or not to wait in flood mode. Only super-user may set interval
+to values less 0.2 seconds.
+.TP
+\fB-I \fIinterface\fB\fR
+\fIinterface\fR is either an address, or an interface name.
+If \fIinterface\fR is an address, it sets source address
+to specified interface address.
+If \fIinterface\fR in an interface name, it sets
+source interface to specified interface.
+For IPv6, when doing ping to a link-local scope
+address, link specification (by the '%'-notation in
+\fIdestination\fR, or by this option) is required.
+.TP
+\fB-l \fIpreload\fB\fR
+If \fIpreload\fR is specified,
+\fBping\fR sends that many packets not waiting for reply.
+Only the super-user may select preload more than 3.
+.TP
+\fB-L\fR
+Suppress loopback of multicast packets.  This flag only applies if the ping
+destination is a multicast address.
+.TP
+\fB-m \fImark\fB\fR
+use \fImark\fR to tag the packets going out. This is useful
+for variety of reasons within the kernel such as using policy
+routing to select specific outbound processing.
+.TP
+\fB-M \fIpmtudisc_opt\fB\fR
+Select Path MTU Discovery strategy.
+\fIpmtudisc_option\fR may be either \fIdo\fR
+(prohibit fragmentation, even local one), 
+\fIwant\fR (do PMTU discovery, fragment locally when packet size
+is large), or \fIdont\fR (do not set DF flag).
+.TP
+\fB-N \fInodeinfo_option\fB\fR
+IPv6 only.
+Send ICMPv6 Node Information Queries (RFC4620), instead of Echo Request.
+CAP_NET_RAW capability is required.
+.RS
+.TP
+\fBhelp\fR
+Show help for NI support.
+.RE
+.RS
+.TP
+\fBname\fR
+Queries for Node Names.
+.RE
+.RS
+.TP
+\fBipv6\fR
+Queries for IPv6 Addresses. There are several IPv6 specific flags.
+.RS
+.TP
+\fBipv6-global\fR
+Request IPv6 global-scope addresses.
+.RE
+.RS
+.TP
+\fBipv6-sitelocal\fR
+Request IPv6 site-local addresses.
+.RE
+.RS
+.TP
+\fBipv6-linklocal\fR
+Request IPv6 link-local addresses.
+.RE
+.RS
+.TP
+\fBipv6-all\fR
+Request IPv6 addresses on other interfaces.
+.RE
+.RE
+.RS
+.TP
+\fBipv4\fR
+Queries for IPv4 Addresses.  There is one IPv4 specific flag.
+.RS
+.TP
+\fBipv4-all\fR
+Request IPv4 addresses on other interfaces.
+.RE
+.RE
+.RS
+.TP
+\fBsubject-ipv6=\fIipv6addr\fB\fR
+IPv6 subject address.
+.RE
+.RS
+.TP
+\fBsubject-ipv4=\fIipv4addr\fB\fR
+IPv4 subject address.
+.RE
+.RS
+.TP
+\fBsubject-name=\fInodename\fB\fR
+Subject name.  If it contains more than one dot,
+fully-qualified domain name is assumed.
+.RE
+.RS
+.TP
+\fBsubject-fqdn=\fInodename\fB\fR
+Subject name.  Fully-qualified domain name is
+always assumed.
+.RE
+.TP
+\fB-n\fR
+Numeric output only.
+No attempt will be made to lookup symbolic names for host addresses.
+.TP
+\fB-O\fR
+Report outstanding ICMP ECHO reply before sending next packet.
+This is useful together with the timestamp \fB-D\fR to
+log output to a diagnostic file and search for missing answers.
+.TP
+\fB-p \fIpattern\fB\fR
+You may specify up to 16 ``pad'' bytes to fill out the packet you send.
+This is useful for diagnosing data-dependent problems in a network.
+For example, \fB-p ff\fR will cause the sent packet
+to be filled with all ones.
+.TP
+\fB-q\fR
+Quiet output.
+Nothing is displayed except the summary lines at startup time and
+when finished.
+.TP
+\fB-Q \fItos\fB\fR
+Set Quality of Service -related bits in ICMP datagrams.
+\fItos\fR can be decimal (\fBping\fR only) or hex number.
+
+In RFC2474, these fields are interpreted as 8-bit Differentiated
+Services (DS), consisting of: bits 0-1 (2 lowest bits) of separate
+data, and bits 2-7 (highest 6 bits) of Differentiated Services
+Codepoint (DSCP).  In RFC2481 and RFC3168, bits 0-1 are used for ECN.
+
+Historically (RFC1349, obsoleted by RFC2474), these were interpreted
+as: bit 0 (lowest bit) for reserved (currently being redefined as
+congestion control), 1-4 for Type of Service and bits 5-7
+(highest bits) for Precedence.
+.TP
+\fB-r\fR
+Bypass the normal routing tables and send directly to a host on an attached
+interface.
+If the host is not on a directly-attached network, an error is returned.
+This option can be used to ping a local host through an interface
+that has no route through it provided the option \fB-I\fR is also
+used.
+.TP
+\fB-R\fR
+\fBping\fR only.
+Record route.
+Includes the RECORD_ROUTE option in the ECHO_REQUEST
+packet and displays the route buffer on returned packets.
+Note that the IP header is only large enough for nine such routes.
+Many hosts ignore or discard this option.
+.TP
+\fB-s \fIpacketsize\fB\fR
+Specifies the number of data bytes to be sent.  
+The default is 56, which translates into 64 ICMP
+data bytes when combined with the 8 bytes of ICMP header data.
+.TP
+\fB-S \fIsndbuf\fB\fR
+Set socket sndbuf. If not specified, it is selected to buffer
+not more than one packet.
+.TP
+\fB-t \fIttl\fB\fR
+\fBping\fR only.
+Set the IP Time to Live.
+.TP
+\fB-T \fItimestamp option\fB\fR
+Set special IP timestamp options.
+\fItimestamp option\fR may be either 
+\fItsonly\fR (only timestamps), 
+\fItsandaddr\fR (timestamps and addresses) or 
+\fItsprespec host1 [host2 [host3 [host4]]]\fR
+(timestamp prespecified hops).
+.TP
+\fB-U\fR
+Print full user-to-user latency (the old behaviour). Normally
+\fBping\fR
+prints network round trip time, which can be different
+f.e. due to DNS failures. 
+.TP
+\fB-v\fR
+Verbose output.
+.TP
+\fB-V\fR
+Show version and exit.
+.TP
+\fB-w \fIdeadline\fB\fR
+Specify a timeout, in seconds, before
+\fBping\fR
+exits regardless of how many
+packets have been sent or received. In this case
+\fBping\fR
+does not stop after
+\fIcount\fR
+packet are sent, it waits either for
+\fIdeadline\fR
+expire or until
+\fIcount\fR
+probes are answered or for some error notification from network.   
+.TP
+\fB-W \fItimeout\fB\fR
+Time to wait for a response, in seconds. The option affects only timeout
+in absence of any responses, otherwise \fBping\fR waits for two RTTs.
+.PP
+When using \fBping\fR for fault isolation, it should first be run
+on the local host, to verify that the local network interface is up
+and running. Then, hosts and gateways further and further away should be
+``pinged''. Round-trip times and packet loss statistics are computed.
+If duplicate packets are received, they are not included in the packet
+loss calculation, although the round trip time of these packets is used
+in calculating the minimum/average/maximum round-trip time numbers.
+When the specified number of packets have been sent (and received) or
+if the program is terminated with a
+SIGINT, a brief summary is displayed. Shorter current statistics
+can be obtained without termination of process with signal
+SIGQUIT.
+.PP
+If \fBping\fR does not receive any reply packets at all it will
+exit with code 1. If a packet 
+\fIcount\fR
+and
+\fIdeadline\fR
+are both specified, and fewer than
+\fIcount\fR
+packets are received by the time the
+\fIdeadline\fR
+has arrived, it will also exit with code 1. 
+On other error it exits with code 2. Otherwise it exits with code 0. This
+makes it possible to use the exit code to see if a host is alive or
+not.
+.PP
+This program is intended for use in network testing, measurement and
+management.
+Because of the load it can impose on the network, it is unwise to use
+\fBping\fR during normal operations or from automated scripts.
+.SH "ICMP PACKET DETAILS"
+.PP
+An IP header without options is 20 bytes.
+An ICMP ECHO_REQUEST packet contains an additional 8 bytes worth
+of ICMP header followed by an arbitrary amount of data.
+When a \fIpacketsize\fR is given, this indicated the size of this
+extra piece of data (the default is 56). Thus the amount of data received
+inside of an IP packet of type ICMP ECHO_REPLY will always be 8 bytes
+more than the requested data space (the ICMP header).
+.PP
+If the data space is at least of size of struct timeval
+\fBping\fR uses the beginning bytes of this space to include
+a timestamp which it uses in the computation of round trip times.
+If the data space is shorter, no round trip times are given.
+.SH "DUPLICATE AND DAMAGED PACKETS"
+.PP
+\fBping\fR will report duplicate and damaged packets.
+Duplicate packets should never occur, and seem to be caused by
+inappropriate link-level retransmissions.
+Duplicates may occur in many situations and are rarely (if ever) a
+good sign, although the presence of low levels of duplicates may not
+always be cause for alarm.
+.PP
+Damaged packets are obviously serious cause for alarm and often
+indicate broken hardware somewhere in the
+\fBping\fR packet's path (in the network or in the hosts).
+.SH "TRYING DIFFERENT DATA PATTERNS"
+.PP
+The (inter)network layer should never treat packets differently depending
+on the data contained in the data portion.
+Unfortunately, data-dependent problems have been known to sneak into
+networks and remain undetected for long periods of time.
+In many cases the particular pattern that will have problems is something
+that doesn't have sufficient ``transitions'', such as all ones or all
+zeros, or a pattern right at the edge, such as almost all zeros.
+It isn't necessarily enough to specify a data pattern of all zeros (for
+example) on the command line because the pattern that is of interest is
+at the data link level, and the relationship between what you type and
+what the controllers transmit can be complicated.
+.PP
+This means that if you have a data-dependent problem you will probably
+have to do a lot of testing to find it.
+If you are lucky, you may manage to find a file that either can't be sent
+across your network or that takes much longer to transfer than other
+similar length files.
+You can then examine this file for repeated patterns that you can test
+using the \fB-p\fR option of \fBping\fR.
+.SH "TTL DETAILS"
+.PP
+The TTL value of an IP packet represents the maximum number of IP routers
+that the packet can go through before being thrown away.
+In current practice you can expect each router in the Internet to decrement
+the TTL field by exactly one.
+.PP
+The TCP/IP specification states that the TTL field for TCP
+packets should be set to 60, but many systems use smaller values
+(4.3 BSD uses 30, 4.2 used 15).
+.PP
+The maximum possible value of this field is 255, and most Unix systems set
+the TTL field of ICMP ECHO_REQUEST packets to 255.
+This is why you will find you can ``ping'' some hosts, but not reach them
+with
+\fBtelnet\fR(1)
+or
+\fBftp\fR(1).
+.PP
+In normal operation ping prints the TTL value from the packet it receives.
+When a remote system receives a ping packet, it can do one of three things
+with the TTL field in its response:
+.TP 0.2i
+\(bu
+Not change it; this is what Berkeley Unix systems did before the
+4.3BSD Tahoe release. In this case the TTL value in the received packet
+will be 255 minus the number of routers in the round-trip path.
+.TP 0.2i
+\(bu
+Set it to 255; this is what current Berkeley Unix systems do.
+In this case the TTL value in the received packet will be 255 minus the
+number of routers in the path \fBfrom\fR
+the remote system \fBto\fR the \fBping\fRing host.
+.TP 0.2i
+\(bu
+Set it to some other value. Some machines use the same value for
+ICMP packets that they use for TCP packets, for example either 30 or 60.
+Others may use completely wild values.
+.SH "BUGS"
+.TP 0.2i
+\(bu
+Many Hosts and Gateways ignore the RECORD_ROUTE option.
+.TP 0.2i
+\(bu
+The maximum IP header length is too small for options like
+RECORD_ROUTE to be completely useful.
+There's not much that can be done about this, however.
+.TP 0.2i
+\(bu
+Flood pinging is not recommended in general, and flood pinging the
+broadcast address should only be done under very controlled conditions.
+.SH "SEE ALSO"
+.PP
+\fBnetstat\fR(1),
+\fBifconfig\fR(8).
+.SH "HISTORY"
+.PP
+The \fBping\fR command appeared in 4.3BSD.
+.PP
+The version described here is its descendant specific to Linux.
+.PP
+As of version s20150815, the \fBping6\fR binary doesn't exist anymore.
+It has been merged into \fBping\fR. Creating a symlink named
+\fBping6\fR pointing to \fBping\fR will result in the same
+funcionality as before.
+.SH "SECURITY"
+.PP
+\fBping\fR requires CAP_NET_RAW capability
+to be executed 1) if the program is used for non-echo queries
+(See \fB-N\fR option), or 2) if kernel does not
+support non-raw ICMP sockets, or 3) if the user is not allowed
+to create an ICMP echo socket.  The program may be used as
+set-uid root.
+.SH "AVAILABILITY"
+.PP
+\fBping\fR is part of \fIiputils\fR package
+and the latest versions are  available in source form at
+http://www.skbuff.net/iputils/iputils-current.tar.bz2.
diff -Naur iputils-s20151218.orig/doc/ping.sgml iputils-s20151218/doc/ping.sgml
--- iputils-s20151218.orig/doc/ping.sgml	2015-12-17 15:45:51.000000000 +0000
+++ iputils-s20151218/doc/ping.sgml	2016-05-17 23:17:09.000000000 +0000
@@ -7,14 +7,14 @@
 </refmeta>
 
 <refnamediv>
-<refname>ping, ping6</refname>
+<refname>ping</refname>
 <refpurpose>send ICMP ECHO_REQUEST to network hosts</refpurpose>
 </refnamediv>
 
 <refsynopsisdiv>
 <cmdsynopsis>
 <command>ping</command>
-<arg choice="opt"><option>-aAbBdDfhLnOqrRUvV</option></arg>
+<arg choice="opt"><option>-aAbBdDfhLnOqrRUvV46</option></arg>
 <arg choice="opt">-c <replaceable/count/</arg>
 <arg choice="opt">-F <replaceable/flowlabel/</arg>
 <arg choice="opt">-i <replaceable/interval/</arg>
@@ -45,7 +45,11 @@
 number of ``pad'' bytes used to fill out the packet.
 </para>
 <para>
-<command/ping6/ is IPv6 version of <command/ping/, and can also send Node Information Queries (RFC4620).
+<command/ping/ works with both IPv4 and IPv6. Using only one of them
+explicitly can be enforced by specifying <option/-4/ or <option/-6/.
+</para>
+<para>
+<command/ping/ can also send IPv6 Node Information Queries (RFC4620).
 Intermediate <replaceable/hop/s may not be allowed, because IPv6 source routing was deprecated (RFC5095).
 </para>
 </refsect1>
@@ -54,6 +58,18 @@
 
 <variablelist>
  <varlistentry>
+  <term><option/-4/</term>
+  <listitem><para>
+Use IPv4 only.
+  </para></listitem>
+ </varlistentry>
+ <varlistentry>
+  <term><option/-6/</term>
+  <listitem><para>
+Use IPv6 only.
+  </para></listitem>
+ </varlistentry>
+ <varlistentry>
   <term><option/-a/</term>
   <listitem><para>
 Audible ping.
@@ -120,7 +136,7 @@
  <varlistentry>
   <term><option>-F <replaceable/flow label/</option></term>
   <listitem><para>
-<command/ping6/ only.
+IPv6 only.
 Allocate and set 20 bit flow label (in hex) on echo request packets.
 If value is zero, kernel allocates random flow label.
   </para></listitem>
@@ -148,7 +164,7 @@
 to specified interface address.
 If <replaceable/interface/ in an interface name, it sets
 source interface to specified interface.
-For <command/ping6/, when doing ping to a link-local scope
+For IPv6, when doing ping to a link-local scope
 address, link specification (by the '%'-notation in
 <replaceable/destination/, or by this option) is required.
   </para></listitem>
@@ -189,7 +205,7 @@
  <varlistentry>
   <term><option>-N <replaceable/nodeinfo_option/</option></term>
   <listitem><para>
-<command/ping6/ only.
+IPv6 only.
 Send ICMPv6 Node Information Queries (RFC4620), instead of Echo Request.
 <constant/CAP_NET_RAW/ capability is required.
    <variablelist>
@@ -625,6 +641,12 @@
 <para>
 The version described here is its descendant specific to Linux.
 </para>
+<para>
+As of version s20150815, the <command/ping6/ binary doesn't exist anymore.
+It has been merged into <command/ping/. Creating a symlink named
+<command/ping6/ pointing to <command/ping/ will result in the same
+funcionality as before.
+</para>
 </refsect1>
 
 <refsect1><title>SECURITY</title>
diff -Naur iputils-s20151218.orig/doc/r1007.html iputils-s20151218/doc/r1007.html
--- iputils-s20151218.orig/doc/r1007.html	1970-01-01 00:00:00.000000000 +0000
+++ iputils-s20151218/doc/r1007.html	2016-07-16 01:02:47.317154594 +0000
@@ -0,0 +1,376 @@
+<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN""http://www.w3.org/TR/html4/loose.dtd">
+<HTML
+><HEAD
+><TITLE
+>tftpd</TITLE
+><META
+NAME="GENERATOR"
+CONTENT="Modular DocBook HTML Stylesheet Version 1.79"><LINK
+REL="HOME"
+TITLE="System Manager's Manual: iputils"
+HREF="index.html"><LINK
+REL="PREVIOUS"
+TITLE="traceroute6"
+HREF="r942.html"><LINK
+REL="NEXT"
+TITLE="ninfod"
+HREF="r1080.html"></HEAD
+><BODY
+CLASS="REFENTRY"
+BGCOLOR="#FFFFFF"
+TEXT="#000000"
+LINK="#0000FF"
+VLINK="#840084"
+ALINK="#0000FF"
+><DIV
+CLASS="NAVHEADER"
+><TABLE
+SUMMARY="Header navigation table"
+WIDTH="100%"
+BORDER="0"
+CELLPADDING="0"
+CELLSPACING="0"
+><TR
+><TH
+COLSPAN="3"
+ALIGN="center"
+>System Manager's Manual: iputils</TH
+></TR
+><TR
+><TD
+WIDTH="10%"
+ALIGN="left"
+VALIGN="bottom"
+><A
+HREF="r942.html"
+ACCESSKEY="P"
+>Prev</A
+></TD
+><TD
+WIDTH="80%"
+ALIGN="center"
+VALIGN="bottom"
+></TD
+><TD
+WIDTH="10%"
+ALIGN="right"
+VALIGN="bottom"
+><A
+HREF="r1080.html"
+ACCESSKEY="N"
+>Next</A
+></TD
+></TR
+></TABLE
+><HR
+ALIGN="LEFT"
+WIDTH="100%"></DIV
+><H1
+><A
+NAME="TFTPD"
+></A
+>tftpd</H1
+><DIV
+CLASS="REFNAMEDIV"
+><A
+NAME="AEN1012"
+></A
+><H2
+>Name</H2
+>tftpd&nbsp;--&nbsp;Trivial File Transfer Protocol server</DIV
+><DIV
+CLASS="REFSYNOPSISDIV"
+><A
+NAME="AEN1015"
+></A
+><H2
+>Synopsis</H2
+><P
+><B
+CLASS="COMMAND"
+>tftpd</B
+>  {<TT
+CLASS="REPLACEABLE"
+><I
+>directory</I
+></TT
+>}</P
+></DIV
+><DIV
+CLASS="REFSECT1"
+><A
+NAME="AEN1020"
+></A
+><H2
+>DESCRIPTION</H2
+><P
+><B
+CLASS="COMMAND"
+>tftpd</B
+> is a server which supports the DARPA
+Trivial File Transfer Protocol
+(<A
+HREF="http://tools.ietf.org/rfc/rfc1350.txt"
+TARGET="_top"
+>RFC1350</A
+>).
+The TFTP server is started
+by <SPAN
+CLASS="CITEREFENTRY"
+><SPAN
+CLASS="REFENTRYTITLE"
+>inetd</SPAN
+>(8)</SPAN
+>.</P
+><P
+><TT
+CLASS="REPLACEABLE"
+><I
+>directory</I
+></TT
+> is required argument; if it is not given
+<B
+CLASS="COMMAND"
+>tftpd</B
+> aborts. This path is prepended to any file name requested
+via TFTP protocol, effectively chrooting <B
+CLASS="COMMAND"
+>tftpd</B
+> to this directory.
+File names are validated not to escape out of this directory, however
+administrator may configure such escape using symbolic links.</P
+><P
+>It is in difference of variants of <B
+CLASS="COMMAND"
+>tftpd</B
+> usually distributed
+with unix-like systems, which take a list of directories and match
+file names to start from one of given prefixes or to some random
+default, when no arguments were given. There are two reasons not to
+behave in this way: first, it is inconvenient, clients are not expected
+to know something about layout of filesystem on server host.
+And second, TFTP protocol is not a tool for browsing of server's filesystem,
+it is just an agent allowing to boot dumb clients. </P
+><P
+>In the case when <B
+CLASS="COMMAND"
+>tftpd</B
+> is used together with
+<A
+HREF="r736.html"
+><SPAN
+CLASS="CITEREFENTRY"
+><SPAN
+CLASS="REFENTRYTITLE"
+>rarpd</SPAN
+>(8)</SPAN
+></A
+>,
+tftp directories in these services should coincide and it is expected
+that each client booted via TFTP has boot image corresponding
+its IP address with an architecture suffix following Sun Microsystems
+conventions. See 
+<A
+HREF="r736.html"
+><SPAN
+CLASS="CITEREFENTRY"
+><SPAN
+CLASS="REFENTRYTITLE"
+>rarpd</SPAN
+>(8)</SPAN
+></A
+>
+for more details.</P
+></DIV
+><DIV
+CLASS="REFSECT1"
+><A
+NAME="AEN1044"
+></A
+><H2
+>SECURITY</H2
+><P
+>TFTP protocol does not provide any authentication.
+Due to this capital flaw <B
+CLASS="COMMAND"
+>tftpd</B
+> is not able to restrict
+access to files and will allow only publically readable
+files to be accessed. Files may be written only if they already
+exist and are publically writable.</P
+><P
+>Impact is evident, directory exported via TFTP <SPAN
+CLASS="emphasis"
+><I
+CLASS="EMPHASIS"
+>must not</I
+></SPAN
+>
+contain sensitive information of any kind, everyone is allowed
+to read it as soon as a client is allowed. Boot images do not contain
+such information as rule, however you should think twice before
+publishing f.e. Cisco IOS config files via TFTP, they contain
+<SPAN
+CLASS="emphasis"
+><I
+CLASS="EMPHASIS"
+>unencrypted</I
+></SPAN
+> passwords and may contain some information
+about the network, which you were not going to make public.</P
+><P
+>The <B
+CLASS="COMMAND"
+>tftpd</B
+> server should be executed by <B
+CLASS="COMMAND"
+>inetd</B
+>
+with dropped root privileges, namely with a user ID giving minimal
+access to files published in tftp directory. If it is executed
+as superuser occasionally, <B
+CLASS="COMMAND"
+>tftpd</B
+> drops its UID and GID
+to 65534, which is most likely not the thing which you expect.
+However, this is not very essential; remember, only files accessible
+for everyone can be read or written via TFTP.</P
+></DIV
+><DIV
+CLASS="REFSECT1"
+><A
+NAME="AEN1055"
+></A
+><H2
+>SEE ALSO</H2
+><P
+><A
+HREF="r736.html"
+><SPAN
+CLASS="CITEREFENTRY"
+><SPAN
+CLASS="REFENTRYTITLE"
+>rarpd</SPAN
+>(8)</SPAN
+></A
+>,
+<SPAN
+CLASS="CITEREFENTRY"
+><SPAN
+CLASS="REFENTRYTITLE"
+>tftp</SPAN
+>(1)</SPAN
+>,
+<SPAN
+CLASS="CITEREFENTRY"
+><SPAN
+CLASS="REFENTRYTITLE"
+>inetd</SPAN
+>(8)</SPAN
+>.</P
+></DIV
+><DIV
+CLASS="REFSECT1"
+><A
+NAME="AEN1068"
+></A
+><H2
+>HISTORY</H2
+><P
+>The <B
+CLASS="COMMAND"
+>tftpd</B
+> command appeared in 4.2BSD. The source in iputils
+is cleaned up both syntactically (ANSIized) and semantically (UDP socket IO).</P
+><P
+>It is distributed with iputils mostly as good demo of an interesting feature
+(<CODE
+CLASS="CONSTANT"
+>MSG_CONFIRM</CODE
+>) allowing to boot long images by dumb clients
+not answering ARP requests until they are finally booted.
+However, this is full functional and can be used in production.</P
+></DIV
+><DIV
+CLASS="REFSECT1"
+><A
+NAME="AEN1074"
+></A
+><H2
+>AVAILABILITY</H2
+><P
+><B
+CLASS="COMMAND"
+>tftpd</B
+> is part of <TT
+CLASS="FILENAME"
+>iputils</TT
+> package
+and the latest versions are  available in source form at
+<A
+HREF="http://www.skbuff.net/iputils/iputils-current.tar.bz2"
+TARGET="_top"
+>http://www.skbuff.net/iputils/iputils-current.tar.bz2</A
+>.</P
+></DIV
+><DIV
+CLASS="NAVFOOTER"
+><HR
+ALIGN="LEFT"
+WIDTH="100%"><TABLE
+SUMMARY="Footer navigation table"
+WIDTH="100%"
+BORDER="0"
+CELLPADDING="0"
+CELLSPACING="0"
+><TR
+><TD
+WIDTH="33%"
+ALIGN="left"
+VALIGN="top"
+><A
+HREF="r942.html"
+ACCESSKEY="P"
+>Prev</A
+></TD
+><TD
+WIDTH="34%"
+ALIGN="center"
+VALIGN="top"
+><A
+HREF="index.html"
+ACCESSKEY="H"
+>Home</A
+></TD
+><TD
+WIDTH="33%"
+ALIGN="right"
+VALIGN="top"
+><A
+HREF="r1080.html"
+ACCESSKEY="N"
+>Next</A
+></TD
+></TR
+><TR
+><TD
+WIDTH="33%"
+ALIGN="left"
+VALIGN="top"
+>traceroute6</TD
+><TD
+WIDTH="34%"
+ALIGN="center"
+VALIGN="top"
+>&nbsp;</TD
+><TD
+WIDTH="33%"
+ALIGN="right"
+VALIGN="top"
+>ninfod</TD
+></TR
+></TABLE
+></DIV
+></BODY
+></HTML
+>
\ No newline at end of file
diff -Naur iputils-s20151218.orig/doc/r1080.html iputils-s20151218/doc/r1080.html
--- iputils-s20151218.orig/doc/r1080.html	1970-01-01 00:00:00.000000000 +0000
+++ iputils-s20151218/doc/r1080.html	2016-07-16 01:02:47.367154208 +0000
@@ -0,0 +1,343 @@
+<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN""http://www.w3.org/TR/html4/loose.dtd">
+<HTML
+><HEAD
+><TITLE
+>ninfod</TITLE
+><META
+NAME="GENERATOR"
+CONTENT="Modular DocBook HTML Stylesheet Version 1.79"><LINK
+REL="HOME"
+TITLE="System Manager's Manual: iputils"
+HREF="index.html"><LINK
+REL="PREVIOUS"
+TITLE="tftpd"
+HREF="r1007.html"><LINK
+REL="NEXT"
+TITLE="rdisc"
+HREF="r1149.html"></HEAD
+><BODY
+CLASS="REFENTRY"
+BGCOLOR="#FFFFFF"
+TEXT="#000000"
+LINK="#0000FF"
+VLINK="#840084"
+ALINK="#0000FF"
+><DIV
+CLASS="NAVHEADER"
+><TABLE
+SUMMARY="Header navigation table"
+WIDTH="100%"
+BORDER="0"
+CELLPADDING="0"
+CELLSPACING="0"
+><TR
+><TH
+COLSPAN="3"
+ALIGN="center"
+>System Manager's Manual: iputils</TH
+></TR
+><TR
+><TD
+WIDTH="10%"
+ALIGN="left"
+VALIGN="bottom"
+><A
+HREF="r1007.html"
+ACCESSKEY="P"
+>Prev</A
+></TD
+><TD
+WIDTH="80%"
+ALIGN="center"
+VALIGN="bottom"
+></TD
+><TD
+WIDTH="10%"
+ALIGN="right"
+VALIGN="bottom"
+><A
+HREF="r1149.html"
+ACCESSKEY="N"
+>Next</A
+></TD
+></TR
+></TABLE
+><HR
+ALIGN="LEFT"
+WIDTH="100%"></DIV
+><H1
+><A
+NAME="NINFOD"
+></A
+>ninfod</H1
+><DIV
+CLASS="REFNAMEDIV"
+><A
+NAME="AEN1085"
+></A
+><H2
+>Name</H2
+>ninfod&nbsp;--&nbsp;Respond to IPv6 Node Information Queries</DIV
+><DIV
+CLASS="REFSYNOPSISDIV"
+><A
+NAME="AEN1088"
+></A
+><H2
+>Synopsis</H2
+><P
+><B
+CLASS="COMMAND"
+>ninfod</B
+>  [<CODE
+CLASS="OPTION"
+>-dhv</CODE
+>] [-p <TT
+CLASS="REPLACEABLE"
+><I
+>pidfile</I
+></TT
+>] [-u <TT
+CLASS="REPLACEABLE"
+><I
+>user</I
+></TT
+>]</P
+></DIV
+><DIV
+CLASS="REFSECT1"
+><A
+NAME="AEN1097"
+></A
+><H2
+>DESCRIPTION</H2
+><P
+>Responds to <A
+HREF="http://tools.ietf.org/rfc/rfc4620.txt"
+TARGET="_top"
+>IPv6 Node Information Queries (RFC4620)</A
+> from clients.
+Queries can be sent by various implementations of <B
+CLASS="COMMAND"
+>ping6</B
+> command.</P
+></DIV
+><DIV
+CLASS="REFSECT1"
+><A
+NAME="AEN1102"
+></A
+><H2
+>OPTIONS</H2
+><P
+></P
+><DIV
+CLASS="VARIABLELIST"
+><DL
+><DT
+><CODE
+CLASS="OPTION"
+>-a</CODE
+></DT
+><DD
+><P
+>Debug mode.  Do not go background.
+  </P
+></DD
+><DT
+><CODE
+CLASS="OPTION"
+>-h</CODE
+></DT
+><DD
+><P
+>Show help.
+  </P
+></DD
+><DT
+><CODE
+CLASS="OPTION"
+>-v</CODE
+></DT
+><DD
+><P
+>Verbose mode.
+  </P
+></DD
+><DT
+><CODE
+CLASS="OPTION"
+>-u <TT
+CLASS="REPLACEABLE"
+><I
+>user</I
+></TT
+></CODE
+></DT
+><DD
+><P
+>Run as another user.
+<TT
+CLASS="REPLACEABLE"
+><I
+>user</I
+></TT
+> can either be username or user ID.
+  </P
+></DD
+><DT
+><CODE
+CLASS="OPTION"
+>-p <TT
+CLASS="REPLACEABLE"
+><I
+>pidfile</I
+></TT
+></CODE
+></DT
+><DD
+><P
+>File for process-id storage.
+<TT
+CLASS="REPLACEABLE"
+><I
+>user</I
+></TT
+> is required to be able to create the file.
+  </P
+></DD
+></DL
+></DIV
+></DIV
+><DIV
+CLASS="REFSECT1"
+><A
+NAME="AEN1134"
+></A
+><H2
+>SEE ALSO</H2
+><P
+><A
+HREF="r3.html"
+><SPAN
+CLASS="CITEREFENTRY"
+><SPAN
+CLASS="REFENTRYTITLE"
+>ping</SPAN
+>(8)</SPAN
+></A
+>.</P
+></DIV
+><DIV
+CLASS="REFSECT1"
+><A
+NAME="AEN1141"
+></A
+><H2
+>AUTHOR</H2
+><P
+><B
+CLASS="COMMAND"
+>ninfod</B
+> was written by USAGI/WIDE Project.</P
+></DIV
+><DIV
+CLASS="REFSECT1"
+><A
+NAME="AEN1145"
+></A
+><H2
+>COPYING</H2
+><P
+><P
+CLASS="LITERALLAYOUT"
+>Copyright&nbsp;(C)&nbsp;2012&nbsp;YOSHIFUJI&nbsp;Hideaki.<br>
+Copyright&nbsp;(C)&nbsp;2002&nbsp;USAGI/WIDE&nbsp;Project.<br>
+All&nbsp;rights&nbsp;reserved.<br>
+<br>
+Redistribution&nbsp;and&nbsp;use&nbsp;in&nbsp;source&nbsp;and&nbsp;binary&nbsp;forms,&nbsp;with&nbsp;or&nbsp;without<br>
+modification,&nbsp;are&nbsp;permitted&nbsp;provided&nbsp;that&nbsp;the&nbsp;following&nbsp;conditions<br>
+are&nbsp;met:<br>
+1.&nbsp;Redistributions&nbsp;of&nbsp;source&nbsp;code&nbsp;must&nbsp;retain&nbsp;the&nbsp;above&nbsp;copyright<br>
+&nbsp;&nbsp;&nbsp;notice,&nbsp;this&nbsp;list&nbsp;of&nbsp;conditions&nbsp;and&nbsp;the&nbsp;following&nbsp;disclaimer.<br>
+2.&nbsp;Redistributions&nbsp;in&nbsp;binary&nbsp;form&nbsp;must&nbsp;reproduce&nbsp;the&nbsp;above&nbsp;copyright<br>
+&nbsp;&nbsp;&nbsp;notice,&nbsp;this&nbsp;list&nbsp;of&nbsp;conditions&nbsp;and&nbsp;the&nbsp;following&nbsp;disclaimer&nbsp;in&nbsp;the<br>
+&nbsp;&nbsp;&nbsp;documentation&nbsp;and/or&nbsp;other&nbsp;materials&nbsp;provided&nbsp;with&nbsp;the&nbsp;distribution.<br>
+3.&nbsp;Neither&nbsp;the&nbsp;name&nbsp;of&nbsp;the&nbsp;project&nbsp;nor&nbsp;the&nbsp;names&nbsp;of&nbsp;its&nbsp;contributors<br>
+&nbsp;&nbsp;&nbsp;may&nbsp;be&nbsp;used&nbsp;to&nbsp;endorse&nbsp;or&nbsp;promote&nbsp;products&nbsp;derived&nbsp;from&nbsp;this&nbsp;software<br>
+&nbsp;&nbsp;&nbsp;without&nbsp;specific&nbsp;prior&nbsp;written&nbsp;permission.<br>
+<br>
+THIS&nbsp;SOFTWARE&nbsp;IS&nbsp;PROVIDED&nbsp;BY&nbsp;THE&nbsp;PROJECT&nbsp;AND&nbsp;CONTRIBUTORS&nbsp;``AS&nbsp;IS''&nbsp;AND<br>
+ANY&nbsp;EXPRESS&nbsp;OR&nbsp;IMPLIED&nbsp;WARRANTIES,&nbsp;INCLUDING,&nbsp;BUT&nbsp;NOT&nbsp;LIMITED&nbsp;TO,&nbsp;THE<br>
+IMPLIED&nbsp;WARRANTIES&nbsp;OF&nbsp;MERCHANTABILITY&nbsp;AND&nbsp;FITNESS&nbsp;FOR&nbsp;A&nbsp;PARTICULAR&nbsp;PURPOSE<br>
+ARE&nbsp;DISCLAIMED.&nbsp;&nbsp;IN&nbsp;NO&nbsp;EVENT&nbsp;SHALL&nbsp;THE&nbsp;PROJECT&nbsp;OR&nbsp;CONTRIBUTORS&nbsp;BE&nbsp;LIABLE<br>
+FOR&nbsp;ANY&nbsp;DIRECT,&nbsp;INDIRECT,&nbsp;INCIDENTAL,&nbsp;SPECIAL,&nbsp;EXEMPLARY,&nbsp;OR&nbsp;CONSEQUENTIAL<br>
+DAMAGES&nbsp;(INCLUDING,&nbsp;BUT&nbsp;NOT&nbsp;LIMITED&nbsp;TO,&nbsp;PROCUREMENT&nbsp;OF&nbsp;SUBSTITUTE&nbsp;GOODS<br>
+OR&nbsp;SERVICES;&nbsp;LOSS&nbsp;OF&nbsp;USE,&nbsp;DATA,&nbsp;OR&nbsp;PROFITS;&nbsp;OR&nbsp;BUSINESS&nbsp;INTERRUPTION)<br>
+HOWEVER&nbsp;CAUSED&nbsp;AND&nbsp;ON&nbsp;ANY&nbsp;THEORY&nbsp;OF&nbsp;LIABILITY,&nbsp;WHETHER&nbsp;IN&nbsp;CONTRACT,&nbsp;STRICT<br>
+LIABILITY,&nbsp;OR&nbsp;TORT&nbsp;(INCLUDING&nbsp;NEGLIGENCE&nbsp;OR&nbsp;OTHERWISE)&nbsp;ARISING&nbsp;IN&nbsp;ANY&nbsp;WAY<br>
+OUT&nbsp;OF&nbsp;THE&nbsp;USE&nbsp;OF&nbsp;THIS&nbsp;SOFTWARE,&nbsp;EVEN&nbsp;IF&nbsp;ADVISED&nbsp;OF&nbsp;THE&nbsp;POSSIBILITY&nbsp;OF<br>
+SUCH&nbsp;DAMAGE.</P
+></P
+></DIV
+><DIV
+CLASS="NAVFOOTER"
+><HR
+ALIGN="LEFT"
+WIDTH="100%"><TABLE
+SUMMARY="Footer navigation table"
+WIDTH="100%"
+BORDER="0"
+CELLPADDING="0"
+CELLSPACING="0"
+><TR
+><TD
+WIDTH="33%"
+ALIGN="left"
+VALIGN="top"
+><A
+HREF="r1007.html"
+ACCESSKEY="P"
+>Prev</A
+></TD
+><TD
+WIDTH="34%"
+ALIGN="center"
+VALIGN="top"
+><A
+HREF="index.html"
+ACCESSKEY="H"
+>Home</A
+></TD
+><TD
+WIDTH="33%"
+ALIGN="right"
+VALIGN="top"
+><A
+HREF="r1149.html"
+ACCESSKEY="N"
+>Next</A
+></TD
+></TR
+><TR
+><TD
+WIDTH="33%"
+ALIGN="left"
+VALIGN="top"
+>tftpd</TD
+><TD
+WIDTH="34%"
+ALIGN="center"
+VALIGN="top"
+>&nbsp;</TD
+><TD
+WIDTH="33%"
+ALIGN="right"
+VALIGN="top"
+>rdisc</TD
+></TR
+></TABLE
+></DIV
+></BODY
+></HTML
+>
\ No newline at end of file
diff -Naur iputils-s20151218.orig/doc/r1149.html iputils-s20151218/doc/r1149.html
--- iputils-s20151218.orig/doc/r1149.html	1970-01-01 00:00:00.000000000 +0000
+++ iputils-s20151218/doc/r1149.html	2016-07-16 01:02:47.407153900 +0000
@@ -0,0 +1,567 @@
+<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN""http://www.w3.org/TR/html4/loose.dtd">
+<HTML
+><HEAD
+><TITLE
+>rdisc</TITLE
+><META
+NAME="GENERATOR"
+CONTENT="Modular DocBook HTML Stylesheet Version 1.79"><LINK
+REL="HOME"
+TITLE="System Manager's Manual: iputils"
+HREF="index.html"><LINK
+REL="PREVIOUS"
+TITLE="ninfod"
+HREF="r1080.html"><LINK
+REL="NEXT"
+TITLE="pg3"
+HREF="r1293.html"></HEAD
+><BODY
+CLASS="REFENTRY"
+BGCOLOR="#FFFFFF"
+TEXT="#000000"
+LINK="#0000FF"
+VLINK="#840084"
+ALINK="#0000FF"
+><DIV
+CLASS="NAVHEADER"
+><TABLE
+SUMMARY="Header navigation table"
+WIDTH="100%"
+BORDER="0"
+CELLPADDING="0"
+CELLSPACING="0"
+><TR
+><TH
+COLSPAN="3"
+ALIGN="center"
+>System Manager's Manual: iputils</TH
+></TR
+><TR
+><TD
+WIDTH="10%"
+ALIGN="left"
+VALIGN="bottom"
+><A
+HREF="r1080.html"
+ACCESSKEY="P"
+>Prev</A
+></TD
+><TD
+WIDTH="80%"
+ALIGN="center"
+VALIGN="bottom"
+></TD
+><TD
+WIDTH="10%"
+ALIGN="right"
+VALIGN="bottom"
+><A
+HREF="r1293.html"
+ACCESSKEY="N"
+>Next</A
+></TD
+></TR
+></TABLE
+><HR
+ALIGN="LEFT"
+WIDTH="100%"></DIV
+><H1
+><A
+NAME="RDISC"
+></A
+>rdisc</H1
+><DIV
+CLASS="REFNAMEDIV"
+><A
+NAME="AEN1154"
+></A
+><H2
+>Name</H2
+>rdisc&nbsp;--&nbsp;network router discovery daemon</DIV
+><DIV
+CLASS="REFSYNOPSISDIV"
+><A
+NAME="AEN1157"
+></A
+><H2
+>Synopsis</H2
+><P
+><B
+CLASS="COMMAND"
+>rdisc</B
+>  [<CODE
+CLASS="OPTION"
+>-abdfrstvV</CODE
+>] [-p <TT
+CLASS="REPLACEABLE"
+><I
+>preference</I
+></TT
+>] [-T <TT
+CLASS="REPLACEABLE"
+><I
+>max_interval</I
+></TT
+>] [<TT
+CLASS="REPLACEABLE"
+><I
+>send_address</I
+></TT
+>] [<TT
+CLASS="REPLACEABLE"
+><I
+>receive_address</I
+></TT
+>]</P
+></DIV
+><DIV
+CLASS="REFSECT1"
+><A
+NAME="AEN1170"
+></A
+><H2
+>DESCRIPTION</H2
+><P
+><B
+CLASS="COMMAND"
+>rdisc</B
+> implements client side of the ICMP router discover protocol.
+<B
+CLASS="COMMAND"
+>rdisc</B
+> is invoked at boot time to populate the network
+routing tables with default routes. </P
+><P
+><B
+CLASS="COMMAND"
+>rdisc</B
+> listens on the ALL_HOSTS (224.0.0.1) multicast address
+(or <TT
+CLASS="REPLACEABLE"
+><I
+>receive_address</I
+></TT
+> provided it is given) 
+for ROUTER_ADVERTISE messages from routers. The received
+messages are handled by first ignoring those listed router addresses
+with which the host does not share a network. Among the remaining addresses
+the ones with the highest preference are selected as default routers
+and a default route is entered in the kernel routing table
+for each one of them.</P
+><P
+>Optionally, <B
+CLASS="COMMAND"
+>rdisc</B
+> can avoid waiting for routers to announce 
+themselves by sending out a few ROUTER_SOLICITATION messages
+to the ALL_ROUTERS (224.0.0.2) multicast address 
+(or <TT
+CLASS="REPLACEABLE"
+><I
+>send_address</I
+></TT
+> provided it is given) 
+when it is started.</P
+><P
+>A timer is associated with each router address and the address will
+no longer be considered for inclusion in the the routing tables if the 
+timer expires before a new 
+<SPAN
+CLASS="emphasis"
+><I
+CLASS="EMPHASIS"
+>advertise</I
+></SPAN
+> message is received from the router.
+The address will also be excluded from consideration if the host receives an 
+<SPAN
+CLASS="emphasis"
+><I
+CLASS="EMPHASIS"
+>advertise</I
+></SPAN
+>
+message with the preference being maximally negative.</P
+><P
+>Server side of router discovery protocol is supported by Cisco IOS
+and by any more or less complete UNIX routing daemon, f.e <B
+CLASS="COMMAND"
+>gated</B
+>.
+Or, <B
+CLASS="COMMAND"
+>rdisc</B
+> can act as responder, if compiled with -DRDISC_SERVER.</P
+></DIV
+><DIV
+CLASS="REFSECT1"
+><A
+NAME="AEN1187"
+></A
+><H2
+>OPTIONS</H2
+><P
+></P
+><DIV
+CLASS="VARIABLELIST"
+><DL
+><DT
+><CODE
+CLASS="OPTION"
+>-a</CODE
+></DT
+><DD
+><P
+>Accept all routers independently of the preference they have in their 
+<SPAN
+CLASS="emphasis"
+><I
+CLASS="EMPHASIS"
+>advertise</I
+></SPAN
+> messages.
+Normally <B
+CLASS="COMMAND"
+>rdisc</B
+> only accepts (and enters in the kernel routing
+tables) the router or routers with the highest preference.
+  </P
+></DD
+><DT
+><CODE
+CLASS="OPTION"
+>-b</CODE
+></DT
+><DD
+><P
+>Opposite to <CODE
+CLASS="OPTION"
+>-a</CODE
+>, i.e. install only router with the best
+preference value. It is default behaviour.
+  </P
+></DD
+><DT
+><CODE
+CLASS="OPTION"
+>-d</CODE
+></DT
+><DD
+><P
+>Send debugging messages to syslog.
+  </P
+></DD
+><DT
+><CODE
+CLASS="OPTION"
+>-f</CODE
+></DT
+><DD
+><P
+>Run <B
+CLASS="COMMAND"
+>rdisc</B
+> forever even if no routers are found.
+Normally <B
+CLASS="COMMAND"
+>rdisc</B
+> gives up if it has not received any 
+<SPAN
+CLASS="emphasis"
+><I
+CLASS="EMPHASIS"
+>advertise</I
+></SPAN
+> message after after soliciting three times,
+in which case it exits with a non-zero exit code.
+If <CODE
+CLASS="OPTION"
+>-f</CODE
+> is not specified in the first form then 
+<CODE
+CLASS="OPTION"
+>-s</CODE
+> must be specified.
+  </P
+></DD
+><DT
+><CODE
+CLASS="OPTION"
+>-r</CODE
+></DT
+><DD
+><P
+>Responder mode, available only if compiled with -DRDISC_SERVER.
+  </P
+></DD
+><DT
+><CODE
+CLASS="OPTION"
+>-s</CODE
+></DT
+><DD
+><P
+>Send three <SPAN
+CLASS="emphasis"
+><I
+CLASS="EMPHASIS"
+>solicitation</I
+></SPAN
+> messages initially to quickly discover
+the routers when the system is booted.
+When <CODE
+CLASS="OPTION"
+>-s</CODE
+> is specified <B
+CLASS="COMMAND"
+>rdisc</B
+>
+exits with a non-zero exit code if it can not find any routers.
+This can be overridden with the <CODE
+CLASS="OPTION"
+>-f</CODE
+> option.
+  </P
+></DD
+><DT
+><CODE
+CLASS="OPTION"
+>-p <TT
+CLASS="REPLACEABLE"
+><I
+>preference</I
+></TT
+></CODE
+></DT
+><DD
+><P
+>Set preference in advertisement.
+Available only with -r option.
+  </P
+></DD
+><DT
+><CODE
+CLASS="OPTION"
+>-T <TT
+CLASS="REPLACEABLE"
+><I
+>max_interval</I
+></TT
+></CODE
+></DT
+><DD
+><P
+>Set maximum advertisement interval in seconds.  Default is 600 secs.
+Available only with -r option.
+  </P
+></DD
+><DT
+><CODE
+CLASS="OPTION"
+>-t</CODE
+></DT
+><DD
+><P
+>Test mode. Do not go to background.
+  </P
+></DD
+><DT
+><CODE
+CLASS="OPTION"
+>-v</CODE
+></DT
+><DD
+><P
+>Be verbose i.e. send lots of debugging messages to syslog.
+  </P
+></DD
+><DT
+><CODE
+CLASS="OPTION"
+>-V</CODE
+></DT
+><DD
+><P
+>Print version and exit.
+  </P
+></DD
+></DL
+></DIV
+></DIV
+><DIV
+CLASS="REFSECT1"
+><A
+NAME="AEN1259"
+></A
+><H2
+>HISTORY</H2
+><P
+>This program was developed by Sun Microsystems (see copyright
+notice in source file). It was ported to Linux by
+<A
+HREF="mailto:kuznet@ms2.inr.ac.ru"
+TARGET="_top"
+>Alexey Kuznetsov
+&lt;kuznet@ms2.inr.ac.ru&gt;</A
+>.
+It is now maintained by
+<A
+HREF="mailto:yoshfuji@skbuff.net"
+TARGET="_top"
+>YOSHIFUJI Hideaki
+&lt;yoshfuji@skbuff.net&gt;</A
+>.</P
+></DIV
+><DIV
+CLASS="REFSECT1"
+><A
+NAME="AEN1264"
+></A
+><H2
+>SEE ALSO</H2
+><P
+><SPAN
+CLASS="CITEREFENTRY"
+><SPAN
+CLASS="REFENTRYTITLE"
+>icmp</SPAN
+>(7)</SPAN
+>,
+<SPAN
+CLASS="CITEREFENTRY"
+><SPAN
+CLASS="REFENTRYTITLE"
+>inet</SPAN
+>(7)</SPAN
+>,
+<A
+HREF="r3.html"
+><SPAN
+CLASS="CITEREFENTRY"
+><SPAN
+CLASS="REFENTRYTITLE"
+>ping</SPAN
+>(8)</SPAN
+></A
+>.</P
+></DIV
+><DIV
+CLASS="REFSECT1"
+><A
+NAME="AEN1277"
+></A
+><H2
+>REFERENCES</H2
+><P
+>Deering, S.E.,ed "ICMP Router Discovery Messages",
+<A
+HREF="http://tools.ietf.org/rfc/rfc1256.txt"
+TARGET="_top"
+>RFC1256</A
+>, Network Information Center, SRI International,
+Menlo Park, Calif., September 1991.</P
+></DIV
+><DIV
+CLASS="REFSECT1"
+><A
+NAME="AEN1281"
+></A
+><H2
+>SECURITY</H2
+><P
+><B
+CLASS="COMMAND"
+>rdisc</B
+> requires <CODE
+CLASS="CONSTANT"
+>CAP_NET_RAW</CODE
+> to listen
+and send ICMP messages and capability <CODE
+CLASS="CONSTANT"
+>CAP_NET_ADMIN</CODE
+>
+to update routing tables. </P
+></DIV
+><DIV
+CLASS="REFSECT1"
+><A
+NAME="AEN1287"
+></A
+><H2
+>AVAILABILITY</H2
+><P
+><B
+CLASS="COMMAND"
+>rdisc</B
+> is part of <TT
+CLASS="FILENAME"
+>iputils</TT
+> package
+and the latest versions are  available in source form at
+<A
+HREF="http://www.skbuff.net/iputils/iputils-current.tar.bz2"
+TARGET="_top"
+>http://www.skbuff.net/iputils/iputils-current.tar.bz2</A
+>.</P
+></DIV
+><DIV
+CLASS="NAVFOOTER"
+><HR
+ALIGN="LEFT"
+WIDTH="100%"><TABLE
+SUMMARY="Footer navigation table"
+WIDTH="100%"
+BORDER="0"
+CELLPADDING="0"
+CELLSPACING="0"
+><TR
+><TD
+WIDTH="33%"
+ALIGN="left"
+VALIGN="top"
+><A
+HREF="r1080.html"
+ACCESSKEY="P"
+>Prev</A
+></TD
+><TD
+WIDTH="34%"
+ALIGN="center"
+VALIGN="top"
+><A
+HREF="index.html"
+ACCESSKEY="H"
+>Home</A
+></TD
+><TD
+WIDTH="33%"
+ALIGN="right"
+VALIGN="top"
+><A
+HREF="r1293.html"
+ACCESSKEY="N"
+>Next</A
+></TD
+></TR
+><TR
+><TD
+WIDTH="33%"
+ALIGN="left"
+VALIGN="top"
+>ninfod</TD
+><TD
+WIDTH="34%"
+ALIGN="center"
+VALIGN="top"
+>&nbsp;</TD
+><TD
+WIDTH="33%"
+ALIGN="right"
+VALIGN="top"
+>pg3</TD
+></TR
+></TABLE
+></DIV
+></BODY
+></HTML
+>
\ No newline at end of file
diff -Naur iputils-s20151218.orig/doc/r1293.html iputils-s20151218/doc/r1293.html
--- iputils-s20151218.orig/doc/r1293.html	1970-01-01 00:00:00.000000000 +0000
+++ iputils-s20151218/doc/r1293.html	2016-07-16 01:02:47.447153591 +0000
@@ -0,0 +1,428 @@
+<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN""http://www.w3.org/TR/html4/loose.dtd">
+<HTML
+><HEAD
+><TITLE
+>pg3</TITLE
+><META
+NAME="GENERATOR"
+CONTENT="Modular DocBook HTML Stylesheet Version 1.79"><LINK
+REL="HOME"
+TITLE="System Manager's Manual: iputils"
+HREF="index.html"><LINK
+REL="PREVIOUS"
+TITLE="rdisc"
+HREF="r1149.html"></HEAD
+><BODY
+CLASS="REFENTRY"
+BGCOLOR="#FFFFFF"
+TEXT="#000000"
+LINK="#0000FF"
+VLINK="#840084"
+ALINK="#0000FF"
+><DIV
+CLASS="NAVHEADER"
+><TABLE
+SUMMARY="Header navigation table"
+WIDTH="100%"
+BORDER="0"
+CELLPADDING="0"
+CELLSPACING="0"
+><TR
+><TH
+COLSPAN="3"
+ALIGN="center"
+>System Manager's Manual: iputils</TH
+></TR
+><TR
+><TD
+WIDTH="10%"
+ALIGN="left"
+VALIGN="bottom"
+><A
+HREF="r1149.html"
+ACCESSKEY="P"
+>Prev</A
+></TD
+><TD
+WIDTH="80%"
+ALIGN="center"
+VALIGN="bottom"
+></TD
+><TD
+WIDTH="10%"
+ALIGN="right"
+VALIGN="bottom"
+>&nbsp;</TD
+></TR
+></TABLE
+><HR
+ALIGN="LEFT"
+WIDTH="100%"></DIV
+><H1
+><A
+NAME="PG3"
+></A
+>pg3</H1
+><DIV
+CLASS="REFNAMEDIV"
+><A
+NAME="AEN1298"
+></A
+><H2
+>Name</H2
+>pg3, ipg, pgset&nbsp;--&nbsp;send stream of UDP packets</DIV
+><DIV
+CLASS="REFSYNOPSISDIV"
+><A
+NAME="AEN1301"
+></A
+><H2
+>Synopsis</H2
+><P
+><B
+CLASS="COMMAND"
+>source ipg</B
+> </P
+><P
+><B
+CLASS="COMMAND"
+>pg</B
+> </P
+><P
+><B
+CLASS="COMMAND"
+>pgset</B
+>  {<TT
+CLASS="REPLACEABLE"
+><I
+>COMMAND</I
+></TT
+>}</P
+></DIV
+><DIV
+CLASS="REFSECT1"
+><A
+NAME="AEN1310"
+></A
+><H2
+>DESCRIPTION</H2
+><P
+><B
+CLASS="COMMAND"
+>ipg</B
+> is not a program, it is script which should be sourced
+to <B
+CLASS="COMMAND"
+>bash</B
+>. When sourced it loads module <TT
+CLASS="FILENAME"
+>pg3</TT
+> and
+exports a few of functions accessible from parent shell. These macros
+are <B
+CLASS="COMMAND"
+>pg</B
+> to start packet injection and to get the results of run;
+and <B
+CLASS="COMMAND"
+>pgset</B
+> to setup packet generator.</P
+><P
+><B
+CLASS="COMMAND"
+>pgset</B
+> can send the following commands to module <TT
+CLASS="FILENAME"
+>pg3</TT
+>:</P
+></DIV
+><DIV
+CLASS="REFSECT1"
+><A
+NAME="AEN1321"
+></A
+><H2
+>COMMAND</H2
+><P
+></P
+><DIV
+CLASS="VARIABLELIST"
+><DL
+><DT
+><CODE
+CLASS="OPTION"
+>odev <TT
+CLASS="REPLACEABLE"
+><I
+>DEVICE</I
+></TT
+></CODE
+></DT
+><DD
+><P
+>Name of Ethernet device to test. See
+<A
+HREF="r1293.html#PG3.WARNING"
+>warning</A
+> below.
+  </P
+></DD
+><DT
+><CODE
+CLASS="OPTION"
+>pkt_size <TT
+CLASS="REPLACEABLE"
+><I
+>BYTES</I
+></TT
+></CODE
+></DT
+><DD
+><P
+>Size of packet to generate. The size includes all the headers: UDP, IP,
+MAC, but does not account for overhead internal to medium, i.e. FCS
+and various paddings.
+  </P
+></DD
+><DT
+><CODE
+CLASS="OPTION"
+>frags <TT
+CLASS="REPLACEABLE"
+><I
+>NUMBER</I
+></TT
+></CODE
+></DT
+><DD
+><P
+>Each packet will contain <TT
+CLASS="REPLACEABLE"
+><I
+>NUMBER</I
+></TT
+> of fragments.
+Maximal amount for linux-2.4 is 6. Far not all the devices support
+fragmented buffers.
+  </P
+></DD
+><DT
+><CODE
+CLASS="OPTION"
+>count <TT
+CLASS="REPLACEABLE"
+><I
+>NUMBER</I
+></TT
+></CODE
+></DT
+><DD
+><P
+>Send stream of <TT
+CLASS="REPLACEABLE"
+><I
+>NUMBER</I
+></TT
+> of packets and stop after this.
+  </P
+></DD
+><DT
+><CODE
+CLASS="OPTION"
+>ipg <TT
+CLASS="REPLACEABLE"
+><I
+>TIME</I
+></TT
+></CODE
+></DT
+><DD
+><P
+>Introduce artificial delay between packets of <TT
+CLASS="REPLACEABLE"
+><I
+>TIME</I
+></TT
+>
+microseconds.
+  </P
+></DD
+><DT
+><CODE
+CLASS="OPTION"
+>dst <TT
+CLASS="REPLACEABLE"
+><I
+>IP_ADDRESS</I
+></TT
+></CODE
+></DT
+><DD
+><P
+>Select IP destination where the stream is sent to.
+Beware, never set this address at random. <B
+CLASS="COMMAND"
+>pg3</B
+> is not a toy,
+it creates really tough stream. Default value is 0.0.0.0.
+  </P
+></DD
+><DT
+><CODE
+CLASS="OPTION"
+>dst <TT
+CLASS="REPLACEABLE"
+><I
+>MAC_ADDRESS</I
+></TT
+></CODE
+></DT
+><DD
+><P
+>Select MAC destination where the stream is sent to.
+Default value is 00:00:00:00:00:00 in hope that this will not be received
+by any node on LAN.
+  </P
+></DD
+><DT
+><CODE
+CLASS="OPTION"
+>stop</CODE
+></DT
+><DD
+><P
+>Abort packet injection.
+  </P
+></DD
+></DL
+></DIV
+></DIV
+><DIV
+CLASS="REFSECT1"
+><A
+NAME="PG3.WARNING"
+></A
+><H2
+>WARNING</H2
+><P
+>When output device is set to some random device different
+of hardware Ethernet device, <B
+CLASS="COMMAND"
+>pg3</B
+> will crash kernel.</P
+><P
+>Do not use it on VLAN, ethertap, VTUN and other devices,
+which emulate Ethernet not being real Ethernet in fact.</P
+></DIV
+><DIV
+CLASS="REFSECT1"
+><A
+NAME="AEN1381"
+></A
+><H2
+>AUTHOR</H2
+><P
+><B
+CLASS="COMMAND"
+>pg3</B
+> was written by <A
+HREF="mailto:robert.olsson@its.uu.se"
+TARGET="_top"
+>Robert Olsson &lt;robert.olsson@its.uu.se&gt;</A
+>.</P
+></DIV
+><DIV
+CLASS="REFSECT1"
+><A
+NAME="AEN1386"
+></A
+><H2
+>SECURITY</H2
+><P
+>This can be used only by superuser.</P
+><P
+>This tool creates floods of packets which is unlikely to be handled
+even by high-end machines. For example, it saturates gigabit link with
+60 byte packets when used with Intel's e1000. In face of such stream
+switches, routers and end hosts may deadlock, crash, explode.
+Use only in test lab environment.</P
+></DIV
+><DIV
+CLASS="REFSECT1"
+><A
+NAME="AEN1390"
+></A
+><H2
+>AVAILABILITY</H2
+><P
+><B
+CLASS="COMMAND"
+>pg3</B
+> is part of <TT
+CLASS="FILENAME"
+>iputils</TT
+> package
+and the latest versions are  available in source form at
+<A
+HREF="http://www.skbuff.net/iputils/iputils-current.tar.bz2"
+TARGET="_top"
+>http://www.skbuff.net/iputils/iputils-current.tar.bz2</A
+>.</P
+></DIV
+><DIV
+CLASS="NAVFOOTER"
+><HR
+ALIGN="LEFT"
+WIDTH="100%"><TABLE
+SUMMARY="Footer navigation table"
+WIDTH="100%"
+BORDER="0"
+CELLPADDING="0"
+CELLSPACING="0"
+><TR
+><TD
+WIDTH="33%"
+ALIGN="left"
+VALIGN="top"
+><A
+HREF="r1149.html"
+ACCESSKEY="P"
+>Prev</A
+></TD
+><TD
+WIDTH="34%"
+ALIGN="center"
+VALIGN="top"
+><A
+HREF="index.html"
+ACCESSKEY="H"
+>Home</A
+></TD
+><TD
+WIDTH="33%"
+ALIGN="right"
+VALIGN="top"
+>&nbsp;</TD
+></TR
+><TR
+><TD
+WIDTH="33%"
+ALIGN="left"
+VALIGN="top"
+>rdisc</TD
+><TD
+WIDTH="34%"
+ALIGN="center"
+VALIGN="top"
+>&nbsp;</TD
+><TD
+WIDTH="33%"
+ALIGN="right"
+VALIGN="top"
+>&nbsp;</TD
+></TR
+></TABLE
+></DIV
+></BODY
+></HTML
+>
\ No newline at end of file
diff -Naur iputils-s20151218.orig/doc/r3.html iputils-s20151218/doc/r3.html
--- iputils-s20151218.orig/doc/r3.html	1970-01-01 00:00:00.000000000 +0000
+++ iputils-s20151218/doc/r3.html	2016-07-16 01:02:46.987157139 +0000
@@ -0,0 +1,1633 @@
+<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN""http://www.w3.org/TR/html4/loose.dtd">
+<HTML
+><HEAD
+><TITLE
+>ping</TITLE
+><META
+NAME="GENERATOR"
+CONTENT="Modular DocBook HTML Stylesheet Version 1.79"><LINK
+REL="HOME"
+TITLE="System Manager's Manual: iputils"
+HREF="index.html"><LINK
+REL="PREVIOUS"
+TITLE="System Manager's Manual: iputils"
+HREF="index.html"><LINK
+REL="NEXT"
+TITLE="arping"
+HREF="r483.html"></HEAD
+><BODY
+CLASS="REFENTRY"
+BGCOLOR="#FFFFFF"
+TEXT="#000000"
+LINK="#0000FF"
+VLINK="#840084"
+ALINK="#0000FF"
+><DIV
+CLASS="NAVHEADER"
+><TABLE
+SUMMARY="Header navigation table"
+WIDTH="100%"
+BORDER="0"
+CELLPADDING="0"
+CELLSPACING="0"
+><TR
+><TH
+COLSPAN="3"
+ALIGN="center"
+>System Manager's Manual: iputils</TH
+></TR
+><TR
+><TD
+WIDTH="10%"
+ALIGN="left"
+VALIGN="bottom"
+><A
+HREF="index.html"
+ACCESSKEY="P"
+>Prev</A
+></TD
+><TD
+WIDTH="80%"
+ALIGN="center"
+VALIGN="bottom"
+></TD
+><TD
+WIDTH="10%"
+ALIGN="right"
+VALIGN="bottom"
+><A
+HREF="r483.html"
+ACCESSKEY="N"
+>Next</A
+></TD
+></TR
+></TABLE
+><HR
+ALIGN="LEFT"
+WIDTH="100%"></DIV
+><H1
+><A
+NAME="PING"
+></A
+>ping</H1
+><DIV
+CLASS="REFNAMEDIV"
+><A
+NAME="AEN8"
+></A
+><H2
+>Name</H2
+>ping&nbsp;--&nbsp;send ICMP ECHO_REQUEST to network hosts</DIV
+><DIV
+CLASS="REFSYNOPSISDIV"
+><A
+NAME="AEN11"
+></A
+><H2
+>Synopsis</H2
+><P
+><B
+CLASS="COMMAND"
+>ping</B
+>  [<CODE
+CLASS="OPTION"
+>-aAbBdDfhLnOqrRUvV46</CODE
+>] [-c <TT
+CLASS="REPLACEABLE"
+><I
+>count</I
+></TT
+>] [-F <TT
+CLASS="REPLACEABLE"
+><I
+>flowlabel</I
+></TT
+>] [-i <TT
+CLASS="REPLACEABLE"
+><I
+>interval</I
+></TT
+>] [-I <TT
+CLASS="REPLACEABLE"
+><I
+>interface</I
+></TT
+>] [-l <TT
+CLASS="REPLACEABLE"
+><I
+>preload</I
+></TT
+>] [-m <TT
+CLASS="REPLACEABLE"
+><I
+>mark</I
+></TT
+>] [-M <TT
+CLASS="REPLACEABLE"
+><I
+>pmtudisc_option</I
+></TT
+>] [-N <TT
+CLASS="REPLACEABLE"
+><I
+>nodeinfo_option</I
+></TT
+>] [-w <TT
+CLASS="REPLACEABLE"
+><I
+>deadline</I
+></TT
+>] [-W <TT
+CLASS="REPLACEABLE"
+><I
+>timeout</I
+></TT
+>] [-p <TT
+CLASS="REPLACEABLE"
+><I
+>pattern</I
+></TT
+>] [-Q <TT
+CLASS="REPLACEABLE"
+><I
+>tos</I
+></TT
+>] [-s <TT
+CLASS="REPLACEABLE"
+><I
+>packetsize</I
+></TT
+>] [-S <TT
+CLASS="REPLACEABLE"
+><I
+>sndbuf</I
+></TT
+>] [-t <TT
+CLASS="REPLACEABLE"
+><I
+>ttl</I
+></TT
+>] [-T <TT
+CLASS="REPLACEABLE"
+><I
+>timestamp option</I
+></TT
+>] [<TT
+CLASS="REPLACEABLE"
+><I
+>hop</I
+></TT
+>...] {<TT
+CLASS="REPLACEABLE"
+><I
+>destination</I
+></TT
+>}</P
+></DIV
+><DIV
+CLASS="REFSECT1"
+><A
+NAME="AEN52"
+></A
+><H2
+>DESCRIPTION</H2
+><P
+><B
+CLASS="COMMAND"
+>ping</B
+> uses the ICMP protocol's mandatory ECHO_REQUEST
+datagram to elicit an ICMP ECHO_RESPONSE from a host or gateway.
+ECHO_REQUEST datagrams (``pings'') have an IP and ICMP
+header, followed by a <CODE
+CLASS="STRUCTNAME"
+>struct timeval</CODE
+> and then an arbitrary
+number of ``pad'' bytes used to fill out the packet.</P
+><P
+><B
+CLASS="COMMAND"
+>ping</B
+> works with both IPv4 and IPv6. Using only one of them
+explicitly can be enforced by specifying <CODE
+CLASS="OPTION"
+>-4</CODE
+> or <CODE
+CLASS="OPTION"
+>-6</CODE
+>.</P
+><P
+><B
+CLASS="COMMAND"
+>ping</B
+> can also send IPv6 Node Information Queries (RFC4620).
+Intermediate <TT
+CLASS="REPLACEABLE"
+><I
+>hop</I
+></TT
+>s may not be allowed, because IPv6 source routing was deprecated (RFC5095).</P
+></DIV
+><DIV
+CLASS="REFSECT1"
+><A
+NAME="AEN64"
+></A
+><H2
+>OPTIONS</H2
+><P
+></P
+><DIV
+CLASS="VARIABLELIST"
+><DL
+><DT
+><CODE
+CLASS="OPTION"
+>-4</CODE
+></DT
+><DD
+><P
+>Use IPv4 only.
+  </P
+></DD
+><DT
+><CODE
+CLASS="OPTION"
+>-6</CODE
+></DT
+><DD
+><P
+>Use IPv6 only.
+  </P
+></DD
+><DT
+><CODE
+CLASS="OPTION"
+>-a</CODE
+></DT
+><DD
+><P
+>Audible ping.
+  </P
+></DD
+><DT
+><CODE
+CLASS="OPTION"
+>-A</CODE
+></DT
+><DD
+><P
+>Adaptive ping. Interpacket interval adapts to round-trip time, so that
+effectively not more than one (or more, if preload is set) unanswered probe
+is present in the network. Minimal interval is 200msec for not super-user.
+On networks with low rtt this mode is essentially equivalent to flood mode.  
+  </P
+></DD
+><DT
+><CODE
+CLASS="OPTION"
+>-b</CODE
+></DT
+><DD
+><P
+>Allow pinging a broadcast address.
+  </P
+></DD
+><DT
+><CODE
+CLASS="OPTION"
+>-B</CODE
+></DT
+><DD
+><P
+>Do not allow <B
+CLASS="COMMAND"
+>ping</B
+> to change source address of probes.
+The address is bound to one selected when <B
+CLASS="COMMAND"
+>ping</B
+> starts.
+  </P
+></DD
+><DT
+><CODE
+CLASS="OPTION"
+><A
+NAME="PING.COUNT"
+></A
+>-c <TT
+CLASS="REPLACEABLE"
+><I
+>count</I
+></TT
+></CODE
+></DT
+><DD
+><P
+>Stop after sending <TT
+CLASS="REPLACEABLE"
+><I
+>count</I
+></TT
+> ECHO_REQUEST
+packets. With 
+<A
+HREF="r3.html#PING.DEADLINE"
+><TT
+CLASS="REPLACEABLE"
+><I
+>deadline</I
+></TT
+></A
+>
+option, <B
+CLASS="COMMAND"
+>ping</B
+> waits for
+<TT
+CLASS="REPLACEABLE"
+><I
+>count</I
+></TT
+> ECHO_REPLY packets, until the timeout expires.
+  </P
+></DD
+><DT
+><CODE
+CLASS="OPTION"
+>-d</CODE
+></DT
+><DD
+><P
+>Set the <CODE
+CLASS="CONSTANT"
+>SO_DEBUG</CODE
+> option on the socket being used.
+Essentially, this socket option is not used by Linux kernel. 
+  </P
+></DD
+><DT
+><CODE
+CLASS="OPTION"
+>-D</CODE
+></DT
+><DD
+><P
+>Print timestamp (unix time + microseconds as in gettimeofday) before
+each line.
+  </P
+></DD
+><DT
+><CODE
+CLASS="OPTION"
+>-f</CODE
+></DT
+><DD
+><P
+>Flood ping. For every ECHO_REQUEST sent a period ``.'' is printed,
+while for ever ECHO_REPLY received a backspace is printed.
+This provides a rapid display of how many packets are being dropped.
+If interval is not given, it sets interval to zero and
+outputs packets as fast as they come back or one hundred times per second,
+whichever is more.
+Only the super-user may use this option with zero interval.
+  </P
+></DD
+><DT
+><CODE
+CLASS="OPTION"
+>-F <TT
+CLASS="REPLACEABLE"
+><I
+>flow label</I
+></TT
+></CODE
+></DT
+><DD
+><P
+>IPv6 only.
+Allocate and set 20 bit flow label (in hex) on echo request packets.
+If value is zero, kernel allocates random flow label.
+  </P
+></DD
+><DT
+><CODE
+CLASS="OPTION"
+>-h</CODE
+></DT
+><DD
+><P
+>Show help.
+  </P
+></DD
+><DT
+><CODE
+CLASS="OPTION"
+>-i <TT
+CLASS="REPLACEABLE"
+><I
+>interval</I
+></TT
+></CODE
+></DT
+><DD
+><P
+>Wait <TT
+CLASS="REPLACEABLE"
+><I
+>interval</I
+></TT
+> seconds between sending each packet.
+The default is to wait for one second between each packet normally,
+or not to wait in flood mode. Only super-user may set interval
+to values less 0.2 seconds.
+  </P
+></DD
+><DT
+><CODE
+CLASS="OPTION"
+>-I <TT
+CLASS="REPLACEABLE"
+><I
+>interface</I
+></TT
+></CODE
+></DT
+><DD
+><P
+><TT
+CLASS="REPLACEABLE"
+><I
+>interface</I
+></TT
+> is either an address, or an interface name.
+If <TT
+CLASS="REPLACEABLE"
+><I
+>interface</I
+></TT
+> is an address, it sets source address
+to specified interface address.
+If <TT
+CLASS="REPLACEABLE"
+><I
+>interface</I
+></TT
+> in an interface name, it sets
+source interface to specified interface.
+For IPv6, when doing ping to a link-local scope
+address, link specification (by the '%'-notation in
+<TT
+CLASS="REPLACEABLE"
+><I
+>destination</I
+></TT
+>, or by this option) is required.
+  </P
+></DD
+><DT
+><CODE
+CLASS="OPTION"
+>-l <TT
+CLASS="REPLACEABLE"
+><I
+>preload</I
+></TT
+></CODE
+></DT
+><DD
+><P
+>If <TT
+CLASS="REPLACEABLE"
+><I
+>preload</I
+></TT
+> is specified,
+<B
+CLASS="COMMAND"
+>ping</B
+> sends that many packets not waiting for reply.
+Only the super-user may select preload more than 3.
+  </P
+></DD
+><DT
+><CODE
+CLASS="OPTION"
+>-L</CODE
+></DT
+><DD
+><P
+>Suppress loopback of multicast packets.  This flag only applies if the ping
+destination is a multicast address.
+  </P
+></DD
+><DT
+><CODE
+CLASS="OPTION"
+>-m <TT
+CLASS="REPLACEABLE"
+><I
+>mark</I
+></TT
+></CODE
+></DT
+><DD
+><P
+>use <TT
+CLASS="REPLACEABLE"
+><I
+>mark</I
+></TT
+> to tag the packets going out. This is useful
+for variety of reasons within the kernel such as using policy
+routing to select specific outbound processing.
+  </P
+></DD
+><DT
+><CODE
+CLASS="OPTION"
+>-M <TT
+CLASS="REPLACEABLE"
+><I
+>pmtudisc_opt</I
+></TT
+></CODE
+></DT
+><DD
+><P
+>Select Path MTU Discovery strategy.
+<TT
+CLASS="REPLACEABLE"
+><I
+>pmtudisc_option</I
+></TT
+> may be either <TT
+CLASS="REPLACEABLE"
+><I
+>do</I
+></TT
+>
+(prohibit fragmentation, even local one), 
+<TT
+CLASS="REPLACEABLE"
+><I
+>want</I
+></TT
+> (do PMTU discovery, fragment locally when packet size
+is large), or <TT
+CLASS="REPLACEABLE"
+><I
+>dont</I
+></TT
+> (do not set DF flag).
+  </P
+></DD
+><DT
+><CODE
+CLASS="OPTION"
+>-N <TT
+CLASS="REPLACEABLE"
+><I
+>nodeinfo_option</I
+></TT
+></CODE
+></DT
+><DD
+><P
+>IPv6 only.
+Send ICMPv6 Node Information Queries (RFC4620), instead of Echo Request.
+<CODE
+CLASS="CONSTANT"
+>CAP_NET_RAW</CODE
+> capability is required.
+   <P
+></P
+><DIV
+CLASS="VARIABLELIST"
+><DL
+><DT
+><CODE
+CLASS="OPTION"
+>help</CODE
+></DT
+><DD
+><P
+>Show help for NI support.</P
+></DD
+></DL
+></DIV
+>
+   <P
+></P
+><DIV
+CLASS="VARIABLELIST"
+><DL
+><DT
+><CODE
+CLASS="OPTION"
+>name</CODE
+></DT
+><DD
+><P
+>Queries for Node Names.</P
+></DD
+></DL
+></DIV
+>
+   <P
+></P
+><DIV
+CLASS="VARIABLELIST"
+><DL
+><DT
+><CODE
+CLASS="OPTION"
+>ipv6</CODE
+></DT
+><DD
+><P
+>Queries for IPv6 Addresses. There are several IPv6 specific flags.
+      <P
+></P
+><DIV
+CLASS="VARIABLELIST"
+><DL
+><DT
+><CODE
+CLASS="OPTION"
+>ipv6-global</CODE
+></DT
+><DD
+><P
+>Request IPv6 global-scope addresses.</P
+></DD
+></DL
+></DIV
+>
+      <P
+></P
+><DIV
+CLASS="VARIABLELIST"
+><DL
+><DT
+><CODE
+CLASS="OPTION"
+>ipv6-sitelocal</CODE
+></DT
+><DD
+><P
+>Request IPv6 site-local addresses.</P
+></DD
+></DL
+></DIV
+>
+      <P
+></P
+><DIV
+CLASS="VARIABLELIST"
+><DL
+><DT
+><CODE
+CLASS="OPTION"
+>ipv6-linklocal</CODE
+></DT
+><DD
+><P
+>Request IPv6 link-local addresses.</P
+></DD
+></DL
+></DIV
+>
+      <P
+></P
+><DIV
+CLASS="VARIABLELIST"
+><DL
+><DT
+><CODE
+CLASS="OPTION"
+>ipv6-all</CODE
+></DT
+><DD
+><P
+>Request IPv6 addresses on other interfaces.</P
+></DD
+></DL
+></DIV
+>
+     </P
+></DD
+></DL
+></DIV
+>
+   <P
+></P
+><DIV
+CLASS="VARIABLELIST"
+><DL
+><DT
+><CODE
+CLASS="OPTION"
+>ipv4</CODE
+></DT
+><DD
+><P
+>Queries for IPv4 Addresses.  There is one IPv4 specific flag.
+      <P
+></P
+><DIV
+CLASS="VARIABLELIST"
+><DL
+><DT
+><CODE
+CLASS="OPTION"
+>ipv4-all</CODE
+></DT
+><DD
+><P
+>Request IPv4 addresses on other interfaces.</P
+></DD
+></DL
+></DIV
+>
+     </P
+></DD
+></DL
+></DIV
+>
+   <P
+></P
+><DIV
+CLASS="VARIABLELIST"
+><DL
+><DT
+><CODE
+CLASS="OPTION"
+>subject-ipv6=<TT
+CLASS="REPLACEABLE"
+><I
+>ipv6addr</I
+></TT
+></CODE
+></DT
+><DD
+><P
+>IPv6 subject address.</P
+></DD
+></DL
+></DIV
+>
+   <P
+></P
+><DIV
+CLASS="VARIABLELIST"
+><DL
+><DT
+><CODE
+CLASS="OPTION"
+>subject-ipv4=<TT
+CLASS="REPLACEABLE"
+><I
+>ipv4addr</I
+></TT
+></CODE
+></DT
+><DD
+><P
+>IPv4 subject address.</P
+></DD
+></DL
+></DIV
+>
+   <P
+></P
+><DIV
+CLASS="VARIABLELIST"
+><DL
+><DT
+><CODE
+CLASS="OPTION"
+>subject-name=<TT
+CLASS="REPLACEABLE"
+><I
+>nodename</I
+></TT
+></CODE
+></DT
+><DD
+><P
+>Subject name.  If it contains more than one dot,
+	fully-qualified domain name is assumed.</P
+></DD
+></DL
+></DIV
+>
+   <P
+></P
+><DIV
+CLASS="VARIABLELIST"
+><DL
+><DT
+><CODE
+CLASS="OPTION"
+>subject-fqdn=<TT
+CLASS="REPLACEABLE"
+><I
+>nodename</I
+></TT
+></CODE
+></DT
+><DD
+><P
+>Subject name.  Fully-qualified domain name is
+	always assumed.</P
+></DD
+></DL
+></DIV
+>
+  </P
+></DD
+><DT
+><CODE
+CLASS="OPTION"
+>-n</CODE
+></DT
+><DD
+><P
+>Numeric output only.
+No attempt will be made to lookup symbolic names for host addresses.
+  </P
+></DD
+><DT
+><CODE
+CLASS="OPTION"
+>-O</CODE
+></DT
+><DD
+><P
+>Report outstanding ICMP ECHO reply before sending next packet.
+This is useful together with the timestamp <CODE
+CLASS="OPTION"
+>-D</CODE
+> to
+log output to a diagnostic file and search for missing answers.
+  </P
+></DD
+><DT
+><CODE
+CLASS="OPTION"
+>-p <TT
+CLASS="REPLACEABLE"
+><I
+>pattern</I
+></TT
+></CODE
+></DT
+><DD
+><P
+>You may specify up to 16 ``pad'' bytes to fill out the packet you send.
+This is useful for diagnosing data-dependent problems in a network.
+For example, <CODE
+CLASS="OPTION"
+>-p ff</CODE
+> will cause the sent packet
+to be filled with all ones.
+  </P
+></DD
+><DT
+><CODE
+CLASS="OPTION"
+>-q</CODE
+></DT
+><DD
+><P
+>Quiet output.
+Nothing is displayed except the summary lines at startup time and
+when finished.
+  </P
+></DD
+><DT
+><CODE
+CLASS="OPTION"
+>-Q <TT
+CLASS="REPLACEABLE"
+><I
+>tos</I
+></TT
+></CODE
+></DT
+><DD
+><P
+>	Set Quality of Service -related bits in ICMP datagrams.
+	<TT
+CLASS="REPLACEABLE"
+><I
+>tos</I
+></TT
+> can be decimal (<B
+CLASS="COMMAND"
+>ping</B
+> only) or hex number.
+	</P
+><P
+>	In RFC2474, these fields are interpreted as 8-bit Differentiated
+	Services (DS), consisting of: bits 0-1 (2 lowest bits) of separate
+	data, and bits 2-7 (highest 6 bits) of Differentiated Services
+	Codepoint (DSCP).  In RFC2481 and RFC3168, bits 0-1 are used for ECN.
+	</P
+><P
+>	Historically (RFC1349, obsoleted by RFC2474), these were interpreted
+	as: bit 0 (lowest bit) for reserved (currently being redefined as
+	congestion control), 1-4 for Type of Service and bits 5-7
+	(highest bits) for Precedence.
+   </P
+></DD
+><DT
+><CODE
+CLASS="OPTION"
+>-r</CODE
+></DT
+><DD
+><P
+>Bypass the normal routing tables and send directly to a host on an attached
+interface.
+If the host is not on a directly-attached network, an error is returned.
+This option can be used to ping a local host through an interface
+that has no route through it provided the option <CODE
+CLASS="OPTION"
+>-I</CODE
+> is also
+used.
+  </P
+></DD
+><DT
+><CODE
+CLASS="OPTION"
+>-R</CODE
+></DT
+><DD
+><P
+><B
+CLASS="COMMAND"
+>ping</B
+> only.
+Record route.
+Includes the RECORD_ROUTE option in the ECHO_REQUEST
+packet and displays the route buffer on returned packets.
+Note that the IP header is only large enough for nine such routes.
+Many hosts ignore or discard this option.
+  </P
+></DD
+><DT
+><CODE
+CLASS="OPTION"
+>-s <TT
+CLASS="REPLACEABLE"
+><I
+>packetsize</I
+></TT
+></CODE
+></DT
+><DD
+><P
+>Specifies the number of data bytes to be sent.  
+The default is 56, which translates into 64 ICMP
+data bytes when combined with the 8 bytes of ICMP header data.
+  </P
+></DD
+><DT
+><CODE
+CLASS="OPTION"
+>-S <TT
+CLASS="REPLACEABLE"
+><I
+>sndbuf</I
+></TT
+></CODE
+></DT
+><DD
+><P
+>Set socket sndbuf. If not specified, it is selected to buffer
+not more than one packet.
+  </P
+></DD
+><DT
+><CODE
+CLASS="OPTION"
+>-t <TT
+CLASS="REPLACEABLE"
+><I
+>ttl</I
+></TT
+></CODE
+></DT
+><DD
+><P
+><B
+CLASS="COMMAND"
+>ping</B
+> only.
+Set the IP Time to Live.
+  </P
+></DD
+><DT
+><CODE
+CLASS="OPTION"
+>-T <TT
+CLASS="REPLACEABLE"
+><I
+>timestamp option</I
+></TT
+></CODE
+></DT
+><DD
+><P
+>Set special IP timestamp options.
+<TT
+CLASS="REPLACEABLE"
+><I
+>timestamp option</I
+></TT
+> may be either 
+<TT
+CLASS="REPLACEABLE"
+><I
+>tsonly</I
+></TT
+> (only timestamps), 
+<TT
+CLASS="REPLACEABLE"
+><I
+>tsandaddr</I
+></TT
+> (timestamps and addresses) or 
+<TT
+CLASS="REPLACEABLE"
+><I
+>tsprespec host1 [host2 [host3 [host4]]]</I
+></TT
+>
+(timestamp prespecified hops).
+  </P
+></DD
+><DT
+><CODE
+CLASS="OPTION"
+>-U</CODE
+></DT
+><DD
+><P
+>Print full user-to-user latency (the old behaviour). Normally
+<B
+CLASS="COMMAND"
+>ping</B
+>
+prints network round trip time, which can be different
+f.e. due to DNS failures. 
+  </P
+></DD
+><DT
+><CODE
+CLASS="OPTION"
+>-v</CODE
+></DT
+><DD
+><P
+>Verbose output.
+  </P
+></DD
+><DT
+><CODE
+CLASS="OPTION"
+>-V</CODE
+></DT
+><DD
+><P
+>Show version and exit.
+  </P
+></DD
+><DT
+><CODE
+CLASS="OPTION"
+><A
+NAME="PING.DEADLINE"
+></A
+>-w <TT
+CLASS="REPLACEABLE"
+><I
+>deadline</I
+></TT
+></CODE
+></DT
+><DD
+><P
+>Specify a timeout, in seconds, before
+<B
+CLASS="COMMAND"
+>ping</B
+>
+exits regardless of how many
+packets have been sent or received. In this case
+<B
+CLASS="COMMAND"
+>ping</B
+>
+does not stop after
+<A
+HREF="r3.html#PING.COUNT"
+><TT
+CLASS="REPLACEABLE"
+><I
+>count</I
+></TT
+></A
+>
+packet are sent, it waits either for
+<A
+HREF="r3.html#PING.DEADLINE"
+><TT
+CLASS="REPLACEABLE"
+><I
+>deadline</I
+></TT
+></A
+>
+expire or until
+<A
+HREF="r3.html#PING.COUNT"
+><TT
+CLASS="REPLACEABLE"
+><I
+>count</I
+></TT
+></A
+>
+probes are answered or for some error notification from network.   
+  </P
+></DD
+><DT
+><CODE
+CLASS="OPTION"
+>-W <TT
+CLASS="REPLACEABLE"
+><I
+>timeout</I
+></TT
+></CODE
+></DT
+><DD
+><P
+>Time to wait for a response, in seconds. The option affects only timeout
+in absence of any responses, otherwise <B
+CLASS="COMMAND"
+>ping</B
+> waits for two RTTs.
+  </P
+></DD
+></DL
+></DIV
+><P
+>When using <B
+CLASS="COMMAND"
+>ping</B
+> for fault isolation, it should first be run
+on the local host, to verify that the local network interface is up
+and running. Then, hosts and gateways further and further away should be
+``pinged''. Round-trip times and packet loss statistics are computed.
+If duplicate packets are received, they are not included in the packet
+loss calculation, although the round trip time of these packets is used
+in calculating the minimum/average/maximum round-trip time numbers.
+When the specified number of packets have been sent (and received) or
+if the program is terminated with a
+<CODE
+CLASS="CONSTANT"
+>SIGINT</CODE
+>, a brief summary is displayed. Shorter current statistics
+can be obtained without termination of process with signal
+<CODE
+CLASS="CONSTANT"
+>SIGQUIT</CODE
+>.</P
+><P
+>If <B
+CLASS="COMMAND"
+>ping</B
+> does not receive any reply packets at all it will
+exit with code 1. If a packet 
+<A
+HREF="r3.html#PING.COUNT"
+><TT
+CLASS="REPLACEABLE"
+><I
+>count</I
+></TT
+></A
+>
+and
+<A
+HREF="r3.html#PING.DEADLINE"
+><TT
+CLASS="REPLACEABLE"
+><I
+>deadline</I
+></TT
+></A
+>
+are both specified, and fewer than
+<A
+HREF="r3.html#PING.COUNT"
+><TT
+CLASS="REPLACEABLE"
+><I
+>count</I
+></TT
+></A
+>
+packets are received by the time the
+<A
+HREF="r3.html#PING.DEADLINE"
+><TT
+CLASS="REPLACEABLE"
+><I
+>deadline</I
+></TT
+></A
+>
+has arrived, it will also exit with code 1. 
+On other error it exits with code 2. Otherwise it exits with code 0. This
+makes it possible to use the exit code to see if a host is alive or
+not.</P
+><P
+>This program is intended for use in network testing, measurement and
+management.
+Because of the load it can impose on the network, it is unwise to use
+<B
+CLASS="COMMAND"
+>ping</B
+> during normal operations or from automated scripts.</P
+></DIV
+><DIV
+CLASS="REFSECT1"
+><A
+NAME="AEN402"
+></A
+><H2
+>ICMP PACKET DETAILS</H2
+><P
+>An IP header without options is 20 bytes.
+An ICMP ECHO_REQUEST packet contains an additional 8 bytes worth
+of ICMP header followed by an arbitrary amount of data.
+When a <TT
+CLASS="REPLACEABLE"
+><I
+>packetsize</I
+></TT
+> is given, this indicated the size of this
+extra piece of data (the default is 56). Thus the amount of data received
+inside of an IP packet of type ICMP ECHO_REPLY will always be 8 bytes
+more than the requested data space (the ICMP header).</P
+><P
+>If the data space is at least of size of <CODE
+CLASS="STRUCTNAME"
+>struct timeval</CODE
+>
+<B
+CLASS="COMMAND"
+>ping</B
+> uses the beginning bytes of this space to include
+a timestamp which it uses in the computation of round trip times.
+If the data space is shorter, no round trip times are given.</P
+></DIV
+><DIV
+CLASS="REFSECT1"
+><A
+NAME="AEN409"
+></A
+><H2
+>DUPLICATE AND DAMAGED PACKETS</H2
+><P
+><B
+CLASS="COMMAND"
+>ping</B
+> will report duplicate and damaged packets.
+Duplicate packets should never occur, and seem to be caused by
+inappropriate link-level retransmissions.
+Duplicates may occur in many situations and are rarely (if ever) a
+good sign, although the presence of low levels of duplicates may not
+always be cause for alarm.</P
+><P
+>Damaged packets are obviously serious cause for alarm and often
+indicate broken hardware somewhere in the
+<B
+CLASS="COMMAND"
+>ping</B
+> packet's path (in the network or in the hosts).</P
+></DIV
+><DIV
+CLASS="REFSECT1"
+><A
+NAME="AEN415"
+></A
+><H2
+>TRYING DIFFERENT DATA PATTERNS</H2
+><P
+>The (inter)network layer should never treat packets differently depending
+on the data contained in the data portion.
+Unfortunately, data-dependent problems have been known to sneak into
+networks and remain undetected for long periods of time.
+In many cases the particular pattern that will have problems is something
+that doesn't have sufficient ``transitions'', such as all ones or all
+zeros, or a pattern right at the edge, such as almost all zeros.
+It isn't necessarily enough to specify a data pattern of all zeros (for
+example) on the command line because the pattern that is of interest is
+at the data link level, and the relationship between what you type and
+what the controllers transmit can be complicated.</P
+><P
+>This means that if you have a data-dependent problem you will probably
+have to do a lot of testing to find it.
+If you are lucky, you may manage to find a file that either can't be sent
+across your network or that takes much longer to transfer than other
+similar length files.
+You can then examine this file for repeated patterns that you can test
+using the <CODE
+CLASS="OPTION"
+>-p</CODE
+> option of <B
+CLASS="COMMAND"
+>ping</B
+>.</P
+></DIV
+><DIV
+CLASS="REFSECT1"
+><A
+NAME="AEN421"
+></A
+><H2
+>TTL DETAILS</H2
+><P
+>The TTL value of an IP packet represents the maximum number of IP routers
+that the packet can go through before being thrown away.
+In current practice you can expect each router in the Internet to decrement
+the TTL field by exactly one.</P
+><P
+>The TCP/IP specification states that the TTL field for TCP
+packets should be set to 60, but many systems use smaller values
+(4.3 BSD uses 30, 4.2 used 15).</P
+><P
+>The maximum possible value of this field is 255, and most Unix systems set
+the TTL field of ICMP ECHO_REQUEST packets to 255.
+This is why you will find you can ``ping'' some hosts, but not reach them
+with
+<SPAN
+CLASS="CITEREFENTRY"
+><SPAN
+CLASS="REFENTRYTITLE"
+>telnet</SPAN
+>(1)</SPAN
+>
+or
+<SPAN
+CLASS="CITEREFENTRY"
+><SPAN
+CLASS="REFENTRYTITLE"
+>ftp</SPAN
+>(1)</SPAN
+>.</P
+><P
+>In normal operation ping prints the TTL value from the packet it receives.
+When a remote system receives a ping packet, it can do one of three things
+with the TTL field in its response:</P
+><P
+></P
+><UL
+><LI
+><P
+>Not change it; this is what Berkeley Unix systems did before the
+4.3BSD Tahoe release. In this case the TTL value in the received packet
+will be 255 minus the number of routers in the round-trip path.
+ </P
+></LI
+><LI
+><P
+>Set it to 255; this is what current Berkeley Unix systems do.
+In this case the TTL value in the received packet will be 255 minus the
+number of routers in the path <SPAN
+CLASS="emphasis"
+><I
+CLASS="EMPHASIS"
+>from</I
+></SPAN
+>
+the remote system <SPAN
+CLASS="emphasis"
+><I
+CLASS="EMPHASIS"
+>to</I
+></SPAN
+> the <B
+CLASS="COMMAND"
+>ping</B
+>ing host.
+ </P
+></LI
+><LI
+><P
+>Set it to some other value. Some machines use the same value for
+ICMP packets that they use for TCP packets, for example either 30 or 60.
+Others may use completely wild values.
+ </P
+></LI
+></UL
+></DIV
+><DIV
+CLASS="REFSECT1"
+><A
+NAME="AEN443"
+></A
+><H2
+>BUGS</H2
+><P
+></P
+><UL
+><LI
+><P
+>Many Hosts and Gateways ignore the RECORD_ROUTE option.
+ </P
+></LI
+><LI
+><P
+>The maximum IP header length is too small for options like
+RECORD_ROUTE to be completely useful.
+There's not much that can be done about this, however.
+ </P
+></LI
+><LI
+><P
+>Flood pinging is not recommended in general, and flood pinging the
+broadcast address should only be done under very controlled conditions.
+ </P
+></LI
+></UL
+></DIV
+><DIV
+CLASS="REFSECT1"
+><A
+NAME="AEN452"
+></A
+><H2
+>SEE ALSO</H2
+><P
+><SPAN
+CLASS="CITEREFENTRY"
+><SPAN
+CLASS="REFENTRYTITLE"
+>netstat</SPAN
+>(1)</SPAN
+>,
+<SPAN
+CLASS="CITEREFENTRY"
+><SPAN
+CLASS="REFENTRYTITLE"
+>ifconfig</SPAN
+>(8)</SPAN
+>.</P
+></DIV
+><DIV
+CLASS="REFSECT1"
+><A
+NAME="AEN461"
+></A
+><H2
+>HISTORY</H2
+><P
+>The <B
+CLASS="COMMAND"
+>ping</B
+> command appeared in 4.3BSD.</P
+><P
+>The version described here is its descendant specific to Linux.</P
+><P
+>As of version s20150815, the <B
+CLASS="COMMAND"
+>ping6</B
+> binary doesn't exist anymore.
+It has been merged into <B
+CLASS="COMMAND"
+>ping</B
+>. Creating a symlink named
+<B
+CLASS="COMMAND"
+>ping6</B
+> pointing to <B
+CLASS="COMMAND"
+>ping</B
+> will result in the same
+funcionality as before.</P
+></DIV
+><DIV
+CLASS="REFSECT1"
+><A
+NAME="AEN471"
+></A
+><H2
+>SECURITY</H2
+><P
+><B
+CLASS="COMMAND"
+>ping</B
+> requires <CODE
+CLASS="CONSTANT"
+>CAP_NET_RAW</CODE
+> capability
+to be executed 1) if the program is used for non-echo queries
+(See <CODE
+CLASS="OPTION"
+>-N</CODE
+> option), or 2) if kernel does not
+support non-raw ICMP sockets, or 3) if the user is not allowed
+to create an ICMP echo socket.  The program may be used as
+set-uid root.</P
+></DIV
+><DIV
+CLASS="REFSECT1"
+><A
+NAME="AEN477"
+></A
+><H2
+>AVAILABILITY</H2
+><P
+><B
+CLASS="COMMAND"
+>ping</B
+> is part of <TT
+CLASS="FILENAME"
+>iputils</TT
+> package
+and the latest versions are  available in source form at
+<A
+HREF="http://www.skbuff.net/iputils/iputils-current.tar.bz2"
+TARGET="_top"
+>http://www.skbuff.net/iputils/iputils-current.tar.bz2</A
+>.</P
+></DIV
+><DIV
+CLASS="NAVFOOTER"
+><HR
+ALIGN="LEFT"
+WIDTH="100%"><TABLE
+SUMMARY="Footer navigation table"
+WIDTH="100%"
+BORDER="0"
+CELLPADDING="0"
+CELLSPACING="0"
+><TR
+><TD
+WIDTH="33%"
+ALIGN="left"
+VALIGN="top"
+><A
+HREF="index.html"
+ACCESSKEY="P"
+>Prev</A
+></TD
+><TD
+WIDTH="34%"
+ALIGN="center"
+VALIGN="top"
+><A
+HREF="index.html"
+ACCESSKEY="H"
+>Home</A
+></TD
+><TD
+WIDTH="33%"
+ALIGN="right"
+VALIGN="top"
+><A
+HREF="r483.html"
+ACCESSKEY="N"
+>Next</A
+></TD
+></TR
+><TR
+><TD
+WIDTH="33%"
+ALIGN="left"
+VALIGN="top"
+>System Manager's Manual: iputils</TD
+><TD
+WIDTH="34%"
+ALIGN="center"
+VALIGN="top"
+>&nbsp;</TD
+><TD
+WIDTH="33%"
+ALIGN="right"
+VALIGN="top"
+>arping</TD
+></TR
+></TABLE
+></DIV
+></BODY
+></HTML
+>
\ No newline at end of file
diff -Naur iputils-s20151218.orig/doc/r483.html iputils-s20151218/doc/r483.html
--- iputils-s20151218.orig/doc/r483.html	1970-01-01 00:00:00.000000000 +0000
+++ iputils-s20151218/doc/r483.html	2016-07-16 01:02:47.067156522 +0000
@@ -0,0 +1,594 @@
+<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN""http://www.w3.org/TR/html4/loose.dtd">
+<HTML
+><HEAD
+><TITLE
+>arping</TITLE
+><META
+NAME="GENERATOR"
+CONTENT="Modular DocBook HTML Stylesheet Version 1.79"><LINK
+REL="HOME"
+TITLE="System Manager's Manual: iputils"
+HREF="index.html"><LINK
+REL="PREVIOUS"
+TITLE="ping"
+HREF="r3.html"><LINK
+REL="NEXT"
+TITLE="clockdiff"
+HREF="r641.html"></HEAD
+><BODY
+CLASS="REFENTRY"
+BGCOLOR="#FFFFFF"
+TEXT="#000000"
+LINK="#0000FF"
+VLINK="#840084"
+ALINK="#0000FF"
+><DIV
+CLASS="NAVHEADER"
+><TABLE
+SUMMARY="Header navigation table"
+WIDTH="100%"
+BORDER="0"
+CELLPADDING="0"
+CELLSPACING="0"
+><TR
+><TH
+COLSPAN="3"
+ALIGN="center"
+>System Manager's Manual: iputils</TH
+></TR
+><TR
+><TD
+WIDTH="10%"
+ALIGN="left"
+VALIGN="bottom"
+><A
+HREF="r3.html"
+ACCESSKEY="P"
+>Prev</A
+></TD
+><TD
+WIDTH="80%"
+ALIGN="center"
+VALIGN="bottom"
+></TD
+><TD
+WIDTH="10%"
+ALIGN="right"
+VALIGN="bottom"
+><A
+HREF="r641.html"
+ACCESSKEY="N"
+>Next</A
+></TD
+></TR
+></TABLE
+><HR
+ALIGN="LEFT"
+WIDTH="100%"></DIV
+><H1
+><A
+NAME="ARPING"
+></A
+>arping</H1
+><DIV
+CLASS="REFNAMEDIV"
+><A
+NAME="AEN488"
+></A
+><H2
+>Name</H2
+>arping&nbsp;--&nbsp;send ARP REQUEST to a neighbour host</DIV
+><DIV
+CLASS="REFSYNOPSISDIV"
+><A
+NAME="AEN491"
+></A
+><H2
+>Synopsis</H2
+><P
+><B
+CLASS="COMMAND"
+>arping</B
+>  [<CODE
+CLASS="OPTION"
+>-AbDfhqUV</CODE
+>] [-c <TT
+CLASS="REPLACEABLE"
+><I
+>count</I
+></TT
+>] [-w <TT
+CLASS="REPLACEABLE"
+><I
+>deadline</I
+></TT
+>] [-s <TT
+CLASS="REPLACEABLE"
+><I
+>source</I
+></TT
+>] {-I <TT
+CLASS="REPLACEABLE"
+><I
+>interface</I
+></TT
+>} {<TT
+CLASS="REPLACEABLE"
+><I
+>destination</I
+></TT
+>}</P
+></DIV
+><DIV
+CLASS="REFSECT1"
+><A
+NAME="AEN506"
+></A
+><H2
+>DESCRIPTION</H2
+><P
+>Ping <TT
+CLASS="REPLACEABLE"
+><I
+>destination</I
+></TT
+> on device <TT
+CLASS="REPLACEABLE"
+><I
+>interface</I
+></TT
+> by ARP packets,
+using source address <TT
+CLASS="REPLACEABLE"
+><I
+>source</I
+></TT
+>.</P
+></DIV
+><DIV
+CLASS="REFSECT1"
+><A
+NAME="AEN512"
+></A
+><H2
+>OPTIONS</H2
+><P
+></P
+><DIV
+CLASS="VARIABLELIST"
+><DL
+><DT
+><CODE
+CLASS="OPTION"
+>-A</CODE
+></DT
+><DD
+><P
+>The same as <CODE
+CLASS="OPTION"
+>-U</CODE
+>, but ARP REPLY packets used instead
+of ARP REQUEST.
+  </P
+></DD
+><DT
+><CODE
+CLASS="OPTION"
+>-b</CODE
+></DT
+><DD
+><P
+>Send only MAC level broadcasts. Normally <B
+CLASS="COMMAND"
+>arping</B
+> starts
+from sending broadcast, and switch to unicast after reply received.
+  </P
+></DD
+><DT
+><CODE
+CLASS="OPTION"
+><A
+NAME="ARPING.COUNT"
+></A
+>-c <TT
+CLASS="REPLACEABLE"
+><I
+>count</I
+></TT
+></CODE
+></DT
+><DD
+><P
+>Stop after sending <TT
+CLASS="REPLACEABLE"
+><I
+>count</I
+></TT
+> ARP REQUEST
+packets. With 
+<A
+HREF="r483.html#ARPING.DEADLINE"
+><TT
+CLASS="REPLACEABLE"
+><I
+>deadline</I
+></TT
+></A
+>
+option, instead wait for
+<TT
+CLASS="REPLACEABLE"
+><I
+>count</I
+></TT
+> ARP REPLY packets, or until the timeout expires.
+  </P
+></DD
+><DT
+><CODE
+CLASS="OPTION"
+>-D</CODE
+></DT
+><DD
+><P
+>Duplicate address detection mode (DAD). See 
+<A
+HREF="http://tools.ietf.org/rfc/rfc2131.txt"
+TARGET="_top"
+>RFC2131, 4.4.1</A
+>.
+Returns 0, if DAD succeeded i.e. no replies are received
+  </P
+></DD
+><DT
+><CODE
+CLASS="OPTION"
+>-f</CODE
+></DT
+><DD
+><P
+>Finish after the first reply confirming that target is alive.
+  </P
+></DD
+><DT
+><CODE
+CLASS="OPTION"
+><A
+NAME="OPT.INTERFACE"
+></A
+>-I <TT
+CLASS="REPLACEABLE"
+><I
+>interface</I
+></TT
+></CODE
+></DT
+><DD
+><P
+>Name of network device where to send ARP REQUEST packets.
+  </P
+></DD
+><DT
+><CODE
+CLASS="OPTION"
+>-h</CODE
+></DT
+><DD
+><P
+>Print help page and exit.
+  </P
+></DD
+><DT
+><CODE
+CLASS="OPTION"
+>-q</CODE
+></DT
+><DD
+><P
+>Quiet output. Nothing is displayed.
+  </P
+></DD
+><DT
+><CODE
+CLASS="OPTION"
+><A
+NAME="OPT.SOURCE"
+></A
+>-s <TT
+CLASS="REPLACEABLE"
+><I
+>source</I
+></TT
+></CODE
+></DT
+><DD
+><P
+>IP source address to use in ARP packets.
+If this option is absent, source address is:
+   <P
+></P
+><UL
+><LI
+><P
+>In DAD mode (with option <CODE
+CLASS="OPTION"
+>-D</CODE
+>) set to 0.0.0.0.
+    </P
+></LI
+><LI
+><P
+>In Unsolicited ARP mode (with options <CODE
+CLASS="OPTION"
+>-U</CODE
+> or <CODE
+CLASS="OPTION"
+>-A</CODE
+>)
+set to <TT
+CLASS="REPLACEABLE"
+><I
+>destination</I
+></TT
+>.
+    </P
+></LI
+><LI
+><P
+>Otherwise, it is calculated from routing tables.
+    </P
+></LI
+></UL
+>
+  </P
+></DD
+><DT
+><CODE
+CLASS="OPTION"
+>-U</CODE
+></DT
+><DD
+><P
+>Unsolicited ARP mode to update neighbours' ARP caches.
+No replies are expected.
+  </P
+></DD
+><DT
+><CODE
+CLASS="OPTION"
+>-V</CODE
+></DT
+><DD
+><P
+>Print version of the program and exit.
+  </P
+></DD
+><DT
+><CODE
+CLASS="OPTION"
+><A
+NAME="ARPING.DEADLINE"
+></A
+>-w <TT
+CLASS="REPLACEABLE"
+><I
+>deadline</I
+></TT
+></CODE
+></DT
+><DD
+><P
+>Specify a timeout, in seconds, before
+<B
+CLASS="COMMAND"
+>arping</B
+>
+exits regardless of how many
+packets have been sent or received. In this case
+<B
+CLASS="COMMAND"
+>arping</B
+>
+does not stop after
+<A
+HREF="r483.html#ARPING.COUNT"
+><TT
+CLASS="REPLACEABLE"
+><I
+>count</I
+></TT
+></A
+>
+packet are sent, it waits either for
+<A
+HREF="r483.html#ARPING.DEADLINE"
+><TT
+CLASS="REPLACEABLE"
+><I
+>deadline</I
+></TT
+></A
+>
+expire or until
+<A
+HREF="r483.html#ARPING.COUNT"
+><TT
+CLASS="REPLACEABLE"
+><I
+>count</I
+></TT
+></A
+>
+probes are answered.
+  </P
+></DD
+></DL
+></DIV
+></DIV
+><DIV
+CLASS="REFSECT1"
+><A
+NAME="AEN609"
+></A
+><H2
+>SEE ALSO</H2
+><P
+><A
+HREF="r3.html"
+><SPAN
+CLASS="CITEREFENTRY"
+><SPAN
+CLASS="REFENTRYTITLE"
+>ping</SPAN
+>(8)</SPAN
+></A
+>,
+<A
+HREF="r641.html"
+><SPAN
+CLASS="CITEREFENTRY"
+><SPAN
+CLASS="REFENTRYTITLE"
+>clockdiff</SPAN
+>(8)</SPAN
+></A
+>,
+<A
+HREF="r835.html"
+><SPAN
+CLASS="CITEREFENTRY"
+><SPAN
+CLASS="REFENTRYTITLE"
+>tracepath</SPAN
+>(8)</SPAN
+></A
+>.</P
+></DIV
+><DIV
+CLASS="REFSECT1"
+><A
+NAME="AEN624"
+></A
+><H2
+>AUTHOR</H2
+><P
+><B
+CLASS="COMMAND"
+>arping</B
+> was written by
+<A
+HREF="mailto:kuznet@ms2.inr.ac.ru"
+TARGET="_top"
+>Alexey Kuznetsov
+&lt;kuznet@ms2.inr.ac.ru&gt;</A
+>.
+It is now maintained by
+<A
+HREF="mailto:yoshfuji@skbuff.net"
+TARGET="_top"
+>YOSHIFUJI Hideaki
+&lt;yoshfuji@skbuff.net&gt;</A
+>.</P
+></DIV
+><DIV
+CLASS="REFSECT1"
+><A
+NAME="AEN630"
+></A
+><H2
+>SECURITY</H2
+><P
+><B
+CLASS="COMMAND"
+>arping</B
+> requires <CODE
+CLASS="CONSTANT"
+>CAP_NET_RAW</CODE
+> capability
+to be executed. It is not recommended to be used as set-uid root,
+because it allows user to modify ARP caches of neighbour hosts.</P
+></DIV
+><DIV
+CLASS="REFSECT1"
+><A
+NAME="AEN635"
+></A
+><H2
+>AVAILABILITY</H2
+><P
+><B
+CLASS="COMMAND"
+>arping</B
+> is part of <TT
+CLASS="FILENAME"
+>iputils</TT
+> package
+and the latest versions are  available in source form at
+<A
+HREF="http://www.skbuff.net/iputils/iputils-current.tar.bz2"
+TARGET="_top"
+>http://www.skbuff.net/iputils/iputils-current.tar.bz2</A
+>.</P
+></DIV
+><DIV
+CLASS="NAVFOOTER"
+><HR
+ALIGN="LEFT"
+WIDTH="100%"><TABLE
+SUMMARY="Footer navigation table"
+WIDTH="100%"
+BORDER="0"
+CELLPADDING="0"
+CELLSPACING="0"
+><TR
+><TD
+WIDTH="33%"
+ALIGN="left"
+VALIGN="top"
+><A
+HREF="r3.html"
+ACCESSKEY="P"
+>Prev</A
+></TD
+><TD
+WIDTH="34%"
+ALIGN="center"
+VALIGN="top"
+><A
+HREF="index.html"
+ACCESSKEY="H"
+>Home</A
+></TD
+><TD
+WIDTH="33%"
+ALIGN="right"
+VALIGN="top"
+><A
+HREF="r641.html"
+ACCESSKEY="N"
+>Next</A
+></TD
+></TR
+><TR
+><TD
+WIDTH="33%"
+ALIGN="left"
+VALIGN="top"
+>ping</TD
+><TD
+WIDTH="34%"
+ALIGN="center"
+VALIGN="top"
+>&nbsp;</TD
+><TD
+WIDTH="33%"
+ALIGN="right"
+VALIGN="top"
+>clockdiff</TD
+></TR
+></TABLE
+></DIV
+></BODY
+></HTML
+>
\ No newline at end of file
diff -Naur iputils-s20151218.orig/doc/r641.html iputils-s20151218/doc/r641.html
--- iputils-s20151218.orig/doc/r641.html	1970-01-01 00:00:00.000000000 +0000
+++ iputils-s20151218/doc/r641.html	2016-07-16 01:02:47.127156059 +0000
@@ -0,0 +1,428 @@
+<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN""http://www.w3.org/TR/html4/loose.dtd">
+<HTML
+><HEAD
+><TITLE
+>clockdiff</TITLE
+><META
+NAME="GENERATOR"
+CONTENT="Modular DocBook HTML Stylesheet Version 1.79"><LINK
+REL="HOME"
+TITLE="System Manager's Manual: iputils"
+HREF="index.html"><LINK
+REL="PREVIOUS"
+TITLE="arping"
+HREF="r483.html"><LINK
+REL="NEXT"
+TITLE="rarpd"
+HREF="r736.html"></HEAD
+><BODY
+CLASS="REFENTRY"
+BGCOLOR="#FFFFFF"
+TEXT="#000000"
+LINK="#0000FF"
+VLINK="#840084"
+ALINK="#0000FF"
+><DIV
+CLASS="NAVHEADER"
+><TABLE
+SUMMARY="Header navigation table"
+WIDTH="100%"
+BORDER="0"
+CELLPADDING="0"
+CELLSPACING="0"
+><TR
+><TH
+COLSPAN="3"
+ALIGN="center"
+>System Manager's Manual: iputils</TH
+></TR
+><TR
+><TD
+WIDTH="10%"
+ALIGN="left"
+VALIGN="bottom"
+><A
+HREF="r483.html"
+ACCESSKEY="P"
+>Prev</A
+></TD
+><TD
+WIDTH="80%"
+ALIGN="center"
+VALIGN="bottom"
+></TD
+><TD
+WIDTH="10%"
+ALIGN="right"
+VALIGN="bottom"
+><A
+HREF="r736.html"
+ACCESSKEY="N"
+>Next</A
+></TD
+></TR
+></TABLE
+><HR
+ALIGN="LEFT"
+WIDTH="100%"></DIV
+><H1
+><A
+NAME="CLOCKDIFF"
+></A
+>clockdiff</H1
+><DIV
+CLASS="REFNAMEDIV"
+><A
+NAME="AEN646"
+></A
+><H2
+>Name</H2
+>clockdiff&nbsp;--&nbsp;measure clock difference between hosts</DIV
+><DIV
+CLASS="REFSYNOPSISDIV"
+><A
+NAME="AEN649"
+></A
+><H2
+>Synopsis</H2
+><P
+><B
+CLASS="COMMAND"
+>clockdiff</B
+>  [<CODE
+CLASS="OPTION"
+>-o</CODE
+>] [<CODE
+CLASS="OPTION"
+>-o1</CODE
+>] {<TT
+CLASS="REPLACEABLE"
+><I
+>destination</I
+></TT
+>}</P
+></DIV
+><DIV
+CLASS="REFSECT1"
+><A
+NAME="AEN658"
+></A
+><H2
+>DESCRIPTION</H2
+><P
+><B
+CLASS="COMMAND"
+>clockdiff</B
+> Measures clock difference between us and
+<TT
+CLASS="REPLACEABLE"
+><I
+>destination</I
+></TT
+> with 1 msec resolution using ICMP TIMESTAMP
+<A
+HREF="r641.html#CLOCKDIFF.ICMP-TIMESTAMP"
+>[2]</A
+>
+packets or, optionally, IP TIMESTAMP option
+<A
+HREF="r641.html#CLOCKDIFF.IP-TIMESTAMP"
+>[3]</A
+>
+option added to ICMP ECHO.
+<A
+HREF="r641.html#CLOCKDIFF.ICMP-ECHO"
+>[1]</A
+></P
+></DIV
+><DIV
+CLASS="REFSECT1"
+><A
+NAME="AEN666"
+></A
+><H2
+>OPTIONS</H2
+><P
+></P
+><DIV
+CLASS="VARIABLELIST"
+><DL
+><DT
+><CODE
+CLASS="OPTION"
+>-o</CODE
+></DT
+><DD
+><P
+>Use IP TIMESTAMP with ICMP ECHO instead of ICMP TIMESTAMP
+messages. It is useful with some destinations, which do not support
+ICMP TIMESTAMP (f.e. Solaris &lt;2.4).
+  </P
+></DD
+><DT
+><CODE
+CLASS="OPTION"
+>-o1</CODE
+></DT
+><DD
+><P
+>Slightly different form of <CODE
+CLASS="OPTION"
+>-o</CODE
+>, namely it uses three-term
+IP TIMESTAMP with prespecified hop addresses instead of four term one.
+What flavor works better depends on target host. Particularly,
+<CODE
+CLASS="OPTION"
+>-o</CODE
+> is better for Linux.
+  </P
+></DD
+></DL
+></DIV
+></DIV
+><DIV
+CLASS="REFSECT1"
+><A
+NAME="AEN681"
+></A
+><H2
+>WARNINGS</H2
+><P
+></P
+><UL
+><LI
+><P
+>Some nodes (Cisco) use non-standard timestamps, which is allowed
+by RFC, but makes timestamps mostly useless.
+ </P
+></LI
+><LI
+><P
+>Some nodes generate messed timestamps (Solaris&gt;2.4), when
+run <B
+CLASS="COMMAND"
+>xntpd</B
+>. Seems, its IP stack uses a corrupted clock source,
+which is synchronized to time-of-day clock periodically and jumps
+randomly making timestamps mostly useless. Good news is that you can
+use NTP in this case, which is even better.
+ </P
+></LI
+><LI
+><P
+><B
+CLASS="COMMAND"
+>clockdiff</B
+> shows difference in time modulo 24 days.
+ </P
+></LI
+></UL
+></DIV
+><DIV
+CLASS="REFSECT1"
+><A
+NAME="AEN692"
+></A
+><H2
+>SEE ALSO</H2
+><P
+><A
+HREF="r3.html"
+><SPAN
+CLASS="CITEREFENTRY"
+><SPAN
+CLASS="REFENTRYTITLE"
+>ping</SPAN
+>(8)</SPAN
+></A
+>,
+<A
+HREF="r483.html"
+><SPAN
+CLASS="CITEREFENTRY"
+><SPAN
+CLASS="REFENTRYTITLE"
+>arping</SPAN
+>(8)</SPAN
+></A
+>,
+<A
+HREF="r835.html"
+><SPAN
+CLASS="CITEREFENTRY"
+><SPAN
+CLASS="REFENTRYTITLE"
+>tracepath</SPAN
+>(8)</SPAN
+></A
+>.</P
+></DIV
+><DIV
+CLASS="REFSECT1"
+><A
+NAME="AEN707"
+></A
+><H2
+>REFERENCES</H2
+><P
+>[1] <A
+NAME="CLOCKDIFF.ICMP-ECHO"
+></A
+>ICMP ECHO,
+<A
+HREF="http://tools.ietf.org/rfc/rfc792.txt"
+TARGET="_top"
+>RFC0792, page 14</A
+>.</P
+><P
+>[2] <A
+NAME="CLOCKDIFF.ICMP-TIMESTAMP"
+></A
+>ICMP TIMESTAMP,
+<A
+HREF="http://tools.ietf.org/rfc/rfc792.txt"
+TARGET="_top"
+>RFC0792, page 16</A
+>.</P
+><P
+>[3] <A
+NAME="CLOCKDIFF.IP-TIMESTAMP"
+></A
+>IP TIMESTAMP option,
+<A
+HREF="http://tools.ietf.org/rfc/rfc791.txt"
+TARGET="_top"
+>RFC0791, 3.1, page 16</A
+>.</P
+></DIV
+><DIV
+CLASS="REFSECT1"
+><A
+NAME="AEN718"
+></A
+><H2
+>AUTHOR</H2
+><P
+><B
+CLASS="COMMAND"
+>clockdiff</B
+> was compiled by
+<A
+HREF="mailto:kuznet@ms2.inr.ac.ru"
+TARGET="_top"
+>Alexey Kuznetsov
+&lt;kuznet@ms2.inr.ac.ru&gt;</A
+>. It was based on code borrowed
+from BSD <B
+CLASS="COMMAND"
+>timed</B
+> daemon.
+It is now maintained by
+<A
+HREF="mailto:yoshfuji@skbuff.net"
+TARGET="_top"
+>YOSHIFUJI Hideaki
+&lt;yoshfuji@skbuff.net&gt;</A
+>.</P
+></DIV
+><DIV
+CLASS="REFSECT1"
+><A
+NAME="AEN725"
+></A
+><H2
+>SECURITY</H2
+><P
+><B
+CLASS="COMMAND"
+>clockdiff</B
+> requires <CODE
+CLASS="CONSTANT"
+>CAP_NET_RAW</CODE
+> capability
+to be executed. It is safe to be used as set-uid root.</P
+></DIV
+><DIV
+CLASS="REFSECT1"
+><A
+NAME="AEN730"
+></A
+><H2
+>AVAILABILITY</H2
+><P
+><B
+CLASS="COMMAND"
+>clockdiff</B
+> is part of <TT
+CLASS="FILENAME"
+>iputils</TT
+> package
+and the latest versions are  available in source form at
+<A
+HREF="http://www.skbuff.net/iputils/iputils-current.tar.bz2"
+TARGET="_top"
+>http://www.skbuff.net/iputils/iputils-current.tar.bz2</A
+>.</P
+></DIV
+><DIV
+CLASS="NAVFOOTER"
+><HR
+ALIGN="LEFT"
+WIDTH="100%"><TABLE
+SUMMARY="Footer navigation table"
+WIDTH="100%"
+BORDER="0"
+CELLPADDING="0"
+CELLSPACING="0"
+><TR
+><TD
+WIDTH="33%"
+ALIGN="left"
+VALIGN="top"
+><A
+HREF="r483.html"
+ACCESSKEY="P"
+>Prev</A
+></TD
+><TD
+WIDTH="34%"
+ALIGN="center"
+VALIGN="top"
+><A
+HREF="index.html"
+ACCESSKEY="H"
+>Home</A
+></TD
+><TD
+WIDTH="33%"
+ALIGN="right"
+VALIGN="top"
+><A
+HREF="r736.html"
+ACCESSKEY="N"
+>Next</A
+></TD
+></TR
+><TR
+><TD
+WIDTH="33%"
+ALIGN="left"
+VALIGN="top"
+>arping</TD
+><TD
+WIDTH="34%"
+ALIGN="center"
+VALIGN="top"
+>&nbsp;</TD
+><TD
+WIDTH="33%"
+ALIGN="right"
+VALIGN="top"
+>rarpd</TD
+></TR
+></TABLE
+></DIV
+></BODY
+></HTML
+>
\ No newline at end of file
diff -Naur iputils-s20151218.orig/doc/r736.html iputils-s20151218/doc/r736.html
--- iputils-s20151218.orig/doc/r736.html	1970-01-01 00:00:00.000000000 +0000
+++ iputils-s20151218/doc/r736.html	2016-07-16 01:02:47.177155673 +0000
@@ -0,0 +1,431 @@
+<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN""http://www.w3.org/TR/html4/loose.dtd">
+<HTML
+><HEAD
+><TITLE
+>rarpd</TITLE
+><META
+NAME="GENERATOR"
+CONTENT="Modular DocBook HTML Stylesheet Version 1.79"><LINK
+REL="HOME"
+TITLE="System Manager's Manual: iputils"
+HREF="index.html"><LINK
+REL="PREVIOUS"
+TITLE="clockdiff"
+HREF="r641.html"><LINK
+REL="NEXT"
+TITLE="tracepath"
+HREF="r835.html"></HEAD
+><BODY
+CLASS="REFENTRY"
+BGCOLOR="#FFFFFF"
+TEXT="#000000"
+LINK="#0000FF"
+VLINK="#840084"
+ALINK="#0000FF"
+><DIV
+CLASS="NAVHEADER"
+><TABLE
+SUMMARY="Header navigation table"
+WIDTH="100%"
+BORDER="0"
+CELLPADDING="0"
+CELLSPACING="0"
+><TR
+><TH
+COLSPAN="3"
+ALIGN="center"
+>System Manager's Manual: iputils</TH
+></TR
+><TR
+><TD
+WIDTH="10%"
+ALIGN="left"
+VALIGN="bottom"
+><A
+HREF="r641.html"
+ACCESSKEY="P"
+>Prev</A
+></TD
+><TD
+WIDTH="80%"
+ALIGN="center"
+VALIGN="bottom"
+></TD
+><TD
+WIDTH="10%"
+ALIGN="right"
+VALIGN="bottom"
+><A
+HREF="r835.html"
+ACCESSKEY="N"
+>Next</A
+></TD
+></TR
+></TABLE
+><HR
+ALIGN="LEFT"
+WIDTH="100%"></DIV
+><H1
+><A
+NAME="RARPD"
+></A
+>rarpd</H1
+><DIV
+CLASS="REFNAMEDIV"
+><A
+NAME="AEN741"
+></A
+><H2
+>Name</H2
+>rarpd&nbsp;--&nbsp;answer RARP REQUESTs</DIV
+><DIV
+CLASS="REFSYNOPSISDIV"
+><A
+NAME="AEN744"
+></A
+><H2
+>Synopsis</H2
+><P
+><B
+CLASS="COMMAND"
+>arping</B
+>  [<CODE
+CLASS="OPTION"
+>-aAvde</CODE
+>] [-b <TT
+CLASS="REPLACEABLE"
+><I
+>bootdir</I
+></TT
+>] [<TT
+CLASS="REPLACEABLE"
+><I
+>interface</I
+></TT
+>]</P
+></DIV
+><DIV
+CLASS="REFSECT1"
+><A
+NAME="AEN753"
+></A
+><H2
+>DESCRIPTION</H2
+><P
+>Listens
+<A
+HREF="http://tools.ietf.org/rfc/rfc903.txt"
+TARGET="_top"
+>RARP</A
+>
+requests from clients. Provided MAC address of client
+is found in <TT
+CLASS="FILENAME"
+>/etc/ethers</TT
+> database and
+obtained host name is resolvable to an IP address appropriate
+for attached network, <B
+CLASS="COMMAND"
+>rarpd</B
+> answers to client with RARPD
+reply carrying an IP address.</P
+><P
+>To allow multiple boot servers on the network <B
+CLASS="COMMAND"
+>rarpd</B
+>
+optionally checks for presence Sun-like bootable image in TFTP directory.
+It should have form <KBD
+CLASS="USERINPUT"
+>Hexadecimal_IP.ARCH</KBD
+>, f.e. to load
+sparc 193.233.7.98 <TT
+CLASS="FILENAME"
+>C1E90762.SUN4M</TT
+> is linked to
+an image appropriate for SUM4M in directory <TT
+CLASS="FILENAME"
+>/etc/tftpboot</TT
+>.</P
+></DIV
+><DIV
+CLASS="REFSECT1"
+><A
+NAME="AEN764"
+></A
+><H2
+>WARNING</H2
+><P
+>This facility is deeply obsoleted by
+<A
+HREF="http://tools.ietf.org/rfc/rfc951.txt"
+TARGET="_top"
+>BOOTP</A
+>
+and later
+<A
+HREF="http://tools.ietf.org/rfc/rfc2131.txt"
+TARGET="_top"
+>DHCP</A
+> protocols.
+However, some clients really still need this to boot.</P
+></DIV
+><DIV
+CLASS="REFSECT1"
+><A
+NAME="AEN769"
+></A
+><H2
+>OPTIONS</H2
+><P
+></P
+><DIV
+CLASS="VARIABLELIST"
+><DL
+><DT
+><CODE
+CLASS="OPTION"
+>-a</CODE
+></DT
+><DD
+><P
+>Listen on all the interfaces. Currently it is an internal
+option, its function is overridden with <TT
+CLASS="REPLACEABLE"
+><I
+>interface</I
+></TT
+>
+argument. It should not be used.
+  </P
+></DD
+><DT
+><CODE
+CLASS="OPTION"
+>-A</CODE
+></DT
+><DD
+><P
+>Listen not only RARP but also ARP messages, some rare clients
+use ARP by some unknown reason.
+  </P
+></DD
+><DT
+><CODE
+CLASS="OPTION"
+>-v</CODE
+></DT
+><DD
+><P
+>Be verbose.
+  </P
+></DD
+><DT
+><CODE
+CLASS="OPTION"
+>-d</CODE
+></DT
+><DD
+><P
+>Debug mode. Do not go to background.
+  </P
+></DD
+><DT
+><CODE
+CLASS="OPTION"
+>-e</CODE
+></DT
+><DD
+><P
+>Do not check for presence of a boot image, reply if MAC address
+resolves to a valid IP address using <TT
+CLASS="FILENAME"
+>/etc/ethers</TT
+>
+database and DNS. 
+  </P
+></DD
+><DT
+><CODE
+CLASS="OPTION"
+>-b <TT
+CLASS="REPLACEABLE"
+><I
+>bootdir</I
+></TT
+></CODE
+></DT
+><DD
+><P
+>TFTP boot directory. Default is <TT
+CLASS="FILENAME"
+>/etc/tftpboot</TT
+>
+  </P
+></DD
+></DL
+></DIV
+></DIV
+><DIV
+CLASS="REFSECT1"
+><A
+NAME="AEN806"
+></A
+><H2
+>SEE ALSO</H2
+><P
+><A
+HREF="r483.html"
+><SPAN
+CLASS="CITEREFENTRY"
+><SPAN
+CLASS="REFENTRYTITLE"
+>arping</SPAN
+>(8)</SPAN
+></A
+>,
+<A
+HREF="r1007.html"
+><SPAN
+CLASS="CITEREFENTRY"
+><SPAN
+CLASS="REFENTRYTITLE"
+>tftpd</SPAN
+>(8)</SPAN
+></A
+>.</P
+></DIV
+><DIV
+CLASS="REFSECT1"
+><A
+NAME="AEN817"
+></A
+><H2
+>AUTHOR</H2
+><P
+><B
+CLASS="COMMAND"
+>rarpd</B
+> was written by
+<A
+HREF="mailto:kuznet@ms2.inr.ac.ru"
+TARGET="_top"
+>Alexey Kuznetsov
+&lt;kuznet@ms2.inr.ac.ru&gt;</A
+>.
+It is now maintained by
+<A
+HREF="mailto:yoshfuji@skbuff.net"
+TARGET="_top"
+>YOSHIFUJI Hideaki
+&lt;yoshfuji@skbuff.net&gt;</A
+>.</P
+></DIV
+><DIV
+CLASS="REFSECT1"
+><A
+NAME="AEN823"
+></A
+><H2
+>SECURITY</H2
+><P
+><B
+CLASS="COMMAND"
+>rarpd</B
+> requires <CODE
+CLASS="CONSTANT"
+>CAP_NET_RAW</CODE
+> capability
+to listen and send RARP and ARP packets. It also needs <CODE
+CLASS="CONSTANT"
+>CAP_NET_ADMIN</CODE
+>
+to give to kernel hint for ARP resolution; this is not strictly required,
+but some (most of, to be more exact) clients are so badly broken that
+are not able to answer ARP before they are finally booted. This is
+not wonderful taking into account that clients using RARPD in 2002
+are all unsupported relic creatures of 90's and even earlier.</P
+></DIV
+><DIV
+CLASS="REFSECT1"
+><A
+NAME="AEN829"
+></A
+><H2
+>AVAILABILITY</H2
+><P
+><B
+CLASS="COMMAND"
+>rarpd</B
+> is part of <TT
+CLASS="FILENAME"
+>iputils</TT
+> package
+and the latest versions are  available in source form at
+<A
+HREF="http://www.skbuff.net/iputils/iputils-current.tar.bz2"
+TARGET="_top"
+>http://www.skbuff.net/iputils/iputils-current.tar.bz2</A
+>.</P
+></DIV
+><DIV
+CLASS="NAVFOOTER"
+><HR
+ALIGN="LEFT"
+WIDTH="100%"><TABLE
+SUMMARY="Footer navigation table"
+WIDTH="100%"
+BORDER="0"
+CELLPADDING="0"
+CELLSPACING="0"
+><TR
+><TD
+WIDTH="33%"
+ALIGN="left"
+VALIGN="top"
+><A
+HREF="r641.html"
+ACCESSKEY="P"
+>Prev</A
+></TD
+><TD
+WIDTH="34%"
+ALIGN="center"
+VALIGN="top"
+><A
+HREF="index.html"
+ACCESSKEY="H"
+>Home</A
+></TD
+><TD
+WIDTH="33%"
+ALIGN="right"
+VALIGN="top"
+><A
+HREF="r835.html"
+ACCESSKEY="N"
+>Next</A
+></TD
+></TR
+><TR
+><TD
+WIDTH="33%"
+ALIGN="left"
+VALIGN="top"
+>clockdiff</TD
+><TD
+WIDTH="34%"
+ALIGN="center"
+VALIGN="top"
+>&nbsp;</TD
+><TD
+WIDTH="33%"
+ALIGN="right"
+VALIGN="top"
+>tracepath</TD
+></TR
+></TABLE
+></DIV
+></BODY
+></HTML
+>
\ No newline at end of file
diff -Naur iputils-s20151218.orig/doc/r835.html iputils-s20151218/doc/r835.html
--- iputils-s20151218.orig/doc/r835.html	1970-01-01 00:00:00.000000000 +0000
+++ iputils-s20151218/doc/r835.html	2016-07-16 01:02:47.237155211 +0000
@@ -0,0 +1,457 @@
+<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN""http://www.w3.org/TR/html4/loose.dtd">
+<HTML
+><HEAD
+><TITLE
+>tracepath</TITLE
+><META
+NAME="GENERATOR"
+CONTENT="Modular DocBook HTML Stylesheet Version 1.79"><LINK
+REL="HOME"
+TITLE="System Manager's Manual: iputils"
+HREF="index.html"><LINK
+REL="PREVIOUS"
+TITLE="rarpd"
+HREF="r736.html"><LINK
+REL="NEXT"
+TITLE="traceroute6"
+HREF="r942.html"></HEAD
+><BODY
+CLASS="REFENTRY"
+BGCOLOR="#FFFFFF"
+TEXT="#000000"
+LINK="#0000FF"
+VLINK="#840084"
+ALINK="#0000FF"
+><DIV
+CLASS="NAVHEADER"
+><TABLE
+SUMMARY="Header navigation table"
+WIDTH="100%"
+BORDER="0"
+CELLPADDING="0"
+CELLSPACING="0"
+><TR
+><TH
+COLSPAN="3"
+ALIGN="center"
+>System Manager's Manual: iputils</TH
+></TR
+><TR
+><TD
+WIDTH="10%"
+ALIGN="left"
+VALIGN="bottom"
+><A
+HREF="r736.html"
+ACCESSKEY="P"
+>Prev</A
+></TD
+><TD
+WIDTH="80%"
+ALIGN="center"
+VALIGN="bottom"
+></TD
+><TD
+WIDTH="10%"
+ALIGN="right"
+VALIGN="bottom"
+><A
+HREF="r942.html"
+ACCESSKEY="N"
+>Next</A
+></TD
+></TR
+></TABLE
+><HR
+ALIGN="LEFT"
+WIDTH="100%"></DIV
+><H1
+><A
+NAME="TRACEPATH"
+></A
+>tracepath</H1
+><DIV
+CLASS="REFNAMEDIV"
+><A
+NAME="AEN840"
+></A
+><H2
+>Name</H2
+>tracepath, tracepath6&nbsp;--&nbsp;traces path to a network host discovering MTU along this path</DIV
+><DIV
+CLASS="REFSYNOPSISDIV"
+><A
+NAME="AEN843"
+></A
+><H2
+>Synopsis</H2
+><P
+><B
+CLASS="COMMAND"
+>tracepath</B
+>  [-n] [-b] [-l <TT
+CLASS="REPLACEABLE"
+><I
+>pktlen</I
+></TT
+>] [-m <TT
+CLASS="REPLACEABLE"
+><I
+>max_hops</I
+></TT
+>] [-p <TT
+CLASS="REPLACEABLE"
+><I
+>port</I
+></TT
+>] {<TT
+CLASS="REPLACEABLE"
+><I
+>destination</I
+></TT
+>}</P
+></DIV
+><DIV
+CLASS="REFSECT1"
+><A
+NAME="AEN856"
+></A
+><H2
+>DESCRIPTION</H2
+><P
+>It traces path to <TT
+CLASS="REPLACEABLE"
+><I
+>destination</I
+></TT
+> discovering MTU along this path.
+It uses UDP port <TT
+CLASS="REPLACEABLE"
+><I
+>port</I
+></TT
+> or some random port.
+It is similar to <B
+CLASS="COMMAND"
+>traceroute</B
+>, only does not require superuser
+privileges and has no fancy options.</P
+><P
+><B
+CLASS="COMMAND"
+>tracepath6</B
+> is good replacement for <B
+CLASS="COMMAND"
+>traceroute6</B
+>
+and classic example of application of Linux error queues.
+The situation with IPv4 is worse, because commercial
+IP routers do not return enough information in ICMP error messages.
+Probably, it will change, when they will be updated.
+For now it uses Van Jacobson's trick, sweeping a range
+of UDP ports to maintain trace history.</P
+></DIV
+><DIV
+CLASS="REFSECT1"
+><A
+NAME="AEN865"
+></A
+><H2
+>OPTIONS</H2
+><P
+></P
+><DIV
+CLASS="VARIABLELIST"
+><DL
+><DT
+><CODE
+CLASS="OPTION"
+>-n</CODE
+></DT
+><DD
+><P
+>Print primarily IP addresses numerically.
+  </P
+></DD
+><DT
+><CODE
+CLASS="OPTION"
+>-b</CODE
+></DT
+><DD
+><P
+>Print both of host names and IP addresses.
+  </P
+></DD
+><DT
+><CODE
+CLASS="OPTION"
+>-l</CODE
+></DT
+><DD
+><P
+>Sets the initial packet length to <TT
+CLASS="REPLACEABLE"
+><I
+>pktlen</I
+></TT
+> instead of
+65535 for <B
+CLASS="COMMAND"
+>tracepath</B
+> or 128000 for <B
+CLASS="COMMAND"
+>tracepath6</B
+>.
+  </P
+></DD
+><DT
+><CODE
+CLASS="OPTION"
+>-m</CODE
+></DT
+><DD
+><P
+>Set maximum hops (or maximum TTLs) to <TT
+CLASS="REPLACEABLE"
+><I
+>max_hops</I
+></TT
+>
+instead of 30.
+  </P
+></DD
+><DT
+><CODE
+CLASS="OPTION"
+>-p</CODE
+></DT
+><DD
+><P
+>Sets the initial destination port to use.
+  </P
+></DD
+></DL
+></DIV
+></DIV
+><DIV
+CLASS="REFSECT1"
+><A
+NAME="AEN897"
+></A
+><H2
+>OUTPUT</H2
+><P
+><P
+CLASS="LITERALLAYOUT"
+>root@mops:~&nbsp;#&nbsp;tracepath6&nbsp;3ffe:2400:0:109::2<br>
+&nbsp;1?:&nbsp;[LOCALHOST]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pmtu&nbsp;1500<br>
+&nbsp;1:&nbsp;&nbsp;dust.inr.ac.ru&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0.411ms<br>
+&nbsp;2:&nbsp;&nbsp;dust.inr.ac.ru&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;asymm&nbsp;&nbsp;1&nbsp;&nbsp;&nbsp;0.390ms&nbsp;pmtu&nbsp;1480<br>
+&nbsp;2:&nbsp;&nbsp;3ffe:2400:0:109::2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;463.514ms&nbsp;reached<br>
+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Resume:&nbsp;pmtu&nbsp;1480&nbsp;hops&nbsp;2&nbsp;back&nbsp;2</P
+></P
+><P
+>The first column shows <TT
+CLASS="LITERAL"
+>TTL</TT
+> of the probe, followed by colon.
+Usually value of <TT
+CLASS="LITERAL"
+>TTL</TT
+> is obtained from reply from network,
+but sometimes reply does not contain necessary information and
+we have to guess it. In this case the number is followed by ?.</P
+><P
+>The second column shows the network hop, which replied to the probe.
+It is either address of router or word <TT
+CLASS="LITERAL"
+>[LOCALHOST]</TT
+>, if
+the probe was not sent to the network.</P
+><P
+>The rest of line shows miscellaneous information about path to
+the correspinding network hop. As rule it contains value of RTT.
+Additionally, it can show Path MTU, when it changes.
+If the path is asymmetric
+or the probe finishes before it reach prescribed hop, difference
+between number of hops in forward and backward direction is shown
+following keyword <TT
+CLASS="LITERAL"
+>async</TT
+>. This information is not reliable.
+F.e. the third line shows asymmetry of 1, it is because the first probe
+with TTL of 2 was rejected at the first hop due to Path MTU Discovery.</P
+><P
+>The last line summarizes information about all the path to the destination,
+it shows detected Path MTU, amount of hops to the destination and our
+guess about amount of hops from the destination to us, which can be
+different when the path is asymmetric.</P
+></DIV
+><DIV
+CLASS="REFSECT1"
+><A
+NAME="AEN909"
+></A
+><H2
+>SEE ALSO</H2
+><P
+><SPAN
+CLASS="CITEREFENTRY"
+><SPAN
+CLASS="REFENTRYTITLE"
+>traceroute</SPAN
+>(8)</SPAN
+>,
+<A
+HREF="r942.html"
+><SPAN
+CLASS="CITEREFENTRY"
+><SPAN
+CLASS="REFENTRYTITLE"
+>traceroute6</SPAN
+>(8)</SPAN
+></A
+>,
+<A
+HREF="r3.html"
+><SPAN
+CLASS="CITEREFENTRY"
+><SPAN
+CLASS="REFENTRYTITLE"
+>ping</SPAN
+>(8)</SPAN
+></A
+>.</P
+></DIV
+><DIV
+CLASS="REFSECT1"
+><A
+NAME="AEN923"
+></A
+><H2
+>AUTHOR</H2
+><P
+><B
+CLASS="COMMAND"
+>tracepath</B
+> was written by
+<A
+HREF="mailto:kuznet@ms2.inr.ac.ru"
+TARGET="_top"
+>Alexey Kuznetsov
+&lt;kuznet@ms2.inr.ac.ru&gt;</A
+>.</P
+></DIV
+><DIV
+CLASS="REFSECT1"
+><A
+NAME="AEN928"
+></A
+><H2
+>SECURITY</H2
+><P
+>No security issues.</P
+><P
+>This lapidary deserves to be elaborated.
+<B
+CLASS="COMMAND"
+>tracepath</B
+> is not a privileged program, unlike
+<B
+CLASS="COMMAND"
+>traceroute</B
+>, <B
+CLASS="COMMAND"
+>ping</B
+> and other beasts of this kind.
+<B
+CLASS="COMMAND"
+>tracepath</B
+> may be executed by everyone who has some access
+to network, enough to send UDP datagrams to investigated destination
+using given port.</P
+></DIV
+><DIV
+CLASS="REFSECT1"
+><A
+NAME="AEN936"
+></A
+><H2
+>AVAILABILITY</H2
+><P
+><B
+CLASS="COMMAND"
+>tracepath</B
+> is part of <TT
+CLASS="FILENAME"
+>iputils</TT
+> package
+and the latest versions are  available in source form at
+<A
+HREF="http://www.skbuff.net/iputils/iputils-current.tar.bz2"
+TARGET="_top"
+>http://www.skbuff.net/iputils/iputils-current.tar.bz2</A
+>.</P
+></DIV
+><DIV
+CLASS="NAVFOOTER"
+><HR
+ALIGN="LEFT"
+WIDTH="100%"><TABLE
+SUMMARY="Footer navigation table"
+WIDTH="100%"
+BORDER="0"
+CELLPADDING="0"
+CELLSPACING="0"
+><TR
+><TD
+WIDTH="33%"
+ALIGN="left"
+VALIGN="top"
+><A
+HREF="r736.html"
+ACCESSKEY="P"
+>Prev</A
+></TD
+><TD
+WIDTH="34%"
+ALIGN="center"
+VALIGN="top"
+><A
+HREF="index.html"
+ACCESSKEY="H"
+>Home</A
+></TD
+><TD
+WIDTH="33%"
+ALIGN="right"
+VALIGN="top"
+><A
+HREF="r942.html"
+ACCESSKEY="N"
+>Next</A
+></TD
+></TR
+><TR
+><TD
+WIDTH="33%"
+ALIGN="left"
+VALIGN="top"
+>rarpd</TD
+><TD
+WIDTH="34%"
+ALIGN="center"
+VALIGN="top"
+>&nbsp;</TD
+><TD
+WIDTH="33%"
+ALIGN="right"
+VALIGN="top"
+>traceroute6</TD
+></TR
+></TABLE
+></DIV
+></BODY
+></HTML
+>
\ No newline at end of file
diff -Naur iputils-s20151218.orig/doc/r942.html iputils-s20151218/doc/r942.html
--- iputils-s20151218.orig/doc/r942.html	1970-01-01 00:00:00.000000000 +0000
+++ iputils-s20151218/doc/r942.html	2016-07-16 01:02:47.267154979 +0000
@@ -0,0 +1,315 @@
+<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN""http://www.w3.org/TR/html4/loose.dtd">
+<HTML
+><HEAD
+><TITLE
+>traceroute6</TITLE
+><META
+NAME="GENERATOR"
+CONTENT="Modular DocBook HTML Stylesheet Version 1.79"><LINK
+REL="HOME"
+TITLE="System Manager's Manual: iputils"
+HREF="index.html"><LINK
+REL="PREVIOUS"
+TITLE="tracepath"
+HREF="r835.html"><LINK
+REL="NEXT"
+TITLE="tftpd"
+HREF="r1007.html"></HEAD
+><BODY
+CLASS="REFENTRY"
+BGCOLOR="#FFFFFF"
+TEXT="#000000"
+LINK="#0000FF"
+VLINK="#840084"
+ALINK="#0000FF"
+><DIV
+CLASS="NAVHEADER"
+><TABLE
+SUMMARY="Header navigation table"
+WIDTH="100%"
+BORDER="0"
+CELLPADDING="0"
+CELLSPACING="0"
+><TR
+><TH
+COLSPAN="3"
+ALIGN="center"
+>System Manager's Manual: iputils</TH
+></TR
+><TR
+><TD
+WIDTH="10%"
+ALIGN="left"
+VALIGN="bottom"
+><A
+HREF="r835.html"
+ACCESSKEY="P"
+>Prev</A
+></TD
+><TD
+WIDTH="80%"
+ALIGN="center"
+VALIGN="bottom"
+></TD
+><TD
+WIDTH="10%"
+ALIGN="right"
+VALIGN="bottom"
+><A
+HREF="r1007.html"
+ACCESSKEY="N"
+>Next</A
+></TD
+></TR
+></TABLE
+><HR
+ALIGN="LEFT"
+WIDTH="100%"></DIV
+><H1
+><A
+NAME="TRACEROUTE6"
+></A
+>traceroute6</H1
+><DIV
+CLASS="REFNAMEDIV"
+><A
+NAME="AEN947"
+></A
+><H2
+>Name</H2
+>traceroute6&nbsp;--&nbsp;traces path to a network host</DIV
+><DIV
+CLASS="REFSYNOPSISDIV"
+><A
+NAME="AEN950"
+></A
+><H2
+>Synopsis</H2
+><P
+><B
+CLASS="COMMAND"
+>traceroute6</B
+>  [<CODE
+CLASS="OPTION"
+>-dnrvV</CODE
+>] [-i <TT
+CLASS="REPLACEABLE"
+><I
+>interface</I
+></TT
+>] [-m <TT
+CLASS="REPLACEABLE"
+><I
+>max_ttl</I
+></TT
+>] [-p <TT
+CLASS="REPLACEABLE"
+><I
+>port</I
+></TT
+>] [-q <TT
+CLASS="REPLACEABLE"
+><I
+>max_probes</I
+></TT
+>] [-s <TT
+CLASS="REPLACEABLE"
+><I
+>source</I
+></TT
+>] [-w <TT
+CLASS="REPLACEABLE"
+><I
+>wait time</I
+></TT
+>] {<TT
+CLASS="REPLACEABLE"
+><I
+>destination</I
+></TT
+>} [<TT
+CLASS="REPLACEABLE"
+><I
+>size</I
+></TT
+>]</P
+></DIV
+><DIV
+CLASS="REFSECT1"
+><A
+NAME="AEN971"
+></A
+><H2
+>DESCRIPTION</H2
+><P
+>Description can be found in 
+<SPAN
+CLASS="CITEREFENTRY"
+><SPAN
+CLASS="REFENTRYTITLE"
+>traceroute</SPAN
+>(8)</SPAN
+>,
+all the references to IP replaced to IPv6. It is needless to copy
+the description from there.</P
+></DIV
+><DIV
+CLASS="REFSECT1"
+><A
+NAME="AEN977"
+></A
+><H2
+>SEE ALSO</H2
+><P
+><SPAN
+CLASS="CITEREFENTRY"
+><SPAN
+CLASS="REFENTRYTITLE"
+>traceroute</SPAN
+>(8)</SPAN
+>,
+<SPAN
+CLASS="CITEREFENTRY"
+><SPAN
+CLASS="REFENTRYTITLE"
+>tracepath</SPAN
+>(8)</SPAN
+>,
+<SPAN
+CLASS="CITEREFENTRY"
+><SPAN
+CLASS="REFENTRYTITLE"
+>ping</SPAN
+>(8)</SPAN
+>.</P
+></DIV
+><DIV
+CLASS="REFSECT1"
+><A
+NAME="AEN989"
+></A
+><H2
+>HISTORY</H2
+><P
+>This program has long history. Author of <B
+CLASS="COMMAND"
+>traceroute</B
+>
+is Van Jacobson and it first appeared in 1988. This clone is
+based on a port of <B
+CLASS="COMMAND"
+>traceroute</B
+> to IPv6 published
+in NRL IPv6 distribution in 1996. In turn, it was ported
+to Linux by Pedro Roque. After this it was kept in sync by    
+<A
+HREF="mailto:kuznet@ms2.inr.ac.ru"
+TARGET="_top"
+>Alexey Kuznetsov
+&lt;kuznet@ms2.inr.ac.ru&gt;</A
+>. And eventually entered
+<B
+CLASS="COMMAND"
+>iputils</B
+> package.</P
+></DIV
+><DIV
+CLASS="REFSECT1"
+><A
+NAME="AEN996"
+></A
+><H2
+>SECURITY</H2
+><P
+><B
+CLASS="COMMAND"
+>tracepath6</B
+> requires <CODE
+CLASS="CONSTANT"
+>CAP_NET_RAW</CODE
+> capability
+to be executed. It is safe to be used as set-uid root.</P
+></DIV
+><DIV
+CLASS="REFSECT1"
+><A
+NAME="AEN1001"
+></A
+><H2
+>AVAILABILITY</H2
+><P
+><B
+CLASS="COMMAND"
+>traceroute6</B
+> is part of <TT
+CLASS="FILENAME"
+>iputils</TT
+> package
+and the latest versions are  available in source form at
+<A
+HREF="http://www.skbuff.net/iputils/iputils-current.tar.bz2"
+TARGET="_top"
+>http://www.skbuff.net/iputils/iputils-current.tar.bz2</A
+>.</P
+></DIV
+><DIV
+CLASS="NAVFOOTER"
+><HR
+ALIGN="LEFT"
+WIDTH="100%"><TABLE
+SUMMARY="Footer navigation table"
+WIDTH="100%"
+BORDER="0"
+CELLPADDING="0"
+CELLSPACING="0"
+><TR
+><TD
+WIDTH="33%"
+ALIGN="left"
+VALIGN="top"
+><A
+HREF="r835.html"
+ACCESSKEY="P"
+>Prev</A
+></TD
+><TD
+WIDTH="34%"
+ALIGN="center"
+VALIGN="top"
+><A
+HREF="index.html"
+ACCESSKEY="H"
+>Home</A
+></TD
+><TD
+WIDTH="33%"
+ALIGN="right"
+VALIGN="top"
+><A
+HREF="r1007.html"
+ACCESSKEY="N"
+>Next</A
+></TD
+></TR
+><TR
+><TD
+WIDTH="33%"
+ALIGN="left"
+VALIGN="top"
+>tracepath</TD
+><TD
+WIDTH="34%"
+ALIGN="center"
+VALIGN="top"
+>&nbsp;</TD
+><TD
+WIDTH="33%"
+ALIGN="right"
+VALIGN="top"
+>tftpd</TD
+></TR
+></TABLE
+></DIV
+></BODY
+></HTML
+>
\ No newline at end of file
diff -Naur iputils-s20151218.orig/doc/rarpd.8 iputils-s20151218/doc/rarpd.8
--- iputils-s20151218.orig/doc/rarpd.8	1970-01-01 00:00:00.000000000 +0000
+++ iputils-s20151218/doc/rarpd.8	2016-07-16 01:02:36.307239493 +0000
@@ -0,0 +1,84 @@
+.\" This manpage has been automatically generated by docbook2man 
+.\" from a DocBook document.  This tool can be found at:
+.\" <http://shell.ipoline.com/~elmert/comp/docbook2X/> 
+.\" Please send any bug reports, improvements, comments, patches, 
+.\" etc. to Steve Cheng <steve@ggi-project.org>.
+.TH "RARPD" "8" "" "iputils-160308" "System Manager's Manual: iputils"
+.SH NAME
+rarpd \- answer RARP REQUESTs
+.SH SYNOPSIS
+
+\fBarping\fR [\fB-aAvde\fR] [\fB-b \fIbootdir\fB\fR] [\fB\fIinterface\fB\fR]
+
+.SH "DESCRIPTION"
+.PP
+Listens
+RARP
+requests from clients. Provided MAC address of client
+is found in \fI/etc/ethers\fR database and
+obtained host name is resolvable to an IP address appropriate
+for attached network, \fBrarpd\fR answers to client with RARPD
+reply carrying an IP address.
+.PP
+To allow multiple boot servers on the network \fBrarpd\fR
+optionally checks for presence Sun-like bootable image in TFTP directory.
+It should have form \fBHexadecimal_IP.ARCH\fR, f.e. to load
+sparc 193.233.7.98 \fIC1E90762.SUN4M\fR is linked to
+an image appropriate for SUM4M in directory \fI/etc/tftpboot\fR.
+.SH "WARNING"
+.PP
+This facility is deeply obsoleted by
+BOOTP
+and later
+DHCP protocols.
+However, some clients really still need this to boot.
+.SH "OPTIONS"
+.TP
+\fB-a\fR
+Listen on all the interfaces. Currently it is an internal
+option, its function is overridden with \fIinterface\fR
+argument. It should not be used.
+.TP
+\fB-A\fR
+Listen not only RARP but also ARP messages, some rare clients
+use ARP by some unknown reason.
+.TP
+\fB-v\fR
+Be verbose.
+.TP
+\fB-d\fR
+Debug mode. Do not go to background.
+.TP
+\fB-e\fR
+Do not check for presence of a boot image, reply if MAC address
+resolves to a valid IP address using \fI/etc/ethers\fR
+database and DNS. 
+.TP
+\fB-b \fIbootdir\fB\fR
+TFTP boot directory. Default is \fI/etc/tftpboot\fR
+.SH "SEE ALSO"
+.PP
+\fBarping\fR(8),
+\fBtftpd\fR(8).
+.SH "AUTHOR"
+.PP
+\fBrarpd\fR was written by
+Alexey Kuznetsov
+<kuznet@ms2.inr.ac.ru>.
+It is now maintained by
+YOSHIFUJI Hideaki
+<yoshfuji@skbuff.net>.
+.SH "SECURITY"
+.PP
+\fBrarpd\fR requires CAP_NET_RAW capability
+to listen and send RARP and ARP packets. It also needs CAP_NET_ADMIN
+to give to kernel hint for ARP resolution; this is not strictly required,
+but some (most of, to be more exact) clients are so badly broken that
+are not able to answer ARP before they are finally booted. This is
+not wonderful taking into account that clients using RARPD in 2002
+are all unsupported relic creatures of 90's and even earlier.
+.SH "AVAILABILITY"
+.PP
+\fBrarpd\fR is part of \fIiputils\fR package
+and the latest versions are  available in source form at
+http://www.skbuff.net/iputils/iputils-current.tar.bz2.
diff -Naur iputils-s20151218.orig/doc/rdisc.8 iputils-s20151218/doc/rdisc.8
--- iputils-s20151218.orig/doc/rdisc.8	1970-01-01 00:00:00.000000000 +0000
+++ iputils-s20151218/doc/rdisc.8	2016-07-16 01:02:36.697236486 +0000
@@ -0,0 +1,122 @@
+.\" This manpage has been automatically generated by docbook2man 
+.\" from a DocBook document.  This tool can be found at:
+.\" <http://shell.ipoline.com/~elmert/comp/docbook2X/> 
+.\" Please send any bug reports, improvements, comments, patches, 
+.\" etc. to Steve Cheng <steve@ggi-project.org>.
+.TH "RDISC" "8" "" "iputils-160308" "System Manager's Manual: iputils"
+.SH NAME
+rdisc \- network router discovery daemon
+.SH SYNOPSIS
+
+\fBrdisc\fR [\fB-abdfrstvV\fR] [\fB-p \fIpreference\fB\fR] [\fB-T \fImax_interval\fB\fR] [\fB\fIsend_address\fB\fR] [\fB\fIreceive_address\fB\fR]
+
+.SH "DESCRIPTION"
+.PP
+\fBrdisc\fR implements client side of the ICMP router discover protocol.
+\fBrdisc\fR is invoked at boot time to populate the network
+routing tables with default routes. 
+.PP
+\fBrdisc\fR listens on the ALL_HOSTS (224.0.0.1) multicast address
+(or \fIreceive_address\fR provided it is given) 
+for ROUTER_ADVERTISE messages from routers. The received
+messages are handled by first ignoring those listed router addresses
+with which the host does not share a network. Among the remaining addresses
+the ones with the highest preference are selected as default routers
+and a default route is entered in the kernel routing table
+for each one of them.
+.PP
+Optionally, \fBrdisc\fR can avoid waiting for routers to announce 
+themselves by sending out a few ROUTER_SOLICITATION messages
+to the ALL_ROUTERS (224.0.0.2) multicast address 
+(or \fIsend_address\fR provided it is given) 
+when it is started.
+.PP
+A timer is associated with each router address and the address will
+no longer be considered for inclusion in the the routing tables if the 
+timer expires before a new 
+\fBadvertise\fR message is received from the router.
+The address will also be excluded from consideration if the host receives an 
+\fBadvertise\fR
+message with the preference being maximally negative.
+.PP
+Server side of router discovery protocol is supported by Cisco IOS
+and by any more or less complete UNIX routing daemon, f.e \fBgated\fR.
+Or, \fBrdisc\fR can act as responder, if compiled with -DRDISC_SERVER.
+.SH "OPTIONS"
+.TP
+\fB-a\fR
+Accept all routers independently of the preference they have in their 
+\fBadvertise\fR messages.
+Normally \fBrdisc\fR only accepts (and enters in the kernel routing
+tables) the router or routers with the highest preference.
+.TP
+\fB-b\fR
+Opposite to \fB-a\fR, i.e. install only router with the best
+preference value. It is default behaviour.
+.TP
+\fB-d\fR
+Send debugging messages to syslog.
+.TP
+\fB-f\fR
+Run \fBrdisc\fR forever even if no routers are found.
+Normally \fBrdisc\fR gives up if it has not received any 
+\fBadvertise\fR message after after soliciting three times,
+in which case it exits with a non-zero exit code.
+If \fB-f\fR is not specified in the first form then 
+\fB-s\fR must be specified.
+.TP
+\fB-r\fR
+Responder mode, available only if compiled with -DRDISC_SERVER.
+.TP
+\fB-s\fR
+Send three \fBsolicitation\fR messages initially to quickly discover
+the routers when the system is booted.
+When \fB-s\fR is specified \fBrdisc\fR
+exits with a non-zero exit code if it can not find any routers.
+This can be overridden with the \fB-f\fR option.
+.TP
+\fB-p \fIpreference\fB\fR
+Set preference in advertisement.
+Available only with -r option.
+.TP
+\fB-T \fImax_interval\fB\fR
+Set maximum advertisement interval in seconds.  Default is 600 secs.
+Available only with -r option.
+.TP
+\fB-t\fR
+Test mode. Do not go to background.
+.TP
+\fB-v\fR
+Be verbose i.e. send lots of debugging messages to syslog.
+.TP
+\fB-V\fR
+Print version and exit.
+.SH "HISTORY"
+.PP
+This program was developed by Sun Microsystems (see copyright
+notice in source file). It was ported to Linux by
+Alexey Kuznetsov
+<kuznet@ms2.inr.ac.ru>.
+It is now maintained by
+YOSHIFUJI Hideaki
+<yoshfuji@skbuff.net>.
+.SH "SEE ALSO"
+.PP
+\fBicmp\fR(7),
+\fBinet\fR(7),
+\fBping\fR(8).
+.SH "REFERENCES"
+.PP
+Deering, S.E.,ed "ICMP Router Discovery Messages",
+RFC1256, Network Information Center, SRI International,
+Menlo Park, Calif., September 1991.
+.SH "SECURITY"
+.PP
+\fBrdisc\fR requires CAP_NET_RAW to listen
+and send ICMP messages and capability CAP_NET_ADMIN
+to update routing tables. 
+.SH "AVAILABILITY"
+.PP
+\fBrdisc\fR is part of \fIiputils\fR package
+and the latest versions are  available in source form at
+http://www.skbuff.net/iputils/iputils-current.tar.bz2.
diff -Naur iputils-s20151218.orig/doc/snapshot.db iputils-s20151218/doc/snapshot.db
--- iputils-s20151218.orig/doc/snapshot.db	2015-12-17 15:45:51.000000000 +0000
+++ iputils-s20151218/doc/snapshot.db	2016-05-17 23:17:09.000000000 +0000
@@ -1 +1 @@
-151218
+160308
diff -Naur iputils-s20151218.orig/doc/tftpd.8 iputils-s20151218/doc/tftpd.8
--- iputils-s20151218.orig/doc/tftpd.8	1970-01-01 00:00:00.000000000 +0000
+++ iputils-s20151218/doc/tftpd.8	2016-07-16 01:02:36.997234173 +0000
@@ -0,0 +1,85 @@
+.\" This manpage has been automatically generated by docbook2man 
+.\" from a DocBook document.  This tool can be found at:
+.\" <http://shell.ipoline.com/~elmert/comp/docbook2X/> 
+.\" Please send any bug reports, improvements, comments, patches, 
+.\" etc. to Steve Cheng <steve@ggi-project.org>.
+.TH "TFTPD" "8" "" "iputils-160308" "System Manager's Manual: iputils"
+.SH NAME
+tftpd \- Trivial File Transfer Protocol server
+.SH SYNOPSIS
+
+\fBtftpd\fR \fB\fIdirectory\fB\fR
+
+.SH "DESCRIPTION"
+.PP
+\fBtftpd\fR is a server which supports the DARPA
+Trivial File Transfer Protocol
+(RFC1350).
+The TFTP server is started
+by \fBinetd\fR(8).
+.PP
+\fIdirectory\fR is required argument; if it is not given
+\fBtftpd\fR aborts. This path is prepended to any file name requested
+via TFTP protocol, effectively chrooting \fBtftpd\fR to this directory.
+File names are validated not to escape out of this directory, however
+administrator may configure such escape using symbolic links.
+.PP
+It is in difference of variants of \fBtftpd\fR usually distributed
+with unix-like systems, which take a list of directories and match
+file names to start from one of given prefixes or to some random
+default, when no arguments were given. There are two reasons not to
+behave in this way: first, it is inconvenient, clients are not expected
+to know something about layout of filesystem on server host.
+And second, TFTP protocol is not a tool for browsing of server's filesystem,
+it is just an agent allowing to boot dumb clients. 
+.PP
+In the case when \fBtftpd\fR is used together with
+\fBrarpd\fR(8),
+tftp directories in these services should coincide and it is expected
+that each client booted via TFTP has boot image corresponding
+its IP address with an architecture suffix following Sun Microsystems
+conventions. See 
+\fBrarpd\fR(8)
+for more details.
+.SH "SECURITY"
+.PP
+TFTP protocol does not provide any authentication.
+Due to this capital flaw \fBtftpd\fR is not able to restrict
+access to files and will allow only publically readable
+files to be accessed. Files may be written only if they already
+exist and are publically writable.
+.PP
+Impact is evident, directory exported via TFTP \fBmust not\fR
+contain sensitive information of any kind, everyone is allowed
+to read it as soon as a client is allowed. Boot images do not contain
+such information as rule, however you should think twice before
+publishing f.e. Cisco IOS config files via TFTP, they contain
+\fBunencrypted\fR passwords and may contain some information
+about the network, which you were not going to make public.
+.PP
+The \fBtftpd\fR server should be executed by \fBinetd\fR
+with dropped root privileges, namely with a user ID giving minimal
+access to files published in tftp directory. If it is executed
+as superuser occasionally, \fBtftpd\fR drops its UID and GID
+to 65534, which is most likely not the thing which you expect.
+However, this is not very essential; remember, only files accessible
+for everyone can be read or written via TFTP.
+.SH "SEE ALSO"
+.PP
+\fBrarpd\fR(8),
+\fBtftp\fR(1),
+\fBinetd\fR(8).
+.SH "HISTORY"
+.PP
+The \fBtftpd\fR command appeared in 4.2BSD. The source in iputils
+is cleaned up both syntactically (ANSIized) and semantically (UDP socket IO).
+.PP
+It is distributed with iputils mostly as good demo of an interesting feature
+(MSG_CONFIRM) allowing to boot long images by dumb clients
+not answering ARP requests until they are finally booted.
+However, this is full functional and can be used in production.
+.SH "AVAILABILITY"
+.PP
+\fBtftpd\fR is part of \fIiputils\fR package
+and the latest versions are  available in source form at
+http://www.skbuff.net/iputils/iputils-current.tar.bz2.
diff -Naur iputils-s20151218.orig/doc/tracepath.8 iputils-s20151218/doc/tracepath.8
--- iputils-s20151218.orig/doc/tracepath.8	1970-01-01 00:00:00.000000000 +0000
+++ iputils-s20151218/doc/tracepath.8	2016-07-16 01:02:37.097233402 +0000
@@ -0,0 +1,104 @@
+.\" This manpage has been automatically generated by docbook2man 
+.\" from a DocBook document.  This tool can be found at:
+.\" <http://shell.ipoline.com/~elmert/comp/docbook2X/> 
+.\" Please send any bug reports, improvements, comments, patches, 
+.\" etc. to Steve Cheng <steve@ggi-project.org>.
+.TH "TRACEPATH" "8" "" "iputils-160308" "System Manager's Manual: iputils"
+.SH NAME
+tracepath, tracepath6 \- traces path to a network host discovering MTU along this path
+.SH SYNOPSIS
+
+\fBtracepath\fR [\fB-n\fR] [\fB-b\fR] [\fB-l \fIpktlen\fB\fR] [\fB-m \fImax_hops\fB\fR] [\fB-p \fIport\fB\fR] \fB\fIdestination\fB\fR
+
+.SH "DESCRIPTION"
+.PP
+It traces path to \fIdestination\fR discovering MTU along this path.
+It uses UDP port \fIport\fR or some random port.
+It is similar to \fBtraceroute\fR, only does not require superuser
+privileges and has no fancy options.
+.PP
+\fBtracepath6\fR is good replacement for \fBtraceroute6\fR
+and classic example of application of Linux error queues.
+The situation with IPv4 is worse, because commercial
+IP routers do not return enough information in ICMP error messages.
+Probably, it will change, when they will be updated.
+For now it uses Van Jacobson's trick, sweeping a range
+of UDP ports to maintain trace history.
+.SH "OPTIONS"
+.TP
+\fB-n\fR
+Print primarily IP addresses numerically.
+.TP
+\fB-b\fR
+Print both of host names and IP addresses.
+.TP
+\fB-l\fR
+Sets the initial packet length to \fIpktlen\fR instead of
+65535 for \fBtracepath\fR or 128000 for \fBtracepath6\fR.
+.TP
+\fB-m\fR
+Set maximum hops (or maximum TTLs) to \fImax_hops\fR
+instead of 30.
+.TP
+\fB-p\fR
+Sets the initial destination port to use.
+.SH "OUTPUT"
+.PP
+
+.nf
+root@mops:~ # tracepath6 3ffe:2400:0:109::2
+ 1?: [LOCALHOST]                              pmtu 1500
+ 1:  dust.inr.ac.ru                   0.411ms
+ 2:  dust.inr.ac.ru        asymm  1   0.390ms pmtu 1480
+ 2:  3ffe:2400:0:109::2               463.514ms reached
+     Resume: pmtu 1480 hops 2 back 2
+.fi
+.PP
+The first column shows TTL of the probe, followed by colon.
+Usually value of TTL is obtained from reply from network,
+but sometimes reply does not contain necessary information and
+we have to guess it. In this case the number is followed by ?.
+.PP
+The second column shows the network hop, which replied to the probe.
+It is either address of router or word [LOCALHOST], if
+the probe was not sent to the network.
+.PP
+The rest of line shows miscellaneous information about path to
+the correspinding network hop. As rule it contains value of RTT.
+Additionally, it can show Path MTU, when it changes.
+If the path is asymmetric
+or the probe finishes before it reach prescribed hop, difference
+between number of hops in forward and backward direction is shown
+following keyword async. This information is not reliable.
+F.e. the third line shows asymmetry of 1, it is because the first probe
+with TTL of 2 was rejected at the first hop due to Path MTU Discovery.
+.PP
+The last line summarizes information about all the path to the destination,
+it shows detected Path MTU, amount of hops to the destination and our
+guess about amount of hops from the destination to us, which can be
+different when the path is asymmetric.
+.SH "SEE ALSO"
+.PP
+\fBtraceroute\fR(8),
+\fBtraceroute6\fR(8),
+\fBping\fR(8).
+.SH "AUTHOR"
+.PP
+\fBtracepath\fR was written by
+Alexey Kuznetsov
+<kuznet@ms2.inr.ac.ru>.
+.SH "SECURITY"
+.PP
+No security issues.
+.PP
+This lapidary deserves to be elaborated.
+\fBtracepath\fR is not a privileged program, unlike
+\fBtraceroute\fR, \fBping\fR and other beasts of this kind.
+\fBtracepath\fR may be executed by everyone who has some access
+to network, enough to send UDP datagrams to investigated destination
+using given port.
+.SH "AVAILABILITY"
+.PP
+\fBtracepath\fR is part of \fIiputils\fR package
+and the latest versions are  available in source form at
+http://www.skbuff.net/iputils/iputils-current.tar.bz2.
diff -Naur iputils-s20151218.orig/doc/tracepath.sgml iputils-s20151218/doc/tracepath.sgml
--- iputils-s20151218.orig/doc/tracepath.sgml	2015-12-17 15:45:51.000000000 +0000
+++ iputils-s20151218/doc/tracepath.sgml	2016-05-17 23:17:09.000000000 +0000
@@ -47,21 +47,21 @@
 <variablelist>
 
  <varlistentry>
-  <term><option/-n/</term>
+  <term><option>-n</option></term>
   <listitem><para>
 Print primarily IP addresses numerically.
   </para></listitem>
  </varlistentry>
 
  <varlistentry>
-  <term><option/-b/</term>
+  <term><option>-b</option></term>
   <listitem><para>
 Print both of host names and IP addresses.
   </para></listitem>
  </varlistentry>
 
  <varlistentry>
-  <term><option/-l/</term>
+  <term><option>-l</option></term>
   <listitem><para>
 Sets the initial packet length to <replaceable/pktlen/ instead of
 65535 for <command/tracepath/ or 128000 for <command/tracepath6/.
@@ -69,7 +69,7 @@
  </varlistentry>
 
  <varlistentry>
-  <term><option/-m/</term>
+  <term><option>-m</option></term>
   <listitem><para>
 Set maximum hops (or maximum TTLs) to <replaceable/max_hops/
 instead of 30.
@@ -77,7 +77,7 @@
  </varlistentry>
 
  <varlistentry>
-  <term><option/-p/</term>
+  <term><option>-p</option></term>
   <listitem><para>
 Sets the initial destination port to use.
   </para></listitem>
diff -Naur iputils-s20151218.orig/doc/traceroute6.8 iputils-s20151218/doc/traceroute6.8
--- iputils-s20151218.orig/doc/traceroute6.8	1970-01-01 00:00:00.000000000 +0000
+++ iputils-s20151218/doc/traceroute6.8	2016-07-16 01:02:36.947234559 +0000
@@ -0,0 +1,42 @@
+.\" This manpage has been automatically generated by docbook2man 
+.\" from a DocBook document.  This tool can be found at:
+.\" <http://shell.ipoline.com/~elmert/comp/docbook2X/> 
+.\" Please send any bug reports, improvements, comments, patches, 
+.\" etc. to Steve Cheng <steve@ggi-project.org>.
+.TH "TRACEROUTE6" "8" "" "iputils-160308" "System Manager's Manual: iputils"
+.SH NAME
+traceroute6 \- traces path to a network host
+.SH SYNOPSIS
+
+\fBtraceroute6\fR [\fB-dnrvV\fR] [\fB-i \fIinterface\fB\fR] [\fB-m \fImax_ttl\fB\fR] [\fB-p \fIport\fB\fR] [\fB-q \fImax_probes\fB\fR] [\fB-s \fIsource\fB\fR] [\fB-w \fIwait time\fB\fR] \fB\fIdestination\fB\fR [\fB\fIsize\fB\fR]
+
+.SH "DESCRIPTION"
+.PP
+Description can be found in 
+\fBtraceroute\fR(8),
+all the references to IP replaced to IPv6. It is needless to copy
+the description from there.
+.SH "SEE ALSO"
+.PP
+\fBtraceroute\fR(8),
+\fBtracepath\fR(8),
+\fBping\fR(8).
+.SH "HISTORY"
+.PP
+This program has long history. Author of \fBtraceroute\fR
+is Van Jacobson and it first appeared in 1988. This clone is
+based on a port of \fBtraceroute\fR to IPv6 published
+in NRL IPv6 distribution in 1996. In turn, it was ported
+to Linux by Pedro Roque. After this it was kept in sync by    
+Alexey Kuznetsov
+<kuznet@ms2.inr.ac.ru>. And eventually entered
+\fBiputils\fR package.
+.SH "SECURITY"
+.PP
+\fBtracepath6\fR requires CAP_NET_RAW capability
+to be executed. It is safe to be used as set-uid root.
+.SH "AVAILABILITY"
+.PP
+\fBtraceroute6\fR is part of \fIiputils\fR package
+and the latest versions are  available in source form at
+http://www.skbuff.net/iputils/iputils-current.tar.bz2.
diff -Naur iputils-s20151218.orig/doc/x109.html iputils-s20151218/doc/x109.html
--- iputils-s20151218.orig/doc/x109.html	1970-01-01 00:00:00.000000000 +0000
+++ iputils-s20151218/doc/x109.html	2016-07-16 01:02:47.007156984 +0000
@@ -0,0 +1,148 @@
+<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN""http://www.w3.org/TR/html4/loose.dtd">
+<HTML
+><HEAD
+><TITLE
+>Availability</TITLE
+><META
+NAME="GENERATOR"
+CONTENT="Modular DocBook HTML Stylesheet Version 1.79"><LINK
+REL="HOME"
+TITLE="iputils: documentation directory"
+HREF="index.html"><LINK
+REL="PREVIOUS"
+TITLE="Installation notes"
+HREF="x89.html"><LINK
+REL="NEXT"
+TITLE="Copying"
+HREF="x114.html"></HEAD
+><BODY
+CLASS="SECT1"
+BGCOLOR="#FFFFFF"
+TEXT="#000000"
+LINK="#0000FF"
+VLINK="#840084"
+ALINK="#0000FF"
+><DIV
+CLASS="NAVHEADER"
+><TABLE
+SUMMARY="Header navigation table"
+WIDTH="100%"
+BORDER="0"
+CELLPADDING="0"
+CELLSPACING="0"
+><TR
+><TH
+COLSPAN="3"
+ALIGN="center"
+>iputils: documentation directory</TH
+></TR
+><TR
+><TD
+WIDTH="10%"
+ALIGN="left"
+VALIGN="bottom"
+><A
+HREF="x89.html"
+ACCESSKEY="P"
+>Prev</A
+></TD
+><TD
+WIDTH="80%"
+ALIGN="center"
+VALIGN="bottom"
+></TD
+><TD
+WIDTH="10%"
+ALIGN="right"
+VALIGN="bottom"
+><A
+HREF="x114.html"
+ACCESSKEY="N"
+>Next</A
+></TD
+></TR
+></TABLE
+><HR
+ALIGN="LEFT"
+WIDTH="100%"></DIV
+><DIV
+CLASS="SECT1"
+><H1
+CLASS="SECT1"
+><A
+NAME="AEN109"
+>4. Availability</A
+></H1
+><P
+>The collection of documents is part of <TT
+CLASS="FILENAME"
+>iputils</TT
+> package
+and the latest versions are  available in source form at
+<A
+HREF="http://www.skbuff.net/iputils/iputils-current.tar.bz2"
+TARGET="_top"
+>http://www.skbuff.net/iputils/iputils-current.tar.bz2</A
+>.</P
+></DIV
+><DIV
+CLASS="NAVFOOTER"
+><HR
+ALIGN="LEFT"
+WIDTH="100%"><TABLE
+SUMMARY="Footer navigation table"
+WIDTH="100%"
+BORDER="0"
+CELLPADDING="0"
+CELLSPACING="0"
+><TR
+><TD
+WIDTH="33%"
+ALIGN="left"
+VALIGN="top"
+><A
+HREF="x89.html"
+ACCESSKEY="P"
+>Prev</A
+></TD
+><TD
+WIDTH="34%"
+ALIGN="center"
+VALIGN="top"
+><A
+HREF="index.html"
+ACCESSKEY="H"
+>Home</A
+></TD
+><TD
+WIDTH="33%"
+ALIGN="right"
+VALIGN="top"
+><A
+HREF="x114.html"
+ACCESSKEY="N"
+>Next</A
+></TD
+></TR
+><TR
+><TD
+WIDTH="33%"
+ALIGN="left"
+VALIGN="top"
+>Installation notes</TD
+><TD
+WIDTH="34%"
+ALIGN="center"
+VALIGN="top"
+>&nbsp;</TD
+><TD
+WIDTH="33%"
+ALIGN="right"
+VALIGN="top"
+>Copying</TD
+></TR
+></TABLE
+></DIV
+></BODY
+></HTML
+>
\ No newline at end of file
diff -Naur iputils-s20151218.orig/doc/x114.html iputils-s20151218/doc/x114.html
--- iputils-s20151218.orig/doc/x114.html	1970-01-01 00:00:00.000000000 +0000
+++ iputils-s20151218/doc/x114.html	2016-07-16 01:02:47.027156830 +0000
@@ -0,0 +1,130 @@
+<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN""http://www.w3.org/TR/html4/loose.dtd">
+<HTML
+><HEAD
+><TITLE
+>Copying</TITLE
+><META
+NAME="GENERATOR"
+CONTENT="Modular DocBook HTML Stylesheet Version 1.79"><LINK
+REL="HOME"
+TITLE="iputils: documentation directory"
+HREF="index.html"><LINK
+REL="PREVIOUS"
+TITLE="Availability"
+HREF="x109.html"></HEAD
+><BODY
+CLASS="SECT1"
+BGCOLOR="#FFFFFF"
+TEXT="#000000"
+LINK="#0000FF"
+VLINK="#840084"
+ALINK="#0000FF"
+><DIV
+CLASS="NAVHEADER"
+><TABLE
+SUMMARY="Header navigation table"
+WIDTH="100%"
+BORDER="0"
+CELLPADDING="0"
+CELLSPACING="0"
+><TR
+><TH
+COLSPAN="3"
+ALIGN="center"
+>iputils: documentation directory</TH
+></TR
+><TR
+><TD
+WIDTH="10%"
+ALIGN="left"
+VALIGN="bottom"
+><A
+HREF="x109.html"
+ACCESSKEY="P"
+>Prev</A
+></TD
+><TD
+WIDTH="80%"
+ALIGN="center"
+VALIGN="bottom"
+></TD
+><TD
+WIDTH="10%"
+ALIGN="right"
+VALIGN="bottom"
+>&nbsp;</TD
+></TR
+></TABLE
+><HR
+ALIGN="LEFT"
+WIDTH="100%"></DIV
+><DIV
+CLASS="SECT1"
+><H1
+CLASS="SECT1"
+><A
+NAME="AEN114"
+>5. Copying</A
+></H1
+><P
+>Different files are copyrighted by different persons and organizations
+and distributed under different licenses. For details look into corresponding
+source files.</P
+></DIV
+><DIV
+CLASS="NAVFOOTER"
+><HR
+ALIGN="LEFT"
+WIDTH="100%"><TABLE
+SUMMARY="Footer navigation table"
+WIDTH="100%"
+BORDER="0"
+CELLPADDING="0"
+CELLSPACING="0"
+><TR
+><TD
+WIDTH="33%"
+ALIGN="left"
+VALIGN="top"
+><A
+HREF="x109.html"
+ACCESSKEY="P"
+>Prev</A
+></TD
+><TD
+WIDTH="34%"
+ALIGN="center"
+VALIGN="top"
+><A
+HREF="index.html"
+ACCESSKEY="H"
+>Home</A
+></TD
+><TD
+WIDTH="33%"
+ALIGN="right"
+VALIGN="top"
+>&nbsp;</TD
+></TR
+><TR
+><TD
+WIDTH="33%"
+ALIGN="left"
+VALIGN="top"
+>Availability</TD
+><TD
+WIDTH="34%"
+ALIGN="center"
+VALIGN="top"
+>&nbsp;</TD
+><TD
+WIDTH="33%"
+ALIGN="right"
+VALIGN="top"
+>&nbsp;</TD
+></TR
+></TABLE
+></DIV
+></BODY
+></HTML
+>
\ No newline at end of file
diff -Naur iputils-s20151218.orig/doc/x34.html iputils-s20151218/doc/x34.html
--- iputils-s20151218.orig/doc/x34.html	1970-01-01 00:00:00.000000000 +0000
+++ iputils-s20151218/doc/x34.html	2016-07-16 01:02:46.937157524 +0000
@@ -0,0 +1,336 @@
+<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN""http://www.w3.org/TR/html4/loose.dtd">
+<HTML
+><HEAD
+><TITLE
+>Historical notes</TITLE
+><META
+NAME="GENERATOR"
+CONTENT="Modular DocBook HTML Stylesheet Version 1.79"><LINK
+REL="HOME"
+TITLE="iputils: documentation directory"
+HREF="index.html"><LINK
+REL="PREVIOUS"
+TITLE="iputils: documentation directory"
+HREF="index.html"><LINK
+REL="NEXT"
+TITLE="Installation notes"
+HREF="x89.html"></HEAD
+><BODY
+CLASS="SECT1"
+BGCOLOR="#FFFFFF"
+TEXT="#000000"
+LINK="#0000FF"
+VLINK="#840084"
+ALINK="#0000FF"
+><DIV
+CLASS="NAVHEADER"
+><TABLE
+SUMMARY="Header navigation table"
+WIDTH="100%"
+BORDER="0"
+CELLPADDING="0"
+CELLSPACING="0"
+><TR
+><TH
+COLSPAN="3"
+ALIGN="center"
+>iputils: documentation directory</TH
+></TR
+><TR
+><TD
+WIDTH="10%"
+ALIGN="left"
+VALIGN="bottom"
+><A
+HREF="index.html"
+ACCESSKEY="P"
+>Prev</A
+></TD
+><TD
+WIDTH="80%"
+ALIGN="center"
+VALIGN="bottom"
+></TD
+><TD
+WIDTH="10%"
+ALIGN="right"
+VALIGN="bottom"
+><A
+HREF="x89.html"
+ACCESSKEY="N"
+>Next</A
+></TD
+></TR
+></TABLE
+><HR
+ALIGN="LEFT"
+WIDTH="100%"></DIV
+><DIV
+CLASS="SECT1"
+><H1
+CLASS="SECT1"
+><A
+NAME="AEN34"
+>2. Historical notes</A
+></H1
+><P
+>This package appeared as a desperate attempt to bring some life
+to state of basic networking applets: <B
+CLASS="COMMAND"
+>ping</B
+>, <B
+CLASS="COMMAND"
+>traceroute</B
+>
+etc. Though it was known that port of BSD <B
+CLASS="COMMAND"
+>ping</B
+> to Linux
+was basically broken, neither maintainers of well known (and superb)
+Linux net-tools package nor maintainers of Linux distributions
+worried about fixing well known bugs, which were reported in linux-kernel
+and linux-net mail lists for ages, were identified and nevertheless
+not repaired. So, one day 1001th resuming of the subject happened
+to be the last straw to break camel's back, I just parsed my hard disks
+and collected a set of utilities, which shared the following properties:</P
+><P
+></P
+><UL
+><LI
+><P
+>Small
+ </P
+></LI
+><LI
+><P
+>Useful despite of this
+ </P
+></LI
+><LI
+><P
+>I never seen it was made right
+ </P
+></LI
+><LI
+><P
+>Not quite trivial
+ </P
+></LI
+><LI
+><P
+>Demonstrating some important feature of Linux 
+ </P
+></LI
+><LI
+><P
+>The last but not the least, I use it more or less regularly
+ </P
+></LI
+></UL
+><P
+>This utility set was not supposed to be a reference set or something like
+that. Most of them were cloned from some originals:
+<DIV
+CLASS="INFORMALTABLE"
+><P
+></P
+><A
+NAME="AEN54"
+></A
+><TABLE
+BORDER="1"
+CLASS="CALSTABLE"
+><COL><COL><TBODY
+><TR
+><TD
+>ping</TD
+><TD
+>cloned of an ancient NetTools-B-xx</TD
+></TR
+><TR
+><TD
+>ping6</TD
+><TD
+>cloned of a very old Pedro's utility set</TD
+></TR
+><TR
+><TD
+>traceroute6</TD
+><TD
+>cloned of NRL Sep 96 distribution</TD
+></TR
+><TR
+><TD
+>rdisc</TD
+><TD
+>cloned of SUN in.rdisc</TD
+></TR
+><TR
+><TD
+>clockdiff</TD
+><TD
+>broken out of some BSD timed</TD
+></TR
+><TR
+><TD
+>tftpd</TD
+><TD
+>it is clone of some ancient NetKit package</TD
+></TR
+></TBODY
+></TABLE
+><P
+></P
+></DIV
+></P
+><P
+>Also I added some utilities written from scratch, namely
+<B
+CLASS="COMMAND"
+>tracepath</B
+>, <B
+CLASS="COMMAND"
+>arping</B
+> and later <B
+CLASS="COMMAND"
+>rarpd</B
+>
+(the last one does not satisfy all the criteria, I used it two or three
+times).</P
+><P
+>Hesitated a bit I overcame temptation to add <B
+CLASS="COMMAND"
+>traceroute</B
+>.
+The variant released by LBNL to that time was mostly sane and bugs
+in it were mostly not specific to Linux, but main reason was that
+the latest version of LBNL <B
+CLASS="COMMAND"
+>traceroute</B
+> was not 
+<SPAN
+CLASS="emphasis"
+><I
+CLASS="EMPHASIS"
+>small</I
+></SPAN
+>, it consisted of several files,
+used a wicked (and failing with Linux :-)) autoconfiguration etc.
+So, instead I assembled to iputils a simplistic <B
+CLASS="COMMAND"
+>tracepath</B
+> utility
+and IPv6 version of traceroute, and published my 
+<A
+HREF="ftp://ftp.inr.ac.ru/ip-routing/lbl-tools"
+TARGET="_top"
+> patches</A
+>.
+to LBNL <B
+CLASS="COMMAND"
+>traceroute</B
+> separately.<A
+NAME="AEN86"
+HREF="#FTN.AEN86"
+><SPAN
+CLASS="footnote"
+>[1]</SPAN
+></A
+></P
+></DIV
+><H3
+CLASS="FOOTNOTES"
+>Notes</H3
+><TABLE
+BORDER="0"
+CLASS="FOOTNOTES"
+WIDTH="100%"
+><TR
+><TD
+ALIGN="LEFT"
+VALIGN="TOP"
+WIDTH="5%"
+><A
+NAME="FTN.AEN86"
+HREF="x34.html#AEN86"
+><SPAN
+CLASS="footnote"
+>[1]</SPAN
+></A
+></TD
+><TD
+ALIGN="LEFT"
+VALIGN="TOP"
+WIDTH="95%"
+><P
+>This was mistake.
+Due to this <B
+CLASS="COMMAND"
+>traceroute</B
+> was in a sad state until recently.
+Good news, redhat-7.2 seems to add these patches to their traceroute
+rpm eventually. So, I think I will refrain of suicide for awhile.</P
+></TD
+></TR
+></TABLE
+><DIV
+CLASS="NAVFOOTER"
+><HR
+ALIGN="LEFT"
+WIDTH="100%"><TABLE
+SUMMARY="Footer navigation table"
+WIDTH="100%"
+BORDER="0"
+CELLPADDING="0"
+CELLSPACING="0"
+><TR
+><TD
+WIDTH="33%"
+ALIGN="left"
+VALIGN="top"
+><A
+HREF="index.html"
+ACCESSKEY="P"
+>Prev</A
+></TD
+><TD
+WIDTH="34%"
+ALIGN="center"
+VALIGN="top"
+><A
+HREF="index.html"
+ACCESSKEY="H"
+>Home</A
+></TD
+><TD
+WIDTH="33%"
+ALIGN="right"
+VALIGN="top"
+><A
+HREF="x89.html"
+ACCESSKEY="N"
+>Next</A
+></TD
+></TR
+><TR
+><TD
+WIDTH="33%"
+ALIGN="left"
+VALIGN="top"
+>iputils: documentation directory</TD
+><TD
+WIDTH="34%"
+ALIGN="center"
+VALIGN="top"
+>&nbsp;</TD
+><TD
+WIDTH="33%"
+ALIGN="right"
+VALIGN="top"
+>Installation notes</TD
+></TR
+></TABLE
+></DIV
+></BODY
+></HTML
+>
\ No newline at end of file
diff -Naur iputils-s20151218.orig/doc/x89.html iputils-s20151218/doc/x89.html
--- iputils-s20151218.orig/doc/x89.html	1970-01-01 00:00:00.000000000 +0000
+++ iputils-s20151218/doc/x89.html	2016-07-16 01:02:46.977157216 +0000
@@ -0,0 +1,220 @@
+<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN""http://www.w3.org/TR/html4/loose.dtd">
+<HTML
+><HEAD
+><TITLE
+>Installation notes</TITLE
+><META
+NAME="GENERATOR"
+CONTENT="Modular DocBook HTML Stylesheet Version 1.79"><LINK
+REL="HOME"
+TITLE="iputils: documentation directory"
+HREF="index.html"><LINK
+REL="PREVIOUS"
+TITLE="Historical notes"
+HREF="x34.html"><LINK
+REL="NEXT"
+TITLE="Availability"
+HREF="x109.html"></HEAD
+><BODY
+CLASS="SECT1"
+BGCOLOR="#FFFFFF"
+TEXT="#000000"
+LINK="#0000FF"
+VLINK="#840084"
+ALINK="#0000FF"
+><DIV
+CLASS="NAVHEADER"
+><TABLE
+SUMMARY="Header navigation table"
+WIDTH="100%"
+BORDER="0"
+CELLPADDING="0"
+CELLSPACING="0"
+><TR
+><TH
+COLSPAN="3"
+ALIGN="center"
+>iputils: documentation directory</TH
+></TR
+><TR
+><TD
+WIDTH="10%"
+ALIGN="left"
+VALIGN="bottom"
+><A
+HREF="x34.html"
+ACCESSKEY="P"
+>Prev</A
+></TD
+><TD
+WIDTH="80%"
+ALIGN="center"
+VALIGN="bottom"
+></TD
+><TD
+WIDTH="10%"
+ALIGN="right"
+VALIGN="bottom"
+><A
+HREF="x109.html"
+ACCESSKEY="N"
+>Next</A
+></TD
+></TR
+></TABLE
+><HR
+ALIGN="LEFT"
+WIDTH="100%"></DIV
+><DIV
+CLASS="SECT1"
+><H1
+CLASS="SECT1"
+><A
+NAME="AEN89"
+>3. Installation notes</A
+></H1
+><P
+><KBD
+CLASS="USERINPUT"
+>make</KBD
+> to compile utilities. <KBD
+CLASS="USERINPUT"
+>make html</KBD
+> to prepare
+html documentation, <KBD
+CLASS="USERINPUT"
+>make man</KBD
+> if you prefer man pages.
+Nothing fancy, provided you have DocBook package installed.</P
+><P
+><KBD
+CLASS="USERINPUT"
+>make install</KBD
+> installs <SPAN
+CLASS="emphasis"
+><I
+CLASS="EMPHASIS"
+>only</I
+></SPAN
+> HTML documentation
+to <TT
+CLASS="FILENAME"
+>/usr/doc/iputils</TT
+>. It even does not try
+to install binaries and man pages. If you read historical
+notes above, the reason should be evident. Most of utilities
+intersect with utilities distributed in another packages, and
+making such target rewriting existing installation would be a crime
+from my side. The decision what variant of <B
+CLASS="COMMAND"
+>ping</B
+> is preferred,
+how to resolve the conflicts etc. is left to you or to person who
+assembled an rpm. I vote for variant from <B
+CLASS="COMMAND"
+>iputils</B
+> of course.</P
+><P
+>Anyway, select utilities which you like and install them to the places
+which you prefer together with their man pages.</P
+><P
+>It is possible that compilation will fail, if you use some
+funny Linux distribution mangling header files in some unexpected ways
+(expected ones are the ways of redhat of course :-)).
+I validate iputils against <A
+HREF="http://www.asplinux.ru"
+TARGET="_top"
+>asplinux</A
+>
+distribution, which is inevitably followed by validity with respect
+to <A
+HREF="http://www.redhat.com"
+TARGET="_top"
+>redhat</A
+>.
+If your distribution is one of widely known ones, suse or debian,
+it also will compile provided snapshot is elder than month or so and
+someone reported all the problems, if they took place at all.</P
+><P
+><SPAN
+CLASS="emphasis"
+><I
+CLASS="EMPHASIS"
+>Anyway, please, do not abuse me complaining about some compilation problems
+in any distribution different of asplinux or redhat.
+If you have a fix, please, send it to
+<A
+HREF="mailto:kuznet@ms2.inr.ac.ru"
+TARGET="_top"
+>me</A
+>,
+I will check that it does not break distributions mentioned above
+and apply it. But I am not going to undertake any investigations,
+bare reports are deemed to be routed to <TT
+CLASS="FILENAME"
+>/dev/null</TT
+>.</I
+></SPAN
+></P
+></DIV
+><DIV
+CLASS="NAVFOOTER"
+><HR
+ALIGN="LEFT"
+WIDTH="100%"><TABLE
+SUMMARY="Footer navigation table"
+WIDTH="100%"
+BORDER="0"
+CELLPADDING="0"
+CELLSPACING="0"
+><TR
+><TD
+WIDTH="33%"
+ALIGN="left"
+VALIGN="top"
+><A
+HREF="x34.html"
+ACCESSKEY="P"
+>Prev</A
+></TD
+><TD
+WIDTH="34%"
+ALIGN="center"
+VALIGN="top"
+><A
+HREF="index.html"
+ACCESSKEY="H"
+>Home</A
+></TD
+><TD
+WIDTH="33%"
+ALIGN="right"
+VALIGN="top"
+><A
+HREF="x109.html"
+ACCESSKEY="N"
+>Next</A
+></TD
+></TR
+><TR
+><TD
+WIDTH="33%"
+ALIGN="left"
+VALIGN="top"
+>Historical notes</TD
+><TD
+WIDTH="34%"
+ALIGN="center"
+VALIGN="top"
+>&nbsp;</TD
+><TD
+WIDTH="33%"
+ALIGN="right"
+VALIGN="top"
+>Availability</TD
+></TR
+></TABLE
+></DIV
+></BODY
+></HTML
+>
\ No newline at end of file
diff -Naur iputils-s20151218.orig/iputils_md5dig.h iputils-s20151218/iputils_md5dig.h
--- iputils-s20151218.orig/iputils_md5dig.h	2015-12-17 15:45:51.000000000 +0000
+++ iputils-s20151218/iputils_md5dig.h	2016-05-17 23:17:09.000000000 +0000
@@ -1,15 +1,17 @@
 #ifndef IPUTILS_MD5DIG_H
 #define IPUTILS_MD5DIG_H
 
-#ifdef USE_GCRYPT
+#if defined(USE_GCRYPT)
 # include <stdlib.h>
 # include <gcrypt.h>
 # define IPUTILS_MD5DIG_LEN	16
+#elif defined(USE_NETTLE)
+# include <nettle/md5.h>
 #else
 # include <openssl/md5.h>
 #endif
 
-#ifdef USE_GCRYPT
+#if defined(USE_GCRYPT)
 typedef struct {
 	gcry_md_hd_t dig;
 } iputils_md5dig_ctx;
@@ -18,12 +20,14 @@
 {
 	if (gcry_md_open(&ctx->dig, GCRY_MD_MD5, 0) != GPG_ERR_NO_ERROR)
 		abort();
+	return;
 }
 
 static void iputils_md5dig_update(iputils_md5dig_ctx *ctx,
-				  const void *buf, int len)
+			   void *buf, int len)
 {
 	gcry_md_write(ctx->dig, buf, len);
+	return;
 }
 
 static void iputils_md5dig_final(unsigned char *digest,
@@ -48,5 +52,34 @@
 # define MD5_Init		iputils_md5dig_init
 # define MD5_Update		iputils_md5dig_update
 # define MD5_Final		iputils_md5dig_final
+
+#elif defined(USE_NETTLE)
+typedef struct md5_ctx iputils_md5dig_ctx;
+
+static void iputils_md5dig_init(iputils_md5dig_ctx *ctx)
+{
+	md5_init(ctx);
+	return;
+}
+
+static void iputils_md5dig_update(iputils_md5dig_ctx *ctx,
+			   void *buf, int len)
+{
+	md5_update(ctx, len, buf);
+	return;
+}
+
+static void iputils_md5dig_final(unsigned char *digest,
+				 iputils_md5dig_ctx *ctx)
+{
+	md5_digest(ctx, MD5_DIGEST_SIZE, digest);
+}
+
+# define MD5_DIGEST_LENGTH	MD5_DIGEST_SIZE
+# define MD5_CTX		iputils_md5dig_ctx
+# define MD5_Init		iputils_md5dig_init
+# define MD5_Update		iputils_md5dig_update
+# define MD5_Final		iputils_md5dig_final
 #endif
+
 #endif
diff -Naur iputils-s20151218.orig/iputils.spec iputils-s20151218/iputils.spec
--- iputils-s20151218.orig/iputils.spec	2015-12-17 15:45:51.000000000 +0000
+++ iputils-s20151218/iputils.spec	2016-05-17 23:17:09.000000000 +0000
@@ -2,7 +2,7 @@
 # This spec file is for _testing_.
 #
 
-%define ssdate 20151218
+%define ssdate 20160308
 %define srcbase iputils%{!?current:-s%{ssdate}}
 
 Summary: The ping program for checking to see if network hosts are alive.
@@ -93,8 +93,6 @@
 %attr(644,root,root) %{_mandir}/man8/*
 
 %changelog
-* Thu Jun 19 2014 YOSHIFUJI Hideaki <hideaki.yoshifuji@miraclelinux.com>
-  Configure before build.
 * Fri Nov 30 2012 YOSHIFUJI Hideaki <yoshfuji@linux-ipv6.org>
   Partically sync with current Fedora's specfile.
 * Fri Feb 23 2001 Alexey Kuznetsov <kuznet@ms2.inr.ac.ru>
diff -Naur iputils-s20151218.orig/Makefile iputils-s20151218/Makefile
--- iputils-s20151218.orig/Makefile	2015-12-17 15:45:51.000000000 +0000
+++ iputils-s20151218/Makefile	2016-07-16 01:03:45.186708022 +0000
@@ -2,8 +2,6 @@
 # Configuration
 #
 
-# CC
-CC=gcc
 # Path to parent kernel include files directory
 LIBC_INCLUDE=/usr/include
 # Libraries
@@ -12,21 +10,24 @@
 LDFLAG_STATIC=-Wl,-Bstatic
 LDFLAG_DYNAMIC=-Wl,-Bdynamic
 LDFLAG_CAP=-lcap
-LDFLAG_GCRYPT=-lgcrypt
+LDFLAG_GCRYPT=-lgcrypt -lgpg-error
+LDFLAG_NETTLE=-lnettle
 LDFLAG_CRYPTO=-lcrypto
 LDFLAG_IDN=-lidn
 LDFLAG_RESOLV=-lresolv
 LDFLAG_SYSFS=-lsysfs
+LDFLAG_RT=-lrt
+LDFLAG_M=-lm
 
 #
 # Options
 #
 
 # Capability support (with libcap) [yes|static|no]
-USE_CAP=yes
+USE_CAP=no
 # sysfs support (with libsysfs - deprecated) [no|yes|static]
 USE_SYSFS=no
-# IDN support (experimental) [no|yes|static]
+# IDN support  [yes|no|static]
 USE_IDN=no
 
 # Do not use getifaddrs [no|yes|static]
@@ -34,10 +35,12 @@
 # arping default device (e.g. eth0) []
 ARPING_DEFAULT_DEVICE=
 
-# Libgcrypt (for MD5) for ping6 [yes|no|static]
-USE_GCRYPT=yes
-# Crypto library for ping6 [shared|static]
-USE_CRYPTO=shared
+# nettle library for ipv6 ping [yes|no|static]
+USE_NETTLE=no
+# libgcrypt library for ipv6 ping [no|yes|static]
+USE_GCRYPT=no
+# Crypto library for ping6 [shared|static|no]
+USE_CRYPTO=no
 # Resolv library for ping6 [yes|static]
 USE_RESOLV=yes
 # ping6 source routing (deprecated by RFC5095) [no|yes|RFC3542]
@@ -48,11 +51,10 @@
 
 # -------------------------------------
 # What a pity, all new gccs are buggy and -Werror does not work. Sigh.
-# CCOPT=-fno-strict-aliasing -Wstrict-prototypes -Wall -Werror -g
-CCOPT=-fno-strict-aliasing -Wstrict-prototypes -Wall -g
-CCOPTOPT=-O3
-GLIBCFIX=-D_GNU_SOURCE
-DEFINES=
+# CFLAGS+=-fno-strict-aliasing -Wstrict-prototypes -Wall -Werror -g
+CFLAGS?=-O3 -g
+CFLAGS+=-fno-strict-aliasing -Wstrict-prototypes -Wall
+CPPFLAGS+=-D_GNU_SOURCE
 LDLIB=
 
 FUNC_LIB = $(if $(filter static,$(1)),$(LDFLAG_STATIC) $(2) $(LDFLAG_DYNAMIC),$(2))
@@ -63,7 +65,15 @@
 	LIB_CRYPTO = $(call FUNC_LIB,$(USE_GCRYPT),$(LDFLAG_GCRYPT))
 	DEF_CRYPTO = -DUSE_GCRYPT
 else
+ifneq ($(USE_NETTLE),no)
+	LIB_CRYPTO = $(call FUNC_LIB,$(USE_NETTLE),$(LDFLAG_NETTLE))
+	DEF_CRYPTO = -DUSE_NETTLE
+else
+ifneq ($(USE_CRYPTO),no)
 	LIB_CRYPTO = $(call FUNC_LIB,$(USE_CRYPTO),$(LDFLAG_CRYPTO))
+	DEF_CRYPTO = -DUSE_OPENSSL
+endif
+endif
 endif
 
 # USE_RESOLV: LIB_RESOLV
@@ -106,18 +116,15 @@
 endif
 
 # -------------------------------------
-IPV4_TARGETS=tracepath ping clockdiff rdisc arping tftpd rarpd
-IPV6_TARGETS=tracepath6 traceroute6 ping6
-TARGETS=$(IPV4_TARGETS) $(IPV6_TARGETS)
+TARGETS=ping tracepath traceroute6 clockdiff rdisc arping tftpd rarpd
 
-CFLAGS=$(CCOPTOPT) $(CCOPT) $(GLIBCFIX) $(DEFINES)
 LDLIBS=$(LDLIB) $(ADDLIB)
 
 UNAME_N:=$(shell uname -n)
 LASTTAG:=$(shell git describe HEAD | sed -e 's/-.*//')
-TODAY=$(shell date +%Y/%m/%d)
-DATE=$(shell date --date $(TODAY) +%Y%m%d)
-TAG:=$(shell date --date=$(TODAY) +s%Y%m%d)
+TODAY=$(shell date +%Y-%m-%d)
+DATE=$(shell date -d $(TODAY) +%Y%m%d)
+TAG:=$(shell date -d $(TODAY) +s%Y%m%d)
 
 
 # -------------------------------------
@@ -129,13 +136,14 @@
 	$(COMPILE.c) $< $(DEF_$(patsubst %.o,%,$@)) -S -o $@
 %.o: %.c
 	$(COMPILE.c) $< $(DEF_$(patsubst %.o,%,$@)) -o $@
+LINK.o += $(CFLAGS)
 $(TARGETS): %: %.o
 	$(LINK.o) $^ $(LIB_$@) $(LDLIBS) -o $@
 
 # -------------------------------------
 # arping
 DEF_arping = $(DEF_SYSFS) $(DEF_CAP) $(DEF_IDN) $(DEF_WITHOUT_IFADDRS)
-LIB_arping = $(LIB_SYSFS) $(LIB_CAP) $(LIB_IDN)
+LIB_arping = $(LIB_SYSFS) $(LIB_CAP) $(LIB_IDN) $(LDFLAG_RT)
 
 ifneq ($(ARPING_DEFAULT_DEVICE),)
 DEF_arping += -DDEFAULT_DEVICE=\"$(ARPING_DEFAULT_DEVICE)\"
@@ -146,16 +154,14 @@
 LIB_clockdiff = $(LIB_CAP)
 
 # ping / ping6
-DEF_ping_common = $(DEF_CAP) $(DEF_IDN)
-DEF_ping  = $(DEF_CAP) $(DEF_IDN) $(DEF_WITHOUT_IFADDRS)
-LIB_ping  = $(LIB_CAP) $(LIB_IDN)
-DEF_ping6 = $(DEF_CAP) $(DEF_IDN) $(DEF_WITHOUT_IFADDRS) $(DEF_ENABLE_PING6_RTHDR) $(DEF_CRYPTO)
-LIB_ping6 = $(LIB_CAP) $(LIB_IDN) $(LIB_RESOLV) $(LIB_CRYPTO)
-
-ping: ping_common.o
-ping6: ping_common.o
-ping.o ping_common.o: ping_common.h
-ping6.o: ping_common.h in6_flowlabel.h
+DEF_ping = $(DEF_CAP) $(DEF_IDN) $(DEF_CRYPTO) $(DEF_WITHOUT_IFADDRS)
+DEF_ping_common = $(DEF_ping)
+DEF_ping6_common = $(DEF_ping)
+LIB_ping = $(LIB_CAP) $(LIB_IDN) $(LIB_CRYPTO) $(LIB_RESOLV) $(LDFLAG_M)
+
+ping: ping_common.o ping6_common.o
+ping.o ping_common.o ping6_common.o: ping.h in6_flowlabel.h
+ping6.o ping6_common.o: ping.h in6_flowlabel.h
 
 # rarpd
 DEF_rarpd =
@@ -169,10 +175,6 @@
 DEF_tracepath = $(DEF_IDN)
 LIB_tracepath = $(LIB_IDN)
 
-# tracepath6
-DEF_tracepath6 = $(DEF_IDN)
-LIB_tracepath6 =
-
 # traceroute6
 DEF_traceroute6 = $(DEF_CAP) $(DEF_IDN)
 LIB_traceroute6 = $(LIB_CAP) $(LIB_IDN)
@@ -236,7 +238,6 @@
 RPMBUILD=rpmbuild
 RPMTMP=.rpmtmp
 snapshot:
-	@if [ x"$(UNAME_N)" != x"pleiades" ]; then echo "Not authorized to advance snapshot"; exit 1; fi
 	@echo "[$(TAG)]" > RELNOTES.NEW
 	@echo >>RELNOTES.NEW
 	@git log --no-merges $(LASTTAG).. | git shortlog >> RELNOTES.NEW
@@ -245,7 +246,7 @@
 	@mv RELNOTES.NEW RELNOTES
 	@sed -e "s/^%define ssdate .*/%define ssdate $(DATE)/" iputils.spec > iputils.spec.tmp
 	@mv iputils.spec.tmp iputils.spec
-	@echo "static char SNAPSHOT[] = \"$(TAG)\";" > SNAPSHOT.h
+	@echo "#define SNAPSHOT \"$(TAG)\"" > SNAPSHOT.h
 	@$(MAKE) -C doc snapshot
 	@$(MAKE) man
 	@git commit -a -m "iputils-$(TAG)"
diff -Naur iputils-s20151218.orig/ninfod/ni_ifaddrs.c iputils-s20151218/ninfod/ni_ifaddrs.c
--- iputils-s20151218.orig/ninfod/ni_ifaddrs.c	2015-12-17 15:45:51.000000000 +0000
+++ iputils-s20151218/ninfod/ni_ifaddrs.c	2016-05-17 23:17:09.000000000 +0000
@@ -321,7 +321,6 @@
 
 	pid_t pid = getpid();
 	int seq = 0;
-	int result;
 	int build;		/* 0 or 1 */
 
 /* ---------------------------------- */
@@ -352,7 +351,6 @@
 		struct ni_ifaddrs *ifl = NULL, *ifa = NULL;
 		struct nlmsghdr *nlh, *nlh0;
 		void *data = NULL, *xdata = NULL;
-		uint16_t *ifflist = NULL;
 #ifndef IFA_LOCAL
 		struct rtmaddr_ifamap ifamap;
 #endif
@@ -364,18 +362,15 @@
 				*ifap = ifa;
 			else {
 				free_data(data);
-				result = 0;
 				break;
 			}
 			if (data == NULL) {
 				free_data(data);
-				result = -1;
 				break;
 			}
 			ifl = NULL;
 			data += NLMSG_ALIGN(sizeof(struct ni_ifaddrs)) * icnt;
 			xdata = data + dlen;
-			ifflist = xdata + xlen;
 		}
 
 		for (nlm = nlmsg_list; nlm; nlm = nlm->nlm_next) {
@@ -388,7 +383,7 @@
 
 				size_t nlm_struct_size = 0;
 				sa_family_t nlm_family = 0;
-				uint32_t nlm_scope = 0, nlm_index = 0;
+				uint32_t nlm_index = 0;
 				unsigned int nlm_flags;
 				size_t rtasize;
 
@@ -407,7 +402,6 @@
 					ifam = (struct ifaddrmsg *) NLMSG_DATA(nlh);
 					nlm_struct_size = sizeof(*ifam);
 					nlm_family = ifam->ifa_family;
-					nlm_scope = ifam->ifa_scope;
 					nlm_index = ifam->ifa_index;
 					nlm_flags = ifam->ifa_flags;
 					if (family && nlm_family != family)
diff -Naur iputils-s20151218.orig/ninfod/ninfod.c iputils-s20151218/ninfod/ninfod.c
--- iputils-s20151218.orig/ninfod/ninfod.c	2015-12-17 15:45:51.000000000 +0000
+++ iputils-s20151218/ninfod/ninfod.c	2016-05-17 23:17:09.000000000 +0000
@@ -427,10 +427,8 @@
 
 static void cleanup_pidfile(void)
 {
-	int err;
-
 	if (daemonized && opt_p) {
-		err = unlink(opt_p);
+		unlink(opt_p);
 		DEBUG(LOG_ERR, "failed to unlink file '%s' : %s\n",
 				opt_p, strerror(errno));
 	}
@@ -662,7 +660,6 @@
 int main (int argc, char **argv)
 {
 	int sock_errno = 0;
-	int ret;
 
 	appname = argv[0];
 	set_logfile();
@@ -705,7 +702,7 @@
 		struct icmp6_hdr *icmph;
 #if ENABLE_DEBUG
 		char saddrbuf[NI_MAXHOST];
-		int gni;
+		int status;
 #endif 
 
 		init_core(0);
@@ -734,12 +731,12 @@
 		}
 
 #if ENABLE_DEBUG
-		gni = getnameinfo((struct sockaddr *)&p->addr,
+		status = getnameinfo((struct sockaddr *)&p->addr,
 				  p->addrlen,
 				  saddrbuf, sizeof(saddrbuf),
 				  NULL, 0,
 				  NI_NUMERICHOST);
-		if (gni)
+		if (status)
 			sprintf(saddrbuf, "???");
 #endif
 		init_core(0);
diff -Naur iputils-s20151218.orig/ping6.c iputils-s20151218/ping6.c
--- iputils-s20151218.orig/ping6.c	2015-12-17 15:45:51.000000000 +0000
+++ iputils-s20151218/ping6.c	1970-01-01 00:00:00.000000000 +0000
@@ -1,1871 +0,0 @@
-/*
- *
- *	Modified for AF_INET6 by Pedro Roque
- *
- *	<roque@di.fc.ul.pt>
- *
- *	Original copyright notice included bellow
- */
-
-/*
- * Copyright (c) 1989 The Regents of the University of California.
- * All rights reserved.
- *
- * This code is derived from software contributed to Berkeley by
- * Mike Muuss.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. All advertising materials mentioning features or use of this software
- *    must display the following acknowledgement:
- *	This product includes software developed by the University of
- *	California, Berkeley and its contributors.
- * 4. Neither the name of the University nor the names of its contributors
- *    may be used to endorse or promote products derived from this software
- *    without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
- * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
- * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
- * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
- * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
- * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
- * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
- * SUCH DAMAGE.
- */
-
-#ifndef lint
-char copyright[] =
-"@(#) Copyright (c) 1989 The Regents of the University of California.\n\
- All rights reserved.\n";
-#endif /* not lint */
-
-/*
- *			P I N G . C
- *
- * Using the InterNet Control Message Protocol (ICMP) "ECHO" facility,
- * measure round-trip-delays and packet loss across network paths.
- *
- * Author -
- *	Mike Muuss
- *	U. S. Army Ballistic Research Laboratory
- *	December, 1983
- *
- * Status -
- *	Public Domain.  Distribution Unlimited.
- * Bugs -
- *	More statistics could always be gathered.
- *	If kernel does not support non-raw ICMP sockets or
- *	if -N option is used, this program has to run SUID to ROOT or
- *	with net_cap_raw enabled.
- */
-#include "ping_common.h"
-
-#include <linux/filter.h>
-#include <netinet/ip6.h>
-#include <netinet/icmp6.h>
-#include <resolv.h>
-#ifndef WITHOUT_IFADDRS
-#include <ifaddrs.h>
-#endif
-
-#ifdef USE_IDN
-#include <stringprep.h>
-#endif
-
-#include "ping6_niquery.h"
-#include "in6_flowlabel.h"
-
-#ifndef SOL_IPV6
-#define SOL_IPV6 IPPROTO_IPV6
-#endif
-
-#ifndef SOL_ICMPV6
-#define SOL_ICMPV6 IPPROTO_ICMPV6
-#endif
-
-/* RFC3542 */
-#ifndef ICMP6_DST_UNREACH_BEYONDSCOPE
-#define ICMP6_DST_UNREACH_BEYONDSCOPE ICMP6_DST_UNREACH_NOTNEIGHBOR
-#endif
-
-#if defined(ENABLE_PING6_RTHDR) && !defined(ENABLE_PING6_RTHDR_RFC3542)
-#ifndef IPV6_SRCRT_TYPE_0
-#define IPV6_SRCRT_TYPE_0	0
-#endif
-#endif
-
-#ifndef MLD_LISTENER_QUERY
-#define MLD_LISTENER_QUERY	130
-#define MLD_LISTENER_REPORT	131
-#define MLD_LISTENER_REDUCTION	132
-#endif
-
-#define BIT_CLEAR(nr, addr) do { ((__u32 *)(addr))[(nr) >> 5] &= ~(1U << ((nr) & 31)); } while(0)
-#define BIT_SET(nr, addr) do { ((__u32 *)(addr))[(nr) >> 5] |= (1U << ((nr) & 31)); } while(0)
-#define BIT_TEST(nr, addr) do { (__u32 *)(addr))[(nr) >> 5] & (1U << ((nr) & 31)); } while(0)
-
-#ifndef ICMP6_FILTER_WILLPASS
-#define ICMP6_FILTER_WILLPASS(type, filterp) \
-	(BIT_TEST((type), filterp) == 0)
-
-#define ICMP6_FILTER_WILLBLOCK(type, filterp) \
-	BIT_TEST((type), filterp)
-
-#define ICMP6_FILTER_SETPASS(type, filterp) \
-	BIT_CLEAR((type), filterp)
-
-#define ICMP6_FILTER_SETBLOCK(type, filterp) \
-	BIT_SET((type), filterp)
-
-#define ICMP6_FILTER_SETPASSALL(filterp) \
-	memset(filterp, 0, sizeof(struct icmp6_filter));
-
-#define ICMP6_FILTER_SETBLOCKALL(filterp) \
-	memset(filterp, 0xFF, sizeof(struct icmp6_filter));
-#endif
-
-#define	MAXPACKET	128000		/* max packet size */
-
-#ifdef SO_TIMESTAMP
-#define HAVE_SIN6_SCOPEID 1
-#endif
-
-#ifndef SCOPE_DELIMITER
-# define SCOPE_DELIMITER '%'
-#endif
-
-__u32 flowlabel;
-__u32 tclass;
-#ifdef ENABLE_PING6_RTHDR
-struct cmsghdr *srcrt;
-#endif
-
-struct sockaddr_in6 whereto;	/* who to ping */
-u_char outpack[MAXPACKET];
-int maxpacket = sizeof(outpack);
-
-static unsigned char cmsgbuf[4096];
-static int cmsglen = 0;
-
-static char * pr_addr(struct in6_addr *addr);
-static char * pr_addr_n(struct in6_addr *addr);
-static int pr_icmph(__u8 type, __u8 code, __u32 info);
-static void usage(void) __attribute((noreturn));
-
-struct sockaddr_in6 source;
-char *device;
-int pmtudisc=-1;
-
-static int icmp_sock;
-
-#include "iputils_md5dig.h"
-
-/* Node Information query */
-int ni_query = -1;
-int ni_flag = 0;
-void *ni_subject = NULL;
-int ni_subject_len = 0;
-int ni_subject_type = -1;
-char *ni_group;
-
-static inline int ntohsp(__u16 *p)
-{
-	__u16 v;
-	memcpy(&v, p, sizeof(v));
-	return ntohs(v);
-}
-
-#if defined(ENABLE_PING6_RTHDR) && !defined(ENABLE_PING6_RTHDR_RFC3542)
-size_t inet6_srcrt_space(int type, int segments)
-{
-	if (type != 0 || segments > 24)
-		return 0;
-
-	return (sizeof(struct cmsghdr) + sizeof(struct ip6_rthdr0) +
-		segments * sizeof(struct in6_addr));
-}
-
-extern struct cmsghdr *	inet6_srcrt_init(void *bp, int type)
-{
-	struct cmsghdr *cmsg;
-
-	if (type)
-		return NULL;
-
-	memset(bp, 0, sizeof(struct cmsghdr) + sizeof(struct ip6_rthdr0));
-	cmsg = (struct cmsghdr *) bp;
-
-	cmsg->cmsg_len = sizeof(struct cmsghdr) + sizeof(struct ip6_rthdr0);
-	cmsg->cmsg_level = SOL_IPV6;
-	cmsg->cmsg_type = IPV6_RTHDR;
-
-	return cmsg;
-}
-
-int inet6_srcrt_add(struct cmsghdr *cmsg, const struct in6_addr *addr)
-{
-	struct ip6_rthdr0 *hdr;
-
-	hdr = (struct ip6_rthdr0 *) CMSG_DATA(cmsg);
-
-	cmsg->cmsg_len += sizeof(struct in6_addr);
-	hdr->ip6r0_len += sizeof(struct in6_addr) / 8;
-
-	memcpy(&hdr->ip6r0_addr[hdr->ip6r0_segleft++], addr,
-	       sizeof(struct in6_addr));
-
-	return 0;
-}
-#endif
-
-unsigned int if_name2index(const char *ifname)
-{
-	unsigned int i = if_nametoindex(ifname);
-	if (!i) {
-		fprintf(stderr, "ping: unknown iface %s\n", ifname);
-		exit(2);
-	}
-	return i;
-}
-
-struct niquery_option {
-	char *name;
-	int namelen;
-	int has_arg;
-	int data;
-	int (*handler)(int index, const char *arg);
-};
-
-#define NIQUERY_OPTION(_name, _has_arg, _data, _handler)	\
-	{							\
-		.name = _name,					\
-		.namelen = sizeof(_name) - 1,			\
-		.has_arg = _has_arg,				\
-		.data = _data,					\
-		.handler = _handler				\
-	}
-
-static int niquery_option_name_handler(int index, const char *arg);
-static int niquery_option_ipv6_handler(int index, const char *arg);
-static int niquery_option_ipv6_flag_handler(int index, const char *arg);
-static int niquery_option_ipv4_handler(int index, const char *arg);
-static int niquery_option_ipv4_flag_handler(int index, const char *arg);
-static int niquery_option_subject_addr_handler(int index, const char *arg);
-static int niquery_option_subject_name_handler(int index, const char *arg);
-static int niquery_option_help_handler(int index, const char *arg);
-
-struct niquery_option niquery_options[] = {
-	NIQUERY_OPTION("name",			0,	0,				niquery_option_name_handler),
-	NIQUERY_OPTION("fqdn",			0,	0,				niquery_option_name_handler),
-	NIQUERY_OPTION("ipv6",			0,	0,				niquery_option_ipv6_handler),
-	NIQUERY_OPTION("ipv6-all",		0,	NI_IPV6ADDR_F_ALL,		niquery_option_ipv6_flag_handler),
-	NIQUERY_OPTION("ipv6-compatible",	0,	NI_IPV6ADDR_F_COMPAT,		niquery_option_ipv6_flag_handler),
-	NIQUERY_OPTION("ipv6-linklocal",	0,	NI_IPV6ADDR_F_LINKLOCAL,	niquery_option_ipv6_flag_handler),
-	NIQUERY_OPTION("ipv6-sitelocal",	0,	NI_IPV6ADDR_F_SITELOCAL,	niquery_option_ipv6_flag_handler),
-	NIQUERY_OPTION("ipv6-global",		0,	NI_IPV6ADDR_F_GLOBAL,		niquery_option_ipv6_flag_handler),
-	NIQUERY_OPTION("ipv4",			0,	0,				niquery_option_ipv4_handler),
-	NIQUERY_OPTION("ipv4-all",		0,	NI_IPV4ADDR_F_ALL,		niquery_option_ipv4_flag_handler),
-	NIQUERY_OPTION("subject-ipv6",		1,	NI_SUBJ_IPV6,			niquery_option_subject_addr_handler),
-	NIQUERY_OPTION("subject-ipv4",		1,	NI_SUBJ_IPV4,			niquery_option_subject_addr_handler),
-	NIQUERY_OPTION("subject-name",		1,	0,				niquery_option_subject_name_handler),
-	NIQUERY_OPTION("subject-fqdn",		1,	-1,				niquery_option_subject_name_handler),
-	NIQUERY_OPTION("help",			0,	0,				niquery_option_help_handler),
-	{},
-};
-
-static inline int niquery_is_enabled(void)
-{
-	return ni_query >= 0;
-}
-
-#if PING6_NONCE_MEMORY
-__u8 *ni_nonce_ptr;
-#else
-struct {
-	struct timeval tv;
-	pid_t pid;
-} ni_nonce_secret;
-#endif
-
-static void niquery_init_nonce(void)
-{
-#if PING6_NONCE_MEMORY
-	struct timeval tv;
-	unsigned long seed;
-
-	seed = (unsigned long)getpid();
-	if (!gettimeofday(&tv, NULL))
-		seed ^= tv.tv_usec;
-	srand(seed);
-
-	ni_nonce_ptr = calloc(NI_NONCE_SIZE, MAX_DUP_CHK);
-	if (!ni_nonce_ptr) {
-		perror("ping6: calloc");
-		exit(2);
-	}
-
-	ni_nonce_ptr[0] = ~0;
-#else
-	gettimeofday(&ni_nonce_secret.tv, NULL);
-	ni_nonce_secret.pid = getpid();
-#endif
-}
-
-#if !PING6_NONCE_MEMORY
-static int niquery_nonce(__u8 *nonce, int fill)
-{
-	static __u8 digest[MD5_DIGEST_LENGTH];
-	static int seq = -1;
-
-	if (fill || seq != *(__u16 *)nonce || seq < 0) {
-		MD5_CTX ctxt;
-
-		MD5_Init(&ctxt);
-		MD5_Update(&ctxt, &ni_nonce_secret, sizeof(ni_nonce_secret));
-		MD5_Update(&ctxt, nonce, sizeof(__u16));
-		MD5_Final(digest, &ctxt);
-
-		seq = *(__u16 *)nonce;
-	}
-
-	if (fill) {
-		memcpy(nonce + sizeof(__u16), digest, NI_NONCE_SIZE - sizeof(__u16));
-		return 0;
-	} else {
-		if (memcmp(nonce + sizeof(__u16), digest, NI_NONCE_SIZE - sizeof(__u16)))
-			return -1;
-		return ntohsp((__u16 *)nonce);
-	}
-}
-#endif
-
-static inline void niquery_fill_nonce(__u16 seq, __u8 *nonce)
-{
-	__u16 v = htons(seq);
-#if PING6_NONCE_MEMORY
-	int i;
-
-	memcpy(&ni_nonce_ptr[NI_NONCE_SIZE * (seq % MAX_DUP_CHK)], &v, sizeof(v));
-
-	for (i = sizeof(v); i < NI_NONCE_SIZE; i++)
-		ni_nonce_ptr[NI_NONCE_SIZE * (seq % MAX_DUP_CHK) + i] = 0x100 * (rand() / (RAND_MAX + 1.0));
-
-	memcpy(nonce, &ni_nonce_ptr[NI_NONCE_SIZE * (seq % MAX_DUP_CHK)], NI_NONCE_SIZE);
-#else
-	memcpy(nonce, &v, sizeof(v));
-	niquery_nonce(nonce, 1);
-#endif
-}
-
-static inline int niquery_check_nonce(__u8 *nonce)
-{
-#if PING6_NONCE_MEMORY
-	__u16 seq = ntohsp((__u16 *)nonce);
-	if (memcmp(nonce, &ni_nonce_ptr[NI_NONCE_SIZE * (seq % MAX_DUP_CHK)], NI_NONCE_SIZE))
-		return -1;
-	return seq;
-#else
-	return niquery_nonce(nonce, 0);
-#endif
-}
-
-static int niquery_set_qtype(int type)
-{
-	if (niquery_is_enabled() && ni_query != type) {
-		printf("Qtype conflict\n");
-		return -1;
-	}
-	ni_query = type;
-	return 0;
-}
-
-static int niquery_option_name_handler(int index, const char *arg)
-{
-	if (niquery_set_qtype(NI_QTYPE_NAME) < 0)
-		return -1;
-	return 0;
-}
-
-static int niquery_option_ipv6_handler(int index, const char *arg)
-{
-	if (niquery_set_qtype(NI_QTYPE_IPV6ADDR) < 0)
-		return -1;
-	return 0;
-}
-
-static int niquery_option_ipv6_flag_handler(int index, const char *arg)
-{
-	if (niquery_set_qtype(NI_QTYPE_IPV6ADDR) < 0)
-		return -1;
-	ni_flag |= niquery_options[index].data;
-	return 0;
-}
-
-static int niquery_option_ipv4_handler(int index, const char *arg)
-{
-	if (niquery_set_qtype(NI_QTYPE_IPV4ADDR) < 0)
-		return -1;
-	return 0;
-}
-
-static int niquery_option_ipv4_flag_handler(int index, const char *arg)
-{
-	if (niquery_set_qtype(NI_QTYPE_IPV4ADDR) < 0)
-		return -1;
-	ni_flag |= niquery_options[index].data;
-	return 0;
-}
-
-static inline int niquery_is_subject_valid(void)
-{
-	return ni_subject_type >= 0 && ni_subject;
-}
-
-static int niquery_set_subject_type(int type)
-{
-	if (niquery_is_subject_valid() && ni_subject_type != type) {
-		printf("Subject type conflict\n");
-		return -1;
-	}
-	ni_subject_type = type;
-	return 0;
-}
-
-#define ARRAY_SIZE(array)	(sizeof(array) / sizeof(array[0]))
-#define OFFSET_OF(type,elem)	((size_t)&((type *)0)->elem)
-
-static int niquery_option_subject_addr_handler(int index, const char *arg)
-{
-	struct addrinfo hints, *ai0, *ai;
-	int offset;
-	int gai;
-
-	if (niquery_set_subject_type(niquery_options[index].data) < 0)
-		return -1;
-
-	ni_subject_type = niquery_options[index].data;
-
-	memset(&hints, 0, sizeof(hints));
-
-	switch (niquery_options[index].data) {
-	case NI_SUBJ_IPV6:
-		ni_subject_len = sizeof(struct in6_addr);
-		offset = OFFSET_OF(struct sockaddr_in6, sin6_addr);
-		hints.ai_family = AF_INET6;
-		break;
-	case NI_SUBJ_IPV4:
-		ni_subject_len = sizeof(struct in_addr);
-		offset = OFFSET_OF(struct sockaddr_in, sin_addr);
-		hints.ai_family = AF_INET;
-		break;
-	default:
-		/* should not happen. */
-		offset = -1;
-	}
-
-	hints.ai_socktype = SOCK_DGRAM;
-#ifdef USE_IDN
-	hints.ai_flags = AI_IDN;
-#endif
-
-	gai = getaddrinfo(arg, 0, &hints, &ai0);
-	if (gai) {
-		fprintf(stderr, "Unknown host: %s\n", arg);
-		return -1;
-	}
-
-	for (ai = ai0; ai; ai = ai->ai_next) {
-		void *p = malloc(ni_subject_len);
-		if (!p)
-			continue;
-		memcpy(p, (__u8 *)ai->ai_addr + offset, ni_subject_len);
-		free(ni_subject);
-		ni_subject = p;
-		break;
-	}
-	freeaddrinfo(ai0);
-
-	return 0;
-}
-
-static int niquery_option_subject_name_handler(int index, const char *arg)
-{
-	static char nigroup_buf[INET6_ADDRSTRLEN + 1 + IFNAMSIZ];
-	unsigned char *dnptrs[2], **dpp, **lastdnptr;
-	int n;
-	int i;
-	char *name, *p;
-	char *canonname = NULL, *idn = NULL;
-	unsigned char *buf = NULL;
-	size_t namelen;
-	size_t buflen;
-	int dots, fqdn = niquery_options[index].data;
-	MD5_CTX ctxt;
-	__u8 digest[MD5_DIGEST_LENGTH];
-#ifdef USE_IDN
-	int rc;
-#endif
-
-	if (niquery_set_subject_type(NI_SUBJ_NAME) < 0)
-		return -1;
-
-#ifdef USE_IDN
-	name = stringprep_locale_to_utf8(arg);
-	if (!name) {
-		fprintf(stderr, "ping6: IDN support failed.\n");
-		exit(2);
-	}
-#else
-	name = strdup(arg);
-	if (!name)
-		goto oomexit;
-#endif
-
-	p = strchr(name, SCOPE_DELIMITER);
-	if (p) {
-		*p = '\0';
-		if (strlen(p + 1) >= IFNAMSIZ) {
-			fprintf(stderr, "ping6: too long scope name.\n");
-			exit(1);
-		}
-	}
-
-#ifdef USE_IDN
-	rc = idna_to_ascii_8z(name, &idn, 0);
-	if (rc) {
-		fprintf(stderr, "ping6: IDN encoding error: %s\n",
-			idna_strerror(rc));
-		exit(2);
-	}
-#else
-	idn = strdup(name);
-	if (!idn)
-		goto oomexit;
-#endif
-
-	namelen = strlen(idn);
-	canonname = malloc(namelen + 1);
-	if (!canonname)
-		goto oomexit;
-
-	dots = 0;
-	for (i = 0; i < namelen + 1; i++) {
-		canonname[i] = isupper(idn[i]) ? tolower(idn[i]) : idn[i];
-		if (idn[i] == '.')
-			dots++;
-	}
-
-	if (fqdn == 0) {
-		/* guess if hostname is FQDN */
-		fqdn = dots ? 1 : -1;
-	}
-
-	buflen = namelen + 3 + 1;	/* dn_comp() requrires strlen() + 3,
-					   plus non-fqdn indicator. */
-	buf = malloc(buflen);
-	if (!buf) {
-		fprintf(stderr, "ping6: out of memory.\n");
-		goto errexit;
-	}
-
-	dpp = dnptrs;
-	lastdnptr = &dnptrs[ARRAY_SIZE(dnptrs)];
-
-	*dpp++ = (unsigned char *)buf;
-	*dpp++ = NULL;
-
-	n = dn_comp(canonname, (unsigned char *)buf, buflen, dnptrs, lastdnptr);
-	if (n < 0) {
-		fprintf(stderr, "ping6: Inappropriate subject name: %s\n", canonname);
-		goto errexit;
-	} else if (n >= buflen) {
-		fprintf(stderr, "ping6: dn_comp() returned too long result.\n");
-		goto errexit;
-	}
-
-	MD5_Init(&ctxt);
-	MD5_Update(&ctxt, buf, buf[0]);
-	MD5_Final(digest, &ctxt);
-
-	sprintf(nigroup_buf, "ff02::2:%02x%02x:%02x%02x%s%s",
-		digest[0], digest[1], digest[2], digest[3],
-		p ? "%" : "",
-		p ? p + 1 : "");
-
-	if (fqdn < 0)
-		buf[n] = 0;
-
-	free(ni_subject);
-
-	ni_group = nigroup_buf;
-	ni_subject = buf;
-	ni_subject_len = n + (fqdn < 0);
-	ni_group = nigroup_buf;
-
-	free(canonname);
-	free(idn);
-	free(name);
-
-	return 0;
-oomexit:
-	fprintf(stderr, "ping6: out of memory.\n");
-errexit:
-	free(buf);
-	free(canonname);
-	free(idn);
-	free(name);
-	exit(1);
-}
-
-int niquery_option_help_handler(int index, const char *arg)
-{
-	fprintf(stderr, "ping6 -N suboptions\n"
-			"\tHelp:\n"
-			"\t\thelp\n"
-			"\tQuery:\n"
-			"\t\tname,\n"
-			"\t\tipv6,ipv6-all,ipv6-compatible,ipv6-linklocal,ipv6-sitelocal,ipv6-global,\n"
-			"\t\tipv4,ipv4-all,\n"
-			"\tSubject:\n"
-			"\t\tsubject-ipv6=addr,subject-ipv4=addr,subject-name=name,subject-fqdn=name,\n"
-		);
-	exit(2);
-}
-
-int niquery_option_handler(const char *opt_arg)
-{
-	struct niquery_option *p;
-	int i;
-	int ret = -1;
-	for (i = 0, p = niquery_options; p->name; i++, p++) {
-		if (strncmp(p->name, opt_arg, p->namelen))
-			continue;
-		if (!p->has_arg) {
-			if (opt_arg[p->namelen] == '\0') {
-				ret = p->handler(i, NULL);
-				if (ret >= 0)
-					break;
-			}
-		} else {
-			if (opt_arg[p->namelen] == '=') {
-				ret = p->handler(i, &opt_arg[p->namelen] + 1);
-				if (ret >= 0)
-					break;
-			}
-		}
-	}
-	if (!p->name)
-		ret = niquery_option_help_handler(0, NULL);
-	return ret;
-}
-
-static int hextoui(const char *str)
-{
-	unsigned long val;
-	char *ep;
-
-	errno = 0;
-	val = strtoul(str, &ep, 16);
-	if (*ep) {
-		if (!errno)
-			errno = EINVAL;
-		return -1;
-	}
-
-	if (val > UINT_MAX) {
-		errno = ERANGE;
-		return UINT_MAX;
-	}
-
-	return val;
-}
-
-int main(int argc, char *argv[])
-{
-	int ch, hold, packlen;
-	u_char *packet;
-	char *target;
-	struct addrinfo hints, *ai;
-	int gai;
-	struct sockaddr_in6 firsthop;
-	int socket_errno;
-	struct icmp6_filter filter;
-	int err;
-#ifdef __linux__
-	int csum_offset, sz_opt;
-#endif
-	static uint32_t scope_id = 0;
-
-	limit_capabilities();
-
-#ifdef USE_IDN
-	setlocale(LC_ALL, "");
-#endif
-
-	enable_capability_raw();
-	icmp_sock = socket(AF_INET6, SOCK_RAW, IPPROTO_ICMPV6);
-	disable_capability_raw();
-
-	if (icmp_sock < 0) {
-		icmp_sock = socket(AF_INET6, SOCK_DGRAM, IPPROTO_ICMPV6);
-		using_ping_socket = 1;
-	}
-
-	socket_errno = errno;
-
-
-	source.sin6_family = AF_INET6;
-	memset(&firsthop, 0, sizeof(firsthop));
-	firsthop.sin6_family = AF_INET6;
-
-	preload = 1;
-	while ((ch = getopt(argc, argv, COMMON_OPTSTR "F:N:")) != EOF) {
-		switch(ch) {
-		case 'F':
-			flowlabel = hextoui(optarg);
-			if (errno || (flowlabel & ~IPV6_FLOWINFO_FLOWLABEL)) {
-				fprintf(stderr, "ping: Invalid flowinfo %s\n", optarg);
-				exit(2);
-			}
-			options |= F_FLOWINFO;
-			break;
-		case 'Q':
-			tclass = hextoui(optarg);
-			if (errno || (tclass & ~0xff)) {
-				fprintf(stderr, "ping: Invalid tclass %s\n", optarg);
-				exit(2);
-			}
-			options |= F_TCLASS;
-			break;
-		case 'I':
-			if (strchr(optarg, ':')) {
-				char *p, *addr = strdup(optarg);
-
-				if (!addr) {
-					fprintf(stderr, "ping: out of memory\n");
-					exit(2);
-				}
-
-				p = strchr(addr, SCOPE_DELIMITER);
-				if (p) {
-					*p = '\0';
-					device = optarg + (p - addr) + 1;
-				}
-
-				if (inet_pton(AF_INET6, addr, (char*)&source.sin6_addr) <= 0) {
-					fprintf(stderr, "ping: invalid source address %s\n", optarg);
-					exit(2);
-				}
-
-				options |= F_STRICTSOURCE;
-
-				free(addr);
-			} else {
-				device = optarg;
-			}
-			break;
-		case 'M':
-			if (strcmp(optarg, "do") == 0)
-				pmtudisc = IPV6_PMTUDISC_DO;
-			else if (strcmp(optarg, "dont") == 0)
-				pmtudisc = IPV6_PMTUDISC_DONT;
-			else if (strcmp(optarg, "want") == 0)
-				pmtudisc = IPV6_PMTUDISC_WANT;
-			else {
-				fprintf(stderr, "ping: wrong value for -M: do, dont, want are valid ones.\n");
-				exit(2);
-			}
-			break;
-		case 'V':
-			printf("ping6 utility, iputils-%s\n", SNAPSHOT);
-			exit(0);
-		case 'N':
-			if (using_ping_socket) {
-				fprintf(stderr, "ping: -N requires raw socket permissions\n");
-				exit(2);
-			}
-			if (niquery_option_handler(optarg) < 0) {
-				usage();
-				break;
-			}
-			break;
-		COMMON_OPTIONS
-			common_options(ch);
-			break;
-		default:
-			usage();
-		}
-	}
-	argc -= optind;
-	argv += optind;
-
-#ifdef ENABLE_PING6_RTHDR
-	while (argc > 1) {
-		struct in6_addr *addr;
-
-		if (srcrt == NULL) {
-			int space;
-
-			fprintf(stderr, "ping6: Warning: "
-					"Source routing is deprecated by RFC5095.\n");
-
-#ifdef ENABLE_PING6_RTHDR_RFC3542
-			space = inet6_rth_space(IPV6_RTHDR_TYPE_0, argc - 1);
-#else
-			space = inet6_srcrt_space(IPV6_SRCRT_TYPE_0, argc - 1);
-#endif
-			if (space == 0)	{
-				fprintf(stderr, "srcrt_space failed\n");
-				exit(2);
-			}
-#ifdef ENABLE_PING6_RTHDR_RFC3542
-			if (cmsglen + CMSG_SPACE(space) > sizeof(cmsgbuf)) {
-				fprintf(stderr, "no room for options\n");
-				exit(2);
-			}
-#else
-			if (space + cmsglen > sizeof(cmsgbuf)) {
-				fprintf(stderr, "no room for options\n");
-				exit(2);
-			}
-#endif
-			srcrt = (struct cmsghdr*)(cmsgbuf+cmsglen);
-#ifdef ENABLE_PING6_RTHDR_RFC3542
-			memset(srcrt, 0, CMSG_SPACE(0));
-			srcrt->cmsg_len = CMSG_LEN(space);
-			srcrt->cmsg_level = IPPROTO_IPV6;
-			srcrt->cmsg_type = IPV6_RTHDR;
-			inet6_rth_init(CMSG_DATA(srcrt), space, IPV6_RTHDR_TYPE_0, argc - 1);
-			cmsglen += CMSG_SPACE(space);
-#else
-			cmsglen += CMSG_ALIGN(space);
-			inet6_srcrt_init(srcrt, IPV6_SRCRT_TYPE_0);
-#endif
-		}
-
-		target = *argv;
-
-		memset(&hints, 0, sizeof(hints));
-		hints.ai_family = AF_INET6;
-#ifdef USE_IDN
-		hints.ai_flags = AI_IDN;
-#endif
-		gai = getaddrinfo(target, NULL, &hints, &ai);
-		if (gai) {
-			fprintf(stderr, "unknown host\n");
-			exit(2);
-		}
-		addr = &((struct sockaddr_in6 *)(ai->ai_addr))->sin6_addr;
-#ifdef ENABLE_PING6_RTHDR_RFC3542
-		inet6_rth_add(CMSG_DATA(srcrt), addr);
-#else
-		inet6_srcrt_add(srcrt, addr);
-#endif
-		if (IN6_IS_ADDR_UNSPECIFIED(&firsthop.sin6_addr)) {
-			memcpy(&firsthop.sin6_addr, addr, 16);
-#ifdef HAVE_SIN6_SCOPEID
-			firsthop.sin6_scope_id = ((struct sockaddr_in6 *)(ai->ai_addr))->sin6_scope_id;
-			/* Verify scope_id is the same as previous nodes */
-			if (firsthop.sin6_scope_id && scope_id && firsthop.sin6_scope_id != scope_id) {
-				fprintf(stderr, "scope discrepancy among the nodes\n");
-				exit(2);
-			} else if (!scope_id) {
-				scope_id = firsthop.sin6_scope_id;
-			}
-#endif
-		}
-		freeaddrinfo(ai);
-
-		argv++;
-		argc--;
-	}
-#endif
-
-	if (niquery_is_enabled()) {
-		niquery_init_nonce();
-
-		if (!niquery_is_subject_valid()) {
-			ni_subject = &whereto.sin6_addr;
-			ni_subject_len = sizeof(whereto.sin6_addr);
-			ni_subject_type = NI_SUBJ_IPV6;
-		}
-	}
-
-	if (argc > 1) {
-#ifndef ENABLE_PING6_RTHDR
-		fprintf(stderr, "ping6: Source routing is deprecated by RFC5095.\n");
-#endif
-		usage();
-	} else if (argc == 1) {
-		target = *argv;
-	} else {
-		if (ni_query < 0 && ni_subject_type != NI_SUBJ_NAME)
-			usage();
-		target = ni_group;
-	}
-
-	memset(&hints, 0, sizeof(hints));
-	hints.ai_family = AF_INET6;
-#ifdef USE_IDN
-	hints.ai_flags = AI_IDN;
-#endif
-	gai = getaddrinfo(target, NULL, &hints, &ai);
-	if (gai) {
-		fprintf(stderr, "unknown host\n");
-		exit(2);
-	}
-
-	memcpy(&whereto, ai->ai_addr, sizeof(whereto));
-	whereto.sin6_port = htons(IPPROTO_ICMPV6);
-
-	if (memchr(target, ':', strlen(target)))
-		options |= F_NUMERIC;
-
-	freeaddrinfo(ai);
-
-	if (IN6_IS_ADDR_UNSPECIFIED(&firsthop.sin6_addr)) {
-		memcpy(&firsthop.sin6_addr, &whereto.sin6_addr, 16);
-#ifdef HAVE_SIN6_SCOPEID
-		firsthop.sin6_scope_id = whereto.sin6_scope_id;
-		/* Verify scope_id is the same as intermediate nodes */
-		if (firsthop.sin6_scope_id && scope_id && firsthop.sin6_scope_id != scope_id) {
-			fprintf(stderr, "scope discrepancy among the nodes\n");
-			exit(2);
-		} else if (!scope_id) {
-			scope_id = firsthop.sin6_scope_id;
-		}
-#endif
-	}
-
-	hostname = target;
-
-	if (IN6_IS_ADDR_UNSPECIFIED(&source.sin6_addr)) {
-		socklen_t alen;
-		int probe_fd = socket(AF_INET6, SOCK_DGRAM, 0);
-
-		if (probe_fd < 0) {
-			perror("socket");
-			exit(2);
-		}
-		if (device) {
-#if defined(IPV6_RECVPKTINFO) || defined(HAVE_SIN6_SCOPEID)
-			unsigned int iface = if_name2index(device);
-#endif
-#ifdef IPV6_RECVPKTINFO
-			struct in6_pktinfo ipi;
-
-			memset(&ipi, 0, sizeof(ipi));
-			ipi.ipi6_ifindex = iface;
-#endif
-
-#ifdef HAVE_SIN6_SCOPEID
-			if (IN6_IS_ADDR_LINKLOCAL(&firsthop.sin6_addr) ||
-			    IN6_IS_ADDR_MC_LINKLOCAL(&firsthop.sin6_addr))
-				firsthop.sin6_scope_id = iface;
-#endif
-			enable_capability_raw();
-			if (
-#ifdef IPV6_RECVPKTINFO
-			    setsockopt(probe_fd, IPPROTO_IPV6, IPV6_PKTINFO, &ipi, sizeof(ipi)) == -1 &&
-#endif
-			    setsockopt(probe_fd, SOL_SOCKET, SO_BINDTODEVICE, device, strlen(device)+1) == -1) {
-				perror("setsockopt(SO_BINDTODEVICE)");
-				exit(2);
-			}
-			disable_capability_raw();
-		}
-		firsthop.sin6_port = htons(1025);
-		if (connect(probe_fd, (struct sockaddr*)&firsthop, sizeof(firsthop)) == -1) {
-			perror("connect");
-			exit(2);
-		}
-		alen = sizeof(source);
-		if (getsockname(probe_fd, (struct sockaddr*)&source, &alen) == -1) {
-			perror("getsockname");
-			exit(2);
-		}
-		source.sin6_port = 0;
-		close(probe_fd);
-
-#ifndef WITHOUT_IFADDRS
-		if (device) {
-			struct ifaddrs *ifa0, *ifa;
-
-			if (getifaddrs(&ifa0)) {
-				perror("getifaddrs");
-				exit(2);
-			}
-
-			for (ifa = ifa0; ifa; ifa = ifa->ifa_next) {
-				if (!ifa->ifa_addr || ifa->ifa_addr->sa_family != AF_INET6)
-					continue;
-				if (!strncmp(ifa->ifa_name, device, sizeof(device) - 1) &&
-				    IN6_ARE_ADDR_EQUAL(&((struct sockaddr_in6 *)ifa->ifa_addr)->sin6_addr,
-						       &source.sin6_addr))
-					break;
-			}
-			if (!ifa)
-				fprintf(stderr, "ping6: Warning: source address might be selected on device other than %s.\n", device);
-
-			freeifaddrs(ifa0);
-		}
-#endif
-	}
-#ifdef HAVE_SIN6_SCOPEID
-	else if (device && (IN6_IS_ADDR_LINKLOCAL(&source.sin6_addr) ||
-			    IN6_IS_ADDR_MC_LINKLOCAL(&source.sin6_addr)))
-		source.sin6_scope_id = if_name2index(device);
-#endif
-
-	if (icmp_sock < 0) {
-		errno = socket_errno;
-		perror("ping: icmp open socket");
-		exit(2);
-	}
-
-	if (device) {
-		struct cmsghdr *cmsg;
-		struct in6_pktinfo *ipi;
-
-		cmsg = (struct cmsghdr*)(cmsgbuf+cmsglen);
-		cmsglen += CMSG_SPACE(sizeof(*ipi));
-		cmsg->cmsg_len = CMSG_LEN(sizeof(*ipi));
-		cmsg->cmsg_level = SOL_IPV6;
-		cmsg->cmsg_type = IPV6_PKTINFO;
-
-		ipi = (struct in6_pktinfo*)CMSG_DATA(cmsg);
-		memset(ipi, 0, sizeof(*ipi));
-		ipi->ipi6_ifindex = if_name2index(device);
-	}
-
-	if ((whereto.sin6_addr.s6_addr16[0]&htons(0xff00)) == htons (0xff00)) {
-		if (uid) {
-			if (interval < 1000) {
-				fprintf(stderr, "ping: multicast ping with too short interval.\n");
-				exit(2);
-			}
-			if (pmtudisc >= 0 && pmtudisc != IPV6_PMTUDISC_DO) {
-				fprintf(stderr, "ping: multicast ping does not fragment.\n");
-				exit(2);
-			}
-		}
-		if (pmtudisc < 0)
-			pmtudisc = IPV6_PMTUDISC_DO;
-	}
-
-	if (pmtudisc >= 0) {
-		if (setsockopt(icmp_sock, SOL_IPV6, IPV6_MTU_DISCOVER, &pmtudisc, sizeof(pmtudisc)) == -1) {
-			perror("ping: IPV6_MTU_DISCOVER");
-			exit(2);
-		}
-	}
-
-	if ((options&F_STRICTSOURCE) &&
-	    bind(icmp_sock, (struct sockaddr*)&source, sizeof(source)) == -1) {
-		perror("ping: bind icmp socket");
-		exit(2);
-	}
-
-	if (datalen >= sizeof(struct timeval) && (ni_query < 0)) {
-		/* can we time transfer */
-		timing = 1;
-	}
-	packlen = datalen + 8 + 4096 + 40 + 8; /* 4096 for rthdr */
-	if (!(packet = (u_char *)malloc((u_int)packlen))) {
-		fprintf(stderr, "ping: out of memory.\n");
-		exit(2);
-	}
-
-	working_recverr = 1;
-	hold = 1;
-	if (setsockopt(icmp_sock, SOL_IPV6, IPV6_RECVERR, (char *)&hold, sizeof(hold))) {
-		fprintf(stderr, "WARNING: your kernel is veeery old. No problems.\n");
-		working_recverr = 0;
-	}
-
-	/* Estimate memory eaten by single packet. It is rough estimate.
-	 * Actually, for small datalen's it depends on kernel side a lot. */
-	hold = datalen+8;
-	hold += ((hold+511)/512)*(40+16+64+160);
-	sock_setbufs(icmp_sock, hold);
-
-	if (!using_ping_socket) {
-#ifdef __linux__
-		csum_offset = 2;
-		sz_opt = sizeof(int);
-
-		err = setsockopt(icmp_sock, SOL_RAW, IPV6_CHECKSUM, &csum_offset, sz_opt);
-		if (err < 0) {
-			/* checksum should be enabled by default and setting this
-			 * option might fail anyway.
-			 */
-			fprintf(stderr, "setsockopt(RAW_CHECKSUM) failed - try to continue.");
-		}
-#endif
-
-		/*
-		 *	select icmp echo reply as icmp type to receive
-		 */
-
-		ICMP6_FILTER_SETBLOCKALL(&filter);
-
-		if (!working_recverr) {
-			ICMP6_FILTER_SETPASS(ICMP6_DST_UNREACH, &filter);
-			ICMP6_FILTER_SETPASS(ICMP6_PACKET_TOO_BIG, &filter);
-			ICMP6_FILTER_SETPASS(ICMP6_TIME_EXCEEDED, &filter);
-			ICMP6_FILTER_SETPASS(ICMP6_PARAM_PROB, &filter);
-		}
-
-		if (niquery_is_enabled())
-			ICMP6_FILTER_SETPASS(ICMPV6_NI_REPLY, &filter);
-		else
-			ICMP6_FILTER_SETPASS(ICMP6_ECHO_REPLY, &filter);
-
-		err = setsockopt(icmp_sock, IPPROTO_ICMPV6, ICMP6_FILTER, &filter,
-				 sizeof(struct icmp6_filter));
-
-		if (err < 0) {
-			perror("setsockopt(ICMP6_FILTER)");
-			exit(2);
-		}
-	}
-
-	if (options & F_NOLOOP) {
-		int loop = 0;
-		if (setsockopt(icmp_sock, IPPROTO_IPV6, IPV6_MULTICAST_LOOP,
-							&loop, sizeof(loop)) == -1) {
-			perror ("can't disable multicast loopback");
-			exit(2);
-		}
-	}
-	if (options & F_TTL) {
-		if (setsockopt(icmp_sock, IPPROTO_IPV6, IPV6_MULTICAST_HOPS,
-			       &ttl, sizeof(ttl)) == -1) {
-			perror ("can't set multicast hop limit");
-			exit(2);
-		}
-		if (setsockopt(icmp_sock, IPPROTO_IPV6, IPV6_UNICAST_HOPS,
-			       &ttl, sizeof(ttl)) == -1) {
-			perror ("can't set unicast hop limit");
-			exit(2);
-		}
-	}
-
-	if (1) {
-		int on = 1;
-		if (
-#ifdef IPV6_RECVHOPLIMIT
-		    setsockopt(icmp_sock, IPPROTO_IPV6, IPV6_RECVHOPLIMIT,
-			       &on, sizeof(on)) == -1 &&
-		    setsockopt(icmp_sock, IPPROTO_IPV6, IPV6_2292HOPLIMIT,
-			       &on, sizeof(on)) == -1
-#else
-		    setsockopt(icmp_sock, IPPROTO_IPV6, IPV6_HOPLIMIT,
-			       &on, sizeof(on)) == -1
-#endif
-		   ){
-			perror ("can't receive hop limit");
-			exit(2);
-		}
-	}
-
-	if (options & F_TCLASS) {
-#ifdef IPV6_TCLASS
-		if (setsockopt(icmp_sock, IPPROTO_IPV6, IPV6_TCLASS,
-			       &tclass, sizeof(tclass)) == -1) {
-			perror ("setsockopt(IPV6_TCLASS)");
-			exit(2);
-		}
-#else
-		fprintf(stderr, "Traffic class is not supported.\n");
-#endif
-	}
-
-	if (options&F_FLOWINFO) {
-#ifdef IPV6_FLOWINFO_SEND
-		int on = 1;
-#endif
-#ifdef IPV6_FLOWLABEL_MGR
-		char freq_buf[CMSG_ALIGN(sizeof(struct in6_flowlabel_req)) + cmsglen];
-		struct in6_flowlabel_req *freq = (struct in6_flowlabel_req *)freq_buf;
-		int freq_len = sizeof(*freq);
-#ifdef ENABLE_PING6_RTHDR
-		if (srcrt)
-			freq_len = CMSG_ALIGN(sizeof(*freq)) + srcrt->cmsg_len;
-#endif
-		memset(freq, 0, sizeof(*freq));
-		freq->flr_label = htonl(flowlabel & IPV6_FLOWINFO_FLOWLABEL);
-		freq->flr_action = IPV6_FL_A_GET;
-		freq->flr_flags = IPV6_FL_F_CREATE;
-		freq->flr_share = IPV6_FL_S_EXCL;
-		memcpy(&freq->flr_dst, &whereto.sin6_addr, 16);
-#ifdef ENABLE_PING6_RTHDR
-		if (srcrt)
-			memcpy(freq_buf + CMSG_ALIGN(sizeof(*freq)), srcrt, srcrt->cmsg_len);
-#endif
-		if (setsockopt(icmp_sock, IPPROTO_IPV6, IPV6_FLOWLABEL_MGR,
-			       freq, freq_len) == -1) {
-			perror ("can't set flowlabel");
-			exit(2);
-		}
-		flowlabel = freq->flr_label;
-#ifdef ENABLE_PING6_RTHDR
-		if (srcrt) {
-			cmsglen = (char*)srcrt - (char*)cmsgbuf;
-			srcrt = NULL;
-		}
-#endif
-#else
-		fprintf(stderr, "Flow labels are not supported.\n");
-		exit(2);
-#endif
-
-#ifdef IPV6_FLOWINFO_SEND
-		whereto.sin6_flowinfo = flowlabel;
-		if (setsockopt(icmp_sock, IPPROTO_IPV6, IPV6_FLOWINFO_SEND,
-			       &on, sizeof(on)) == -1) {
-			perror ("can't send flowinfo");
-			exit(2);
-		}
-#else
-		fprintf(stderr, "Flowinfo is not supported.\n");
-		exit(2);
-#endif
-	}
-
-	printf("PING %s(%s) ", hostname, pr_addr(&whereto.sin6_addr));
-	if (flowlabel)
-		printf(", flow 0x%05x, ", (unsigned)ntohl(flowlabel));
-	if (device || (options&F_STRICTSOURCE)) {
-		printf("from %s %s: ",
-		       pr_addr_n(&source.sin6_addr), device ? : "");
-	}
-	printf("%d data bytes\n", datalen);
-
-	setup(icmp_sock);
-
-	drop_capabilities();
-
-	main_loop(icmp_sock, packet, packlen);
-}
-
-int receive_error_msg()
-{
-	int res;
-	char cbuf[512];
-	struct iovec  iov;
-	struct msghdr msg;
-	struct cmsghdr *cmsg;
-	struct sock_extended_err *e;
-	struct icmp6_hdr icmph;
-	struct sockaddr_in6 target;
-	int net_errors = 0;
-	int local_errors = 0;
-	int saved_errno = errno;
-
-	iov.iov_base = &icmph;
-	iov.iov_len = sizeof(icmph);
-	msg.msg_name = (void*)&target;
-	msg.msg_namelen = sizeof(target);
-	msg.msg_iov = &iov;
-	msg.msg_iovlen = 1;
-	msg.msg_flags = 0;
-	msg.msg_control = cbuf;
-	msg.msg_controllen = sizeof(cbuf);
-
-	res = recvmsg(icmp_sock, &msg, MSG_ERRQUEUE|MSG_DONTWAIT);
-	if (res < 0)
-		goto out;
-
-	e = NULL;
-	for (cmsg = CMSG_FIRSTHDR(&msg); cmsg; cmsg = CMSG_NXTHDR(&msg, cmsg)) {
-		if (cmsg->cmsg_level == SOL_IPV6) {
-			if (cmsg->cmsg_type == IPV6_RECVERR)
-				e = (struct sock_extended_err *)CMSG_DATA(cmsg);
-		}
-	}
-	if (e == NULL)
-		abort();
-
-	if (e->ee_origin == SO_EE_ORIGIN_LOCAL) {
-		local_errors++;
-		if (options & F_QUIET)
-			goto out;
-		if (options & F_FLOOD)
-			write_stdout("E", 1);
-		else if (e->ee_errno != EMSGSIZE)
-			fprintf(stderr, "ping: local error: %s\n", strerror(e->ee_errno));
-		else
-			fprintf(stderr, "ping: local error: Message too long, mtu=%u\n", e->ee_info);
-		nerrors++;
-	} else if (e->ee_origin == SO_EE_ORIGIN_ICMP6) {
-		struct sockaddr_in6 *sin6 = (struct sockaddr_in6*)(e+1);
-
-		if (res < sizeof(icmph) ||
-		    memcmp(&target.sin6_addr, &whereto.sin6_addr, 16) ||
-		    icmph.icmp6_type != ICMP6_ECHO_REQUEST ||
-		    !is_ours(icmph.icmp6_id)) {
-			/* Not our error, not an error at all. Clear. */
-			saved_errno = 0;
-			goto out;
-		}
-
-		net_errors++;
-		nerrors++;
-		if (options & F_QUIET)
-			goto out;
-		if (options & F_FLOOD) {
-			write_stdout("\bE", 2);
-		} else {
-			print_timestamp();
-			printf("From %s icmp_seq=%u ", pr_addr(&sin6->sin6_addr), ntohs(icmph.icmp6_seq));
-			pr_icmph(e->ee_type, e->ee_code, e->ee_info);
-			putchar('\n');
-			fflush(stdout);
-		}
-	}
-
-out:
-	errno = saved_errno;
-	return net_errors ? : -local_errors;
-}
-
-/*
- * pinger --
- * 	Compose and transmit an ICMP ECHO REQUEST packet.  The IP packet
- * will be added on by the kernel.  The ID field is our UNIX process ID,
- * and the sequence number is an ascending integer.  The first 8 bytes
- * of the data portion are used to hold a UNIX "timeval" struct in VAX
- * byte-order, to compute the round-trip time.
- */
-int build_echo(__u8 *_icmph)
-{
-	struct icmp6_hdr *icmph;
-	int cc;
-
-	icmph = (struct icmp6_hdr *)_icmph;
-	icmph->icmp6_type = ICMP6_ECHO_REQUEST;
-	icmph->icmp6_code = 0;
-	icmph->icmp6_cksum = 0;
-	icmph->icmp6_seq = htons(ntransmitted+1);
-	icmph->icmp6_id = ident;
-
-	if (timing)
-		gettimeofday((struct timeval *)&outpack[8],
-		    (struct timezone *)NULL);
-
-	cc = datalen + 8;			/* skips ICMP portion */
-
-	return cc;
-}
-
-
-int build_niquery(__u8 *_nih)
-{
-	struct ni_hdr *nih;
-	int cc;
-
-	nih = (struct ni_hdr *)_nih;
-	nih->ni_cksum = 0;
-
-	nih->ni_type = ICMPV6_NI_QUERY;
-	cc = sizeof(*nih);
-	datalen = 0;
-
-	niquery_fill_nonce(ntransmitted + 1, nih->ni_nonce);
-	nih->ni_code = ni_subject_type;
-	nih->ni_qtype = htons(ni_query);
-	nih->ni_flags = ni_flag;
-	memcpy(nih + 1, ni_subject, ni_subject_len);
-	cc += ni_subject_len;
-
-	return cc;
-}
-
-int send_probe(void)
-{
-	int len, cc;
-
-	rcvd_clear(ntransmitted + 1);
-
-	if (niquery_is_enabled())
-		len = build_niquery(outpack);
-	else
-		len = build_echo(outpack);
-
-	if (cmsglen == 0) {
-		cc = sendto(icmp_sock, (char *)outpack, len, confirm,
-			    (struct sockaddr *) &whereto,
-			    sizeof(struct sockaddr_in6));
-	} else {
-		struct msghdr mhdr;
-		struct iovec iov;
-
-		iov.iov_len  = len;
-		iov.iov_base = outpack;
-
-		memset(&mhdr, 0, sizeof(mhdr));
-		mhdr.msg_name = &whereto;
-		mhdr.msg_namelen = sizeof(struct sockaddr_in6);
-		mhdr.msg_iov = &iov;
-		mhdr.msg_iovlen = 1;
-		mhdr.msg_control = cmsgbuf;
-		mhdr.msg_controllen = cmsglen;
-
-		cc = sendmsg(icmp_sock, &mhdr, confirm);
-	}
-	confirm = 0;
-
-	return (cc == len ? 0 : cc);
-}
-
-void pr_echo_reply(__u8 *_icmph, int cc)
-{
-	struct icmp6_hdr *icmph = (struct icmp6_hdr *) _icmph;
-	printf(" icmp_seq=%u", ntohs(icmph->icmp6_seq));
-};
-
-static void putchar_safe(char c)
-{
-	if (isprint(c))
-		putchar(c);
-	else
-		printf("\\%03o", c);
-}
-
-void pr_niquery_reply_name(struct ni_hdr *nih, int len)
-{
-	__u8 *h = (__u8 *)(nih + 1);
-	__u8 *p = h + 4;
-	__u8 *end = (__u8 *)nih + len;
-	int continued = 0;
-	char buf[1024];
-	int ret;
-
-	len -= sizeof(struct ni_hdr) + 4;
-
-	if (len < 0) {
-		printf(" parse error (too short)");
-		return;
-	}
-	while (p < end) {
-		int fqdn = 1;
-		int i;
-
-		memset(buf, 0xff, sizeof(buf));
-
-		if (continued)
-			putchar(',');
-
-		ret = dn_expand(h, end, p, buf, sizeof(buf));
-		if (ret < 0) {
-			printf(" parse error (truncated)");
-			break;
-		}
-		if (p + ret < end && *(p + ret) == '\0')
-			fqdn = 0;
-
-		putchar(' ');
-		for (i = 0; i < strlen(buf); i++)
-			putchar_safe(buf[i]);
-		if (fqdn)
-			putchar('.');
-
-		p += ret + !fqdn;
-
-		continued = 1;
-	}
-}
-
-void pr_niquery_reply_addr(struct ni_hdr *nih, int len)
-{
-	__u8 *h = (__u8 *)(nih + 1);
-	__u8 *p = h + 4;
-	__u8 *end = (__u8 *)nih + len;
-	int af;
-	int aflen;
-	int continued = 0;
-	int truncated;
-	char buf[1024];
-
-	switch (ntohs(nih->ni_qtype)) {
-	case NI_QTYPE_IPV4ADDR:
-		af = AF_INET;
-		aflen = sizeof(struct in_addr);
-		truncated = nih->ni_flags & NI_IPV6ADDR_F_TRUNCATE;
-		break;
-	case NI_QTYPE_IPV6ADDR:
-		af = AF_INET6;
-		aflen = sizeof(struct in6_addr);
-		truncated = nih->ni_flags & NI_IPV4ADDR_F_TRUNCATE;
-		break;
-	default:
-		/* should not happen */
-		af = aflen = truncated = 0;
-	}
-	p = h;
-	if (len < 0) {
-		printf(" parse error (too short)");
-		return;
-	}
-
-	while (p < end) {
-		if (continued)
-			putchar(',');
-
-		if (p + sizeof(__u32) + aflen > end) {
-			printf(" parse error (truncated)");
-			break;
-		}
-		if (!inet_ntop(af, p + sizeof(__u32), buf, sizeof(buf)))
-			printf(" unexpeced error in inet_ntop(%s)",
-			       strerror(errno));
-		else
-			printf(" %s", buf);
-		p += sizeof(__u32) + aflen;
-
-		continued = 1;
-	}
-	if (truncated)
-		printf(" (truncated)");
-}
-
-void pr_niquery_reply(__u8 *_nih, int len)
-{
-	struct ni_hdr *nih = (struct ni_hdr *)_nih;
-
-	switch (nih->ni_code) {
-	case NI_SUCCESS:
-		switch (ntohs(nih->ni_qtype)) {
-		case NI_QTYPE_NAME:
-			pr_niquery_reply_name(nih, len);
-			break;
-		case NI_QTYPE_IPV4ADDR:
-		case NI_QTYPE_IPV6ADDR:
-			pr_niquery_reply_addr(nih, len);
-			break;
-		default:
-			printf(" unknown qtype(0x%02x)", ntohs(nih->ni_qtype));
-		}
-		break;
-	case NI_REFUSED:
-		printf(" refused");
-		break;
-	case NI_UNKNOWN:
-		printf(" unknown");
-		break;
-	default:
-		printf(" unknown code(%02x)", ntohs(nih->ni_code));
-	}
-	printf("; seq=%u;", ntohsp((__u16*)nih->ni_nonce));
-}
-
-/*
- * parse_reply --
- *	Print out the packet, if it came from us.  This logic is necessary
- * because ALL readers of the ICMP socket get a copy of ALL ICMP packets
- * which arrive ('tis only fair).  This permits multiple copies of this
- * program to be run without having intermingled output (or statistics!).
- */
-int
-parse_reply(struct msghdr *msg, int cc, void *addr, struct timeval *tv)
-{
-	struct sockaddr_in6 *from = addr;
-	__u8 *buf = msg->msg_iov->iov_base;
-	struct cmsghdr *c;
-	struct icmp6_hdr *icmph;
-	int hops = -1;
-
-	for (c = CMSG_FIRSTHDR(msg); c; c = CMSG_NXTHDR(msg, c)) {
-		if (c->cmsg_level != SOL_IPV6)
-			continue;
-		switch(c->cmsg_type) {
-		case IPV6_HOPLIMIT:
-#ifdef IPV6_2292HOPLIMIT
-		case IPV6_2292HOPLIMIT:
-#endif
-			if (c->cmsg_len < CMSG_LEN(sizeof(int)))
-				continue;
-			memcpy(&hops, CMSG_DATA(c), sizeof(hops));
-		}
-	}
-
-
-	/* Now the ICMP part */
-
-	icmph = (struct icmp6_hdr *) buf;
-	if (cc < 8) {
-		if (options & F_VERBOSE)
-			fprintf(stderr, "ping: packet too short (%d bytes)\n", cc);
-		return 1;
-	}
-
-	if (icmph->icmp6_type == ICMP6_ECHO_REPLY) {
-		if (!is_ours(icmph->icmp6_id))
-			return 1;
-
-		if (gather_statistics((__u8*)icmph, sizeof(*icmph), cc,
-				      ntohs(icmph->icmp6_seq),
-				      hops, 0, tv, pr_addr(&from->sin6_addr),
-				      pr_echo_reply))
-			return 0;
-	} else if (icmph->icmp6_type == ICMPV6_NI_REPLY) {
-		struct ni_hdr *nih = (struct ni_hdr *)icmph;
-		int seq = niquery_check_nonce(nih->ni_nonce);
-		if (seq < 0)
-			return 1;
-		if (gather_statistics((__u8*)icmph, sizeof(*icmph), cc,
-				      seq,
-				      hops, 0, tv, pr_addr(&from->sin6_addr),
-				      pr_niquery_reply))
-			return 0;
-	} else {
-		int nexthdr;
-		struct ip6_hdr *iph1 = (struct ip6_hdr*)(icmph+1);
-		struct icmp6_hdr *icmph1 = (struct icmp6_hdr *)(iph1+1);
-
-		/* We must not ever fall here. All the messages but
-		 * echo reply are blocked by filter and error are
-		 * received with IPV6_RECVERR. Ugly code is preserved
-		 * however, just to remember what crap we avoided
-		 * using RECVRERR. :-)
-		 */
-
-		if (cc < 8+sizeof(struct ip6_hdr)+8)
-			return 1;
-
-		if (memcmp(&iph1->ip6_dst, &whereto.sin6_addr, 16))
-			return 1;
-
-		nexthdr = iph1->ip6_nxt;
-
-		if (nexthdr == 44) {
-			nexthdr = *(__u8*)icmph1;
-			icmph1++;
-		}
-		if (nexthdr == IPPROTO_ICMPV6) {
-			if (icmph1->icmp6_type != ICMP6_ECHO_REQUEST ||
-			    !is_ours(icmph1->icmp6_id))
-				return 1;
-			acknowledge(ntohs(icmph1->icmp6_seq));
-			if (working_recverr)
-				return 0;
-			nerrors++;
-			if (options & F_FLOOD) {
-				write_stdout("\bE", 2);
-				return 0;
-			}
-			print_timestamp();
-			printf("From %s: icmp_seq=%u ", pr_addr(&from->sin6_addr), ntohs(icmph1->icmp6_seq));
-		} else {
-			/* We've got something other than an ECHOREPLY */
-			if (!(options & F_VERBOSE) || uid)
-				return 1;
-			print_timestamp();
-			printf("From %s: ", pr_addr(&from->sin6_addr));
-		}
-		pr_icmph(icmph->icmp6_type, icmph->icmp6_code, ntohl(icmph->icmp6_mtu));
-	}
-
-	if (options & F_AUDIBLE) {
-		putchar('\a');
-		if(options & F_FLOOD)
-			fflush(stdout);
-	}
-	if (!(options & F_FLOOD)) {
-		putchar('\n');
-		fflush(stdout);
-	}
-	return 0;
-}
-
-
-int pr_icmph(__u8 type, __u8 code, __u32 info)
-{
-	switch(type) {
-	case ICMP6_DST_UNREACH:
-		printf("Destination unreachable: ");
-		switch (code) {
-		case ICMP6_DST_UNREACH_NOROUTE:
-			printf("No route");
-			break;
-		case ICMP6_DST_UNREACH_ADMIN:
-			printf("Administratively prohibited");
-			break;
-		case ICMP6_DST_UNREACH_BEYONDSCOPE:
-			printf("Beyond scope of source address");
-			break;
-		case ICMP6_DST_UNREACH_ADDR:
-			printf("Address unreachable");
-			break;
-		case ICMP6_DST_UNREACH_NOPORT:
-			printf("Port unreachable");
-			break;
-		default:
-			printf("Unknown code %d", code);
-			break;
-		}
-		break;
-	case ICMP6_PACKET_TOO_BIG:
-		printf("Packet too big: mtu=%u", info);
-		if (code)
-			printf(", code=%d", code);
-		break;
-	case ICMP6_TIME_EXCEEDED:
-		printf("Time exceeded: ");
-		if (code == ICMP6_TIME_EXCEED_TRANSIT)
-			printf("Hop limit");
-		else if (code == ICMP6_TIME_EXCEED_REASSEMBLY)
-			printf("Defragmentation failure");
-		else
-			printf("code %d", code);
-		break;
-	case ICMP6_PARAM_PROB:
-		printf("Parameter problem: ");
-		if (code == ICMP6_PARAMPROB_HEADER)
-			printf("Wrong header field ");
-		else if (code == ICMP6_PARAMPROB_NEXTHEADER)
-			printf("Unknown header ");
-		else if (code == ICMP6_PARAMPROB_OPTION)
-			printf("Unknown option ");
-		else
-			printf("code %d ", code);
-		printf ("at %u", info);
-		break;
-	case ICMP6_ECHO_REQUEST:
-		printf("Echo request");
-		break;
-	case ICMP6_ECHO_REPLY:
-		printf("Echo reply");
-		break;
-	case MLD_LISTENER_QUERY:
-		printf("MLD Query");
-		break;
-	case MLD_LISTENER_REPORT:
-		printf("MLD Report");
-		break;
-	case MLD_LISTENER_REDUCTION:
-		printf("MLD Reduction");
-		break;
-	default:
-		printf("unknown icmp type: %u", type);
-
-	}
-	return 0;
-}
-
-#include <linux/filter.h>
-
-void install_filter(void)
-{
-	static int once;
-	static struct sock_filter insns[] = {
-		BPF_STMT(BPF_LD|BPF_H|BPF_ABS, 4),  /* Load icmp echo ident */
-		BPF_JUMP(BPF_JMP|BPF_JEQ|BPF_K, 0xAAAA, 0, 1),  /* Ours? */
-		BPF_STMT(BPF_RET|BPF_K, ~0U),  /* Yes, it passes. */
-		BPF_STMT(BPF_LD|BPF_B|BPF_ABS, 0),  /* Load icmp type */
-		BPF_JUMP(BPF_JMP|BPF_JEQ|BPF_K, ICMP6_ECHO_REPLY, 1, 0), /* Echo? */
-		BPF_STMT(BPF_RET|BPF_K, ~0U), /* No. It passes. This must not happen. */
-		BPF_STMT(BPF_RET|BPF_K, 0), /* Echo with wrong ident. Reject. */
-	};
-	static struct sock_fprog filter = {
-		sizeof insns / sizeof(insns[0]),
-		insns
-	};
-
-	if (once)
-		return;
-	once = 1;
-
-	/* Patch bpflet for current identifier. */
-	insns[1] = (struct sock_filter)BPF_JUMP(BPF_JMP|BPF_JEQ|BPF_K, htons(ident), 0, 1);
-
-	if (setsockopt(icmp_sock, SOL_SOCKET, SO_ATTACH_FILTER, &filter, sizeof(filter)))
-		perror("WARNING: failed to install socket filter\n");
-}
-
-
-/*
- * pr_addr --
- *	Return an ascii host address as a dotted quad and optionally with
- * a hostname.
- */
-char * pr_addr(struct in6_addr *addr)
-{
-	struct hostent *hp = NULL;
-	static char *s;
-
-#ifdef USE_IDN
-	free(s);
-#endif
-
-	in_pr_addr = !setjmp(pr_addr_jmp);
-
-	if (!(exiting || options&F_NUMERIC))
-		hp = gethostbyaddr((__u8*)addr, sizeof(struct in6_addr), AF_INET6);
-
-	in_pr_addr = 0;
-
-	if (!hp
-#ifdef USE_IDN
-	    || idna_to_unicode_lzlz(hp->h_name, &s, 0) != IDNA_SUCCESS
-#endif
-	    )
-		s = NULL;
-
-	return hp ? (s ? s : hp->h_name) : pr_addr_n(addr);
-}
-
-char * pr_addr_n(struct in6_addr *addr)
-{
-	static char str[64];
-	inet_ntop(AF_INET6, addr, str, sizeof(str));
-	return str;
-}
-
-#define USAGE_NEWLINE	"\n            "
-
-void usage(void)
-{
-	fprintf(stderr,
-		"Usage: ping6"
-		" [-"
-			"aAbBdDfhLnOqrRUvV"
-		"]"
-		" [-c count]"
-		" [-i interval]"
-		" [-I interface]"
-		USAGE_NEWLINE
-		" [-l preload]"
-		" [-m mark]"
-		" [-M pmtudisc_option]"
-		USAGE_NEWLINE
-		" [-N nodeinfo_option]"
-		" [-p pattern]"
-		" [-Q tclass]"
-		" [-s packetsize]"
-		USAGE_NEWLINE
-		" [-S sndbuf]"
-		" [-t ttl]"
-		" [-T timestamp_option]"
-		" [-w deadline]"
-		USAGE_NEWLINE
-		" [-W timeout]"
-#ifdef ENABLE_PING6_RTHDR
-		" [hop1 ...]"
-#endif
-		" destination"
-		"\n"
-	);
-	exit(2);
-}
diff -Naur iputils-s20151218.orig/ping6_common.c iputils-s20151218/ping6_common.c
--- iputils-s20151218.orig/ping6_common.c	1970-01-01 00:00:00.000000000 +0000
+++ iputils-s20151218/ping6_common.c	2016-05-17 23:17:09.000000000 +0000
@@ -0,0 +1,1640 @@
+/*
+ *
+ *	Modified for AF_INET6 by Pedro Roque
+ *
+ *	<roque@di.fc.ul.pt>
+ *
+ *	Original copyright notice included bellow
+ */
+
+/*
+ * Copyright (c) 1989 The Regents of the University of California.
+ * All rights reserved.
+ *
+ * This code is derived from software contributed to Berkeley by
+ * Mike Muuss.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. All advertising materials mentioning features or use of this software
+ *    must display the following acknowledgement:
+ *	This product includes software developed by the University of
+ *	California, Berkeley and its contributors.
+ * 4. Neither the name of the University nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ */
+/*
+ *			P I N G . C
+ *
+ * Using the InterNet Control Message Protocol (ICMP) "ECHO" facility,
+ * measure round-trip-delays and packet loss across network paths.
+ *
+ * Author -
+ *	Mike Muuss
+ *	U. S. Army Ballistic Research Laboratory
+ *	December, 1983
+ *
+ * Status -
+ *	Public Domain.  Distribution Unlimited.
+ * Bugs -
+ *	More statistics could always be gathered.
+ *	If kernel does not support non-raw ICMP sockets or
+ *	if -N option is used, this program has to run SUID to ROOT or
+ *	with net_cap_raw enabled.
+ */
+#include "ping.h"
+
+#if defined(ENABLE_PING6_RTHDR) && !defined(ENABLE_PING6_RTHDR_RFC3542)
+#ifndef IPV6_SRCRT_TYPE_0
+#define IPV6_SRCRT_TYPE_0	0
+#endif
+#endif
+
+ping_func_set_st ping6_func_set = {
+	.send_probe = ping6_send_probe,
+	.receive_error_msg = ping6_receive_error_msg,
+	.parse_reply = ping6_parse_reply,
+	.install_filter = ping6_install_filter
+};
+
+#define BIT_CLEAR(nr, addr) do { ((__u32 *)(addr))[(nr) >> 5] &= ~(1U << ((nr) & 31)); } while(0)
+#define BIT_SET(nr, addr) do { ((__u32 *)(addr))[(nr) >> 5] |= (1U << ((nr) & 31)); } while(0)
+#define BIT_TEST(nr, addr) do { (__u32 *)(addr))[(nr) >> 5] & (1U << ((nr) & 31)); } while(0)
+
+#ifndef SCOPE_DELIMITER
+# define SCOPE_DELIMITER '%'
+#endif
+
+__u32 flowlabel;
+__u32 tclass;
+#ifdef ENABLE_PING6_RTHDR
+struct cmsghdr *srcrt;
+#endif
+
+static struct sockaddr_in6 whereto;
+static struct sockaddr_in6 firsthop;
+
+static unsigned char cmsgbuf[4096];
+static int cmsglen = 0;
+
+static int pr_icmph(__u8 type, __u8 code, __u32 info);
+void ping6_usage(unsigned) __attribute((noreturn));
+
+struct sockaddr_in6 source6 = { .sin6_family = AF_INET6 };
+char *device;
+int pmtudisc=-1;
+
+#if defined(USE_GCRYPT) || defined(USE_OPENSSL) || defined(USE_NETTLE)
+#include "iputils_md5dig.h"
+#define USE_CRYPTO
+#endif
+
+/* Node Information query */
+int ni_query = -1;
+int ni_flag = 0;
+void *ni_subject = NULL;
+int ni_subject_len = 0;
+int ni_subject_type = -1;
+char *ni_group;
+
+static inline int ntohsp(__u16 *p)
+{
+	__u16 v;
+	memcpy(&v, p, sizeof(v));
+	return ntohs(v);
+}
+
+#if defined(ENABLE_PING6_RTHDR) && !defined(ENABLE_PING6_RTHDR_RFC3542)
+size_t inet6_srcrt_space(int type, int segments)
+{
+	if (type != 0 || segments > 24)
+		return 0;
+
+	return (sizeof(struct cmsghdr) + sizeof(struct ip6_rthdr0) +
+		segments * sizeof(struct in6_addr));
+}
+
+extern struct cmsghdr *	inet6_srcrt_init(void *bp, int type)
+{
+	struct cmsghdr *cmsg;
+
+	if (type)
+		return NULL;
+
+	memset(bp, 0, sizeof(struct cmsghdr) + sizeof(struct ip6_rthdr0));
+	cmsg = (struct cmsghdr *) bp;
+
+	cmsg->cmsg_len = sizeof(struct cmsghdr) + sizeof(struct ip6_rthdr0);
+	cmsg->cmsg_level = IPPROTO_IPV6;
+	cmsg->cmsg_type = IPV6_RTHDR;
+
+	return cmsg;
+}
+
+int inet6_srcrt_add(struct cmsghdr *cmsg, const struct in6_addr *addr)
+{
+	struct ip6_rthdr0 *hdr;
+
+	hdr = (struct ip6_rthdr0 *) CMSG_DATA(cmsg);
+
+	cmsg->cmsg_len += sizeof(struct in6_addr);
+	hdr->ip6r0_len += sizeof(struct in6_addr) / 8;
+
+	memcpy(&hdr->ip6r0_addr[hdr->ip6r0_segleft++], addr,
+	       sizeof(struct in6_addr));
+
+	return 0;
+}
+#endif
+
+unsigned int if_name2index(const char *ifname)
+{
+	unsigned int i = if_nametoindex(ifname);
+	if (!i) {
+		fprintf(stderr, "ping: unknown iface %s\n", ifname);
+		exit(2);
+	}
+	return i;
+}
+
+struct niquery_option {
+	char *name;
+	int namelen;
+	int has_arg;
+	int data;
+	int (*handler)(int index, const char *arg);
+};
+
+#define NIQUERY_OPTION(_name, _has_arg, _data, _handler)	\
+	{							\
+		.name = _name,					\
+		.namelen = sizeof(_name) - 1,			\
+		.has_arg = _has_arg,				\
+		.data = _data,					\
+		.handler = _handler				\
+	}
+
+static int niquery_option_name_handler(int index, const char *arg);
+static int niquery_option_ipv6_handler(int index, const char *arg);
+static int niquery_option_ipv6_flag_handler(int index, const char *arg);
+static int niquery_option_ipv4_handler(int index, const char *arg);
+static int niquery_option_ipv4_flag_handler(int index, const char *arg);
+static int niquery_option_subject_addr_handler(int index, const char *arg);
+static int niquery_option_subject_name_handler(int index, const char *arg);
+static int niquery_option_help_handler(int index, const char *arg);
+
+struct niquery_option niquery_options[] = {
+	NIQUERY_OPTION("name",			0,	0,				niquery_option_name_handler),
+	NIQUERY_OPTION("fqdn",			0,	0,				niquery_option_name_handler),
+	NIQUERY_OPTION("ipv6",			0,	0,				niquery_option_ipv6_handler),
+	NIQUERY_OPTION("ipv6-all",		0,	NI_IPV6ADDR_F_ALL,		niquery_option_ipv6_flag_handler),
+	NIQUERY_OPTION("ipv6-compatible",	0,	NI_IPV6ADDR_F_COMPAT,		niquery_option_ipv6_flag_handler),
+	NIQUERY_OPTION("ipv6-linklocal",	0,	NI_IPV6ADDR_F_LINKLOCAL,	niquery_option_ipv6_flag_handler),
+	NIQUERY_OPTION("ipv6-sitelocal",	0,	NI_IPV6ADDR_F_SITELOCAL,	niquery_option_ipv6_flag_handler),
+	NIQUERY_OPTION("ipv6-global",		0,	NI_IPV6ADDR_F_GLOBAL,		niquery_option_ipv6_flag_handler),
+	NIQUERY_OPTION("ipv4",			0,	0,				niquery_option_ipv4_handler),
+	NIQUERY_OPTION("ipv4-all",		0,	NI_IPV4ADDR_F_ALL,		niquery_option_ipv4_flag_handler),
+	NIQUERY_OPTION("subject-ipv6",		1,	NI_SUBJ_IPV6,			niquery_option_subject_addr_handler),
+	NIQUERY_OPTION("subject-ipv4",		1,	NI_SUBJ_IPV4,			niquery_option_subject_addr_handler),
+	NIQUERY_OPTION("subject-name",		1,	0,				niquery_option_subject_name_handler),
+	NIQUERY_OPTION("subject-fqdn",		1,	-1,				niquery_option_subject_name_handler),
+	NIQUERY_OPTION("help",			0,	0,				niquery_option_help_handler),
+	{},
+};
+
+static inline int niquery_is_enabled(void)
+{
+	return ni_query >= 0;
+}
+
+#if PING6_NONCE_MEMORY
+__u8 *ni_nonce_ptr;
+#else
+struct {
+	struct timeval tv;
+	pid_t pid;
+} ni_nonce_secret;
+#endif
+
+static void niquery_init_nonce(void)
+{
+#if PING6_NONCE_MEMORY
+	struct timeval tv;
+	unsigned long seed;
+
+	seed = (unsigned long)getpid();
+	if (!gettimeofday(&tv, NULL))
+		seed ^= tv.tv_usec;
+	srand(seed);
+
+	ni_nonce_ptr = calloc(NI_NONCE_SIZE, MAX_DUP_CHK);
+	if (!ni_nonce_ptr) {
+		perror("ping6: calloc");
+		exit(2);
+	}
+
+	ni_nonce_ptr[0] = ~0;
+#else
+	gettimeofday(&ni_nonce_secret.tv, NULL);
+	ni_nonce_secret.pid = getpid();
+#endif
+}
+
+#if !PING6_NONCE_MEMORY
+static int niquery_nonce(__u8 *nonce, int fill)
+{
+# ifdef USE_CRYPTO
+	static __u8 digest[MD5_DIGEST_LENGTH];
+	static int seq = -1;
+
+	if (fill || seq != *(__u16 *)nonce || seq < 0) {
+		MD5_CTX ctxt;
+
+		MD5_Init(&ctxt);
+		MD5_Update(&ctxt, &ni_nonce_secret, sizeof(ni_nonce_secret));
+		MD5_Update(&ctxt, nonce, sizeof(__u16));
+		MD5_Final(digest, &ctxt);
+
+		seq = *(__u16 *)nonce;
+	}
+
+	if (fill) {
+		memcpy(nonce + sizeof(__u16), digest, NI_NONCE_SIZE - sizeof(__u16));
+		return 0;
+	} else {
+		if (memcmp(nonce + sizeof(__u16), digest, NI_NONCE_SIZE - sizeof(__u16)))
+			return -1;
+		return ntohsp((__u16 *)nonce);
+	}
+# else
+	fprintf(stderr, "ping6: function not available; crypto disabled\n");
+	exit(3);
+# endif
+}
+#endif
+
+static inline void niquery_fill_nonce(__u16 seq, __u8 *nonce)
+{
+	__u16 v = htons(seq);
+#if PING6_NONCE_MEMORY
+	int i;
+
+	memcpy(&ni_nonce_ptr[NI_NONCE_SIZE * (seq % MAX_DUP_CHK)], &v, sizeof(v));
+
+	for (i = sizeof(v); i < NI_NONCE_SIZE; i++)
+		ni_nonce_ptr[NI_NONCE_SIZE * (seq % MAX_DUP_CHK) + i] = 0x100 * (rand() / (RAND_MAX + 1.0));
+
+	memcpy(nonce, &ni_nonce_ptr[NI_NONCE_SIZE * (seq % MAX_DUP_CHK)], NI_NONCE_SIZE);
+#else
+	memcpy(nonce, &v, sizeof(v));
+	niquery_nonce(nonce, 1);
+#endif
+}
+
+static inline int niquery_check_nonce(__u8 *nonce)
+{
+#if PING6_NONCE_MEMORY
+	__u16 seq = ntohsp((__u16 *)nonce);
+	if (memcmp(nonce, &ni_nonce_ptr[NI_NONCE_SIZE * (seq % MAX_DUP_CHK)], NI_NONCE_SIZE))
+		return -1;
+	return seq;
+#else
+	return niquery_nonce(nonce, 0);
+#endif
+}
+
+static int niquery_set_qtype(int type)
+{
+	if (niquery_is_enabled() && ni_query != type) {
+		printf("Qtype conflict\n");
+		return -1;
+	}
+	ni_query = type;
+	return 0;
+}
+
+static int niquery_option_name_handler(int index, const char *arg)
+{
+	if (niquery_set_qtype(NI_QTYPE_NAME) < 0)
+		return -1;
+	return 0;
+}
+
+static int niquery_option_ipv6_handler(int index, const char *arg)
+{
+	if (niquery_set_qtype(NI_QTYPE_IPV6ADDR) < 0)
+		return -1;
+	return 0;
+}
+
+static int niquery_option_ipv6_flag_handler(int index, const char *arg)
+{
+	if (niquery_set_qtype(NI_QTYPE_IPV6ADDR) < 0)
+		return -1;
+	ni_flag |= niquery_options[index].data;
+	return 0;
+}
+
+static int niquery_option_ipv4_handler(int index, const char *arg)
+{
+	if (niquery_set_qtype(NI_QTYPE_IPV4ADDR) < 0)
+		return -1;
+	return 0;
+}
+
+static int niquery_option_ipv4_flag_handler(int index, const char *arg)
+{
+	if (niquery_set_qtype(NI_QTYPE_IPV4ADDR) < 0)
+		return -1;
+	ni_flag |= niquery_options[index].data;
+	return 0;
+}
+
+static inline int niquery_is_subject_valid(void)
+{
+	return ni_subject_type >= 0 && ni_subject;
+}
+
+static int niquery_set_subject_type(int type)
+{
+	if (niquery_is_subject_valid() && ni_subject_type != type) {
+		printf("Subject type conflict\n");
+		return -1;
+	}
+	ni_subject_type = type;
+	return 0;
+}
+
+#define ARRAY_SIZE(array)	(sizeof(array) / sizeof(array[0]))
+#define OFFSET_OF(type,elem)	((size_t)&((type *)0)->elem)
+
+static int niquery_option_subject_addr_handler(int index, const char *arg)
+{
+	struct addrinfo hints = { .ai_family = AF_UNSPEC, .ai_socktype = SOCK_DGRAM, .ai_flags = getaddrinfo_flags };
+	struct addrinfo *result, *ai;
+	int status;
+	int offset;
+
+	if (niquery_set_subject_type(niquery_options[index].data) < 0)
+		return -1;
+
+	ni_subject_type = niquery_options[index].data;
+
+	switch (niquery_options[index].data) {
+	case NI_SUBJ_IPV6:
+		ni_subject_len = sizeof(struct in6_addr);
+		offset = OFFSET_OF(struct sockaddr_in6, sin6_addr);
+		hints.ai_family = AF_INET6;
+		break;
+	case NI_SUBJ_IPV4:
+		ni_subject_len = sizeof(struct in_addr);
+		offset = OFFSET_OF(struct sockaddr_in, sin_addr);
+		hints.ai_family = AF_INET;
+		break;
+	default:
+		/* should not happen. */
+		offset = -1;
+	}
+
+	status = getaddrinfo(arg, 0, &hints, &result);
+	if (status) {
+		fprintf(stderr, "ping6: %s: %s\n", arg, gai_strerror(status));
+		return -1;
+	}
+
+	for (ai = result; ai; ai = ai->ai_next) {
+		void *p = malloc(ni_subject_len);
+		if (!p)
+			continue;
+		memcpy(p, (__u8 *)ai->ai_addr + offset, ni_subject_len);
+		free(ni_subject);
+		ni_subject = p;
+		break;
+	}
+	freeaddrinfo(result);
+
+	return 0;
+}
+
+static int niquery_option_subject_name_handler(int index, const char *arg)
+{
+#ifdef USE_CRYPTO
+	static char nigroup_buf[INET6_ADDRSTRLEN + 1 + IFNAMSIZ];
+	unsigned char *dnptrs[2], **dpp, **lastdnptr;
+	int n;
+	int i;
+	char *name, *p;
+	char *canonname = NULL, *idn = NULL;
+	unsigned char *buf = NULL;
+	size_t namelen;
+	size_t buflen;
+	int dots, fqdn = niquery_options[index].data;
+	MD5_CTX ctxt;
+	__u8 digest[MD5_DIGEST_LENGTH];
+#ifdef USE_IDN
+	int rc;
+#endif
+
+	if (niquery_set_subject_type(NI_SUBJ_NAME) < 0)
+		return -1;
+
+#ifdef USE_IDN
+	name = stringprep_locale_to_utf8(arg);
+	if (!name) {
+		fprintf(stderr, "ping6: IDN support failed.\n");
+		exit(2);
+	}
+#else
+	name = strdup(arg);
+	if (!name)
+		goto oomexit;
+#endif
+
+	p = strchr(name, SCOPE_DELIMITER);
+	if (p) {
+		*p = '\0';
+		if (strlen(p + 1) >= IFNAMSIZ) {
+			fprintf(stderr, "ping6: too long scope name.\n");
+			exit(1);
+		}
+	}
+
+#ifdef USE_IDN
+	rc = idna_to_ascii_8z(name, &idn, 0);
+	if (rc) {
+		fprintf(stderr, "ping6: IDN encoding error: %s\n",
+			idna_strerror(rc));
+		exit(2);
+	}
+#else
+	idn = strdup(name);
+	if (!idn)
+		goto oomexit;
+#endif
+
+	namelen = strlen(idn);
+	canonname = malloc(namelen + 1);
+	if (!canonname)
+		goto oomexit;
+
+	dots = 0;
+	for (i = 0; i < namelen + 1; i++) {
+		canonname[i] = isupper(idn[i]) ? tolower(idn[i]) : idn[i];
+		if (idn[i] == '.')
+			dots++;
+	}
+
+	if (fqdn == 0) {
+		/* guess if hostname is FQDN */
+		fqdn = dots ? 1 : -1;
+	}
+
+	buflen = namelen + 3 + 1;	/* dn_comp() requrires strlen() + 3,
+					   plus non-fqdn indicator. */
+	buf = malloc(buflen);
+	if (!buf) {
+		fprintf(stderr, "ping6: out of memory.\n");
+		goto errexit;
+	}
+
+	dpp = dnptrs;
+	lastdnptr = &dnptrs[ARRAY_SIZE(dnptrs)];
+
+	*dpp++ = (unsigned char *)buf;
+	*dpp++ = NULL;
+
+	n = dn_comp(canonname, (unsigned char *)buf, buflen, dnptrs, lastdnptr);
+	if (n < 0) {
+		fprintf(stderr, "ping6: Inappropriate subject name: %s\n", canonname);
+		goto errexit;
+	} else if (n >= buflen) {
+		fprintf(stderr, "ping6: dn_comp() returned too long result.\n");
+		goto errexit;
+	}
+
+	MD5_Init(&ctxt);
+	MD5_Update(&ctxt, buf, buf[0]);
+	MD5_Final(digest, &ctxt);
+
+	sprintf(nigroup_buf, "ff02::2:%02x%02x:%02x%02x%s%s",
+		digest[0], digest[1], digest[2], digest[3],
+		p ? "%" : "",
+		p ? p + 1 : "");
+
+	if (fqdn < 0)
+		buf[n] = 0;
+
+	free(ni_subject);
+
+	ni_group = nigroup_buf;
+	ni_subject = buf;
+	ni_subject_len = n + (fqdn < 0);
+	ni_group = nigroup_buf;
+
+	free(canonname);
+	free(idn);
+	free(name);
+
+	return 0;
+oomexit:
+	fprintf(stderr, "ping6: out of memory.\n");
+errexit:
+	free(buf);
+	free(canonname);
+	free(idn);
+	free(name);
+	exit(1);
+#else
+	fprintf(stderr, "ping6: function not available; crypto disabled\n");
+	exit(3);
+#endif
+}
+
+int niquery_option_help_handler(int index, const char *arg)
+{
+	fprintf(stderr, "ping6 -N suboptions\n"
+			"\tHelp:\n"
+			"\t\thelp\n"
+			"\tQuery:\n"
+			"\t\tname,\n"
+			"\t\tipv6,ipv6-all,ipv6-compatible,ipv6-linklocal,ipv6-sitelocal,ipv6-global,\n"
+			"\t\tipv4,ipv4-all,\n"
+			"\tSubject:\n"
+			"\t\tsubject-ipv6=addr,subject-ipv4=addr,subject-name=name,subject-fqdn=name,\n"
+		);
+	exit(2);
+}
+
+int niquery_option_handler(const char *opt_arg)
+{
+	struct niquery_option *p;
+	int i;
+	int ret = -1;
+	for (i = 0, p = niquery_options; p->name; i++, p++) {
+		if (strncmp(p->name, opt_arg, p->namelen))
+			continue;
+		if (!p->has_arg) {
+			if (opt_arg[p->namelen] == '\0') {
+				ret = p->handler(i, NULL);
+				if (ret >= 0)
+					break;
+			}
+		} else {
+			if (opt_arg[p->namelen] == '=') {
+				ret = p->handler(i, &opt_arg[p->namelen] + 1);
+				if (ret >= 0)
+					break;
+			}
+		}
+	}
+	if (!p->name)
+		ret = niquery_option_help_handler(0, NULL);
+	return ret;
+}
+
+int hextoui(const char *str)
+{
+	unsigned long val;
+	char *ep;
+
+	errno = 0;
+	val = strtoul(str, &ep, 16);
+	if (*ep) {
+		if (!errno)
+			errno = EINVAL;
+		return -1;
+	}
+
+	if (val > UINT_MAX) {
+		errno = ERANGE;
+		return UINT_MAX;
+	}
+
+	return val;
+}
+
+int ping6_run(int argc, char **argv, struct addrinfo *ai, struct socket_st *sock)
+{
+	static const struct addrinfo hints = { .ai_family = AF_INET6, .ai_flags = getaddrinfo_flags };
+	struct addrinfo *result = NULL;
+	int status;
+	int hold, packlen;
+	unsigned char *packet;
+	char *target;
+	struct icmp6_filter filter;
+	int err;
+	static uint32_t scope_id = 0;
+
+#ifdef ENABLE_PING6_RTHDR
+	while (argc > 1) {
+		struct in6_addr *addr;
+
+		if (srcrt == NULL) {
+			int space;
+
+			fprintf(stderr, "ping6: Warning: "
+					"Source routing is deprecated by RFC5095.\n");
+
+#ifdef ENABLE_PING6_RTHDR_RFC3542
+			space = inet6_rth_space(IPV6_RTHDR_TYPE_0, argc - 1);
+#else
+			space = inet6_srcrt_space(IPV6_SRCRT_TYPE_0, argc - 1);
+#endif
+			if (space == 0)	{
+				fprintf(stderr, "srcrt_space failed\n");
+				exit(2);
+			}
+#ifdef ENABLE_PING6_RTHDR_RFC3542
+			if (cmsglen + CMSG_SPACE(space) > sizeof(cmsgbuf)) {
+				fprintf(stderr, "no room for options\n");
+				exit(2);
+			}
+#else
+			if (space + cmsglen > sizeof(cmsgbuf)) {
+				fprintf(stderr, "no room for options\n");
+				exit(2);
+			}
+#endif
+			srcrt = (struct cmsghdr*)(cmsgbuf+cmsglen);
+#ifdef ENABLE_PING6_RTHDR_RFC3542
+			memset(srcrt, 0, CMSG_SPACE(0));
+			srcrt->cmsg_len = CMSG_LEN(space);
+			srcrt->cmsg_level = IPPROTO_IPV6;
+			srcrt->cmsg_type = IPV6_RTHDR;
+			inet6_rth_init(CMSG_DATA(srcrt), space, IPV6_RTHDR_TYPE_0, argc - 1);
+			cmsglen += CMSG_SPACE(space);
+#else
+			cmsglen += CMSG_ALIGN(space);
+			inet6_srcrt_init(srcrt, IPV6_SRCRT_TYPE_0);
+#endif
+		}
+
+		target = *argv;
+
+		status = getaddrinfo(target, NULL, &hints, &result);
+		if (status) {
+			fprintf(stderr, "ping6: %s: %s\n", target, gai_strerror(status));
+			exit(2);
+		}
+		addr = &((struct sockaddr_in6 *)(result->ai_addr))->sin6_addr;
+#ifdef ENABLE_PING6_RTHDR_RFC3542
+		inet6_rth_add(CMSG_DATA(srcrt), addr);
+#else
+		inet6_srcrt_add(srcrt, addr);
+#endif
+		if (IN6_IS_ADDR_UNSPECIFIED(&firsthop.sin6_addr)) {
+			memcpy(&firsthop.sin6_addr, addr, 16);
+			firsthop.sin6_scope_id = ((struct sockaddr_in6 *)(result->ai_addr))->sin6_scope_id;
+			/* Verify scope_id is the same as previous nodes */
+			if (firsthop.sin6_scope_id && scope_id && firsthop.sin6_scope_id != scope_id) {
+				fprintf(stderr, "scope discrepancy among the nodes\n");
+				exit(2);
+			} else if (!scope_id) {
+				scope_id = firsthop.sin6_scope_id;
+			}
+		}
+		freeaddrinfo(result);
+
+		argv++;
+		argc--;
+	}
+#endif
+
+	if (niquery_is_enabled()) {
+		niquery_init_nonce();
+
+		if (!niquery_is_subject_valid()) {
+			ni_subject = &whereto.sin6_addr;
+			ni_subject_len = sizeof(whereto.sin6_addr);
+			ni_subject_type = NI_SUBJ_IPV6;
+		}
+	}
+
+	if (argc > 1) {
+#ifndef ENABLE_PING6_RTHDR
+		fprintf(stderr, "ping6: Source routing is deprecated by RFC5095.\n");
+#endif
+		ping6_usage(0);
+	} else if (argc == 1) {
+		target = *argv;
+	} else {
+		if (ni_query < 0 && ni_subject_type != NI_SUBJ_NAME)
+			ping6_usage(0);
+		target = ni_group;
+	}
+
+	if (!ai) {
+		status = getaddrinfo(target, NULL, &hints, &result);
+		if (status) {
+			fprintf(stderr, "ping6: %s: %s\n", target, gai_strerror(status));
+			exit(2);
+		}
+		ai = result;
+	}
+
+	memcpy(&whereto, ai->ai_addr, sizeof(whereto));
+	whereto.sin6_port = htons(IPPROTO_ICMPV6);
+
+	if (result)
+		freeaddrinfo(result);
+
+	if (memchr(target, ':', strlen(target)))
+		options |= F_NUMERIC;
+
+	if (IN6_IS_ADDR_UNSPECIFIED(&firsthop.sin6_addr)) {
+		memcpy(&firsthop.sin6_addr, &whereto.sin6_addr, 16);
+		firsthop.sin6_scope_id = whereto.sin6_scope_id;
+		/* Verify scope_id is the same as intermediate nodes */
+		if (firsthop.sin6_scope_id && scope_id && firsthop.sin6_scope_id != scope_id) {
+			fprintf(stderr, "scope discrepancy among the nodes\n");
+			exit(2);
+		} else if (!scope_id) {
+			scope_id = firsthop.sin6_scope_id;
+		}
+	}
+
+	hostname = target;
+
+	if (IN6_IS_ADDR_UNSPECIFIED(&source6.sin6_addr)) {
+		socklen_t alen;
+		int probe_fd = socket(AF_INET6, SOCK_DGRAM, 0);
+
+		if (probe_fd < 0) {
+			perror("socket");
+			exit(2);
+		}
+		if (device) {
+			unsigned int iface = if_name2index(device);
+#ifdef IPV6_RECVPKTINFO
+			struct in6_pktinfo ipi;
+
+			memset(&ipi, 0, sizeof(ipi));
+			ipi.ipi6_ifindex = iface;
+#endif
+
+			if (IN6_IS_ADDR_LINKLOCAL(&firsthop.sin6_addr) ||
+			    IN6_IS_ADDR_MC_LINKLOCAL(&firsthop.sin6_addr))
+				firsthop.sin6_scope_id = iface;
+			enable_capability_raw();
+			if (
+#ifdef IPV6_RECVPKTINFO
+			    setsockopt(probe_fd, IPPROTO_IPV6, IPV6_PKTINFO, &ipi, sizeof ipi) == -1 &&
+#endif
+			    setsockopt(probe_fd, SOL_SOCKET, SO_BINDTODEVICE, device, strlen(device)+1) == -1) {
+				perror("setsockopt(SO_BINDTODEVICE)");
+				exit(2);
+			}
+			disable_capability_raw();
+		}
+		firsthop.sin6_port = htons(1025);
+		if (connect(probe_fd, (struct sockaddr*)&firsthop, sizeof(firsthop)) == -1) {
+			perror("connect");
+			exit(2);
+		}
+		alen = sizeof source6;
+		if (getsockname(probe_fd, (struct sockaddr *) &source6, &alen) == -1) {
+			perror("getsockname");
+			exit(2);
+		}
+		source6.sin6_port = 0;
+		close(probe_fd);
+
+#ifndef WITHOUT_IFADDRS
+		if (device) {
+			struct ifaddrs *ifa0, *ifa;
+
+			if (getifaddrs(&ifa0)) {
+				perror("getifaddrs");
+				exit(2);
+			}
+
+			for (ifa = ifa0; ifa; ifa = ifa->ifa_next) {
+				if (!ifa->ifa_addr || ifa->ifa_addr->sa_family != AF_INET6)
+					continue;
+				if (!strncmp(ifa->ifa_name, device, sizeof(device) - 1) &&
+				    IN6_ARE_ADDR_EQUAL(&((struct sockaddr_in6 *)ifa->ifa_addr)->sin6_addr,
+						       &source6.sin6_addr))
+					break;
+			}
+			if (!ifa)
+				fprintf(stderr, "ping6: Warning: source address might be selected on device other than %s.\n", device);
+
+			freeifaddrs(ifa0);
+		}
+#endif
+	}
+	else if (device && (IN6_IS_ADDR_LINKLOCAL(&source6.sin6_addr) ||
+			    IN6_IS_ADDR_MC_LINKLOCAL(&source6.sin6_addr)))
+		source6.sin6_scope_id = if_name2index(device);
+
+	if (device) {
+		struct cmsghdr *cmsg;
+		struct in6_pktinfo *ipi;
+
+		cmsg = (struct cmsghdr*)(cmsgbuf+cmsglen);
+		cmsglen += CMSG_SPACE(sizeof(*ipi));
+		cmsg->cmsg_len = CMSG_LEN(sizeof(*ipi));
+		cmsg->cmsg_level = IPPROTO_IPV6;
+		cmsg->cmsg_type = IPV6_PKTINFO;
+
+		ipi = (struct in6_pktinfo*)CMSG_DATA(cmsg);
+		memset(ipi, 0, sizeof(*ipi));
+		ipi->ipi6_ifindex = if_name2index(device);
+	}
+
+	if ((whereto.sin6_addr.s6_addr16[0]&htons(0xff00)) == htons (0xff00)) {
+		if (uid) {
+			if (interval < 1000) {
+				fprintf(stderr, "ping: multicast ping with too short interval.\n");
+				exit(2);
+			}
+			if (pmtudisc >= 0 && pmtudisc != IPV6_PMTUDISC_DO) {
+				fprintf(stderr, "ping: multicast ping does not fragment.\n");
+				exit(2);
+			}
+		}
+		if (pmtudisc < 0)
+			pmtudisc = IPV6_PMTUDISC_DO;
+	}
+
+	if (pmtudisc >= 0) {
+		if (setsockopt(sock->fd, IPPROTO_IPV6, IPV6_MTU_DISCOVER, &pmtudisc, sizeof pmtudisc) == -1) {
+			perror("ping: IPV6_MTU_DISCOVER");
+			exit(2);
+		}
+	}
+
+	if ((options&F_STRICTSOURCE) &&
+	    bind(sock->fd, (struct sockaddr *) &source6, sizeof source6) == -1) {
+		perror("ping: bind icmp socket");
+		exit(2);
+	}
+
+	if (datalen >= sizeof(struct timeval) && (ni_query < 0)) {
+		/* can we time transfer */
+		timing = 1;
+	}
+	packlen = datalen + 8 + 4096 + 40 + 8; /* 4096 for rthdr */
+	if (!(packet = (unsigned char *)malloc((unsigned int)packlen))) {
+		fprintf(stderr, "ping: out of memory.\n");
+		exit(2);
+	}
+
+	sock->working_recverr = 1;
+	hold = 1;
+	if (setsockopt(sock->fd, IPPROTO_IPV6, IPV6_RECVERR, &hold, sizeof hold)) {
+		fprintf(stderr, "WARNING: your kernel is veeery old. No problems.\n");
+		sock->working_recverr = 0;
+	}
+
+	/* Estimate memory eaten by single packet. It is rough estimate.
+	 * Actually, for small datalen's it depends on kernel side a lot. */
+	hold = datalen+8;
+	hold += ((hold+511)/512)*(40+16+64+160);
+	sock_setbufs(sock, hold);
+
+#ifdef __linux__
+	if (sock->socktype == SOCK_RAW) {
+		int csum_offset = 2;
+		int sz_opt = sizeof(int);
+
+		err = setsockopt(sock->fd, SOL_RAW, IPV6_CHECKSUM, &csum_offset, sz_opt);
+		if (err < 0) {
+			/* checksum should be enabled by default and setting this
+			 * option might fail anyway.
+			 */
+			fprintf(stderr, "setsockopt(RAW_CHECKSUM) failed - try to continue.");
+		}
+#endif
+
+		/*
+		 *	select icmp echo reply as icmp type to receive
+		 */
+
+		ICMP6_FILTER_SETBLOCKALL(&filter);
+
+		if (!sock->working_recverr) {
+			ICMP6_FILTER_SETPASS(ICMP6_DST_UNREACH, &filter);
+			ICMP6_FILTER_SETPASS(ICMP6_PACKET_TOO_BIG, &filter);
+			ICMP6_FILTER_SETPASS(ICMP6_TIME_EXCEEDED, &filter);
+			ICMP6_FILTER_SETPASS(ICMP6_PARAM_PROB, &filter);
+		}
+
+		if (niquery_is_enabled())
+			ICMP6_FILTER_SETPASS(ICMPV6_NI_REPLY, &filter);
+		else
+			ICMP6_FILTER_SETPASS(ICMP6_ECHO_REPLY, &filter);
+
+		err = setsockopt(sock->fd, IPPROTO_ICMPV6, ICMP6_FILTER, &filter, sizeof filter);
+
+		if (err < 0) {
+			perror("setsockopt(ICMP6_FILTER)");
+			exit(2);
+		}
+	}
+
+	if (options & F_NOLOOP) {
+		int loop = 0;
+		if (setsockopt(sock->fd, IPPROTO_IPV6, IPV6_MULTICAST_LOOP, &loop, sizeof loop) == -1) {
+			perror ("can't disable multicast loopback");
+			exit(2);
+		}
+	}
+	if (options & F_TTL) {
+		if (setsockopt(sock->fd, IPPROTO_IPV6, IPV6_MULTICAST_HOPS, &ttl, sizeof ttl) == -1) {
+			perror ("can't set multicast hop limit");
+			exit(2);
+		}
+		if (setsockopt(sock->fd, IPPROTO_IPV6, IPV6_UNICAST_HOPS, &ttl, sizeof ttl) == -1) {
+			perror ("can't set unicast hop limit");
+			exit(2);
+		}
+	}
+
+	const int on = 1;
+	if (
+#ifdef IPV6_RECVHOPLIMIT
+	    setsockopt(sock->fd, IPPROTO_IPV6, IPV6_RECVHOPLIMIT, &on, sizeof on) == -1 &&
+	    setsockopt(sock->fd, IPPROTO_IPV6, IPV6_2292HOPLIMIT, &on, sizeof on) == -1
+#else
+	    setsockopt(sock->fd, IPPROTO_IPV6, IPV6_HOPLIMIT, &on, sizeof on) == -1
+#endif
+	   ){
+		perror ("can't receive hop limit");
+		exit(2);
+	}
+
+	if (options & F_TCLASS) {
+#ifdef IPV6_TCLASS
+		if (setsockopt(sock->fd, IPPROTO_IPV6, IPV6_TCLASS, &tclass, sizeof tclass) == -1) {
+			perror ("setsockopt(IPV6_TCLASS)");
+			exit(2);
+		}
+#else
+		fprintf(stderr, "Traffic class is not supported.\n");
+#endif
+	}
+
+	if (options&F_FLOWINFO) {
+#ifdef IPV6_FLOWLABEL_MGR
+		char freq_buf[CMSG_ALIGN(sizeof(struct in6_flowlabel_req)) + cmsglen];
+		struct in6_flowlabel_req *freq = (struct in6_flowlabel_req *)freq_buf;
+		int freq_len = sizeof(*freq);
+#ifdef ENABLE_PING6_RTHDR
+		if (srcrt)
+			freq_len = CMSG_ALIGN(sizeof(*freq)) + srcrt->cmsg_len;
+#endif
+		memset(freq, 0, sizeof(*freq));
+		freq->flr_label = htonl(flowlabel & IPV6_FLOWINFO_FLOWLABEL);
+		freq->flr_action = IPV6_FL_A_GET;
+		freq->flr_flags = IPV6_FL_F_CREATE;
+		freq->flr_share = IPV6_FL_S_EXCL;
+		memcpy(&freq->flr_dst, &whereto.sin6_addr, 16);
+#ifdef ENABLE_PING6_RTHDR
+		if (srcrt)
+			memcpy(freq_buf + CMSG_ALIGN(sizeof(*freq)), srcrt, srcrt->cmsg_len);
+#endif
+		if (setsockopt(sock->fd, IPPROTO_IPV6, IPV6_FLOWLABEL_MGR, freq, freq_len) == -1) {
+			perror ("can't set flowlabel");
+			exit(2);
+		}
+		flowlabel = freq->flr_label;
+#ifdef ENABLE_PING6_RTHDR
+		if (srcrt) {
+			cmsglen = (char*)srcrt - (char*)cmsgbuf;
+			srcrt = NULL;
+		}
+#endif
+#else
+		fprintf(stderr, "Flow labels are not supported.\n");
+		exit(2);
+#endif
+
+#ifdef IPV6_FLOWINFO_SEND
+		whereto.sin6_flowinfo = flowlabel;
+		if (setsockopt(sock->fd, IPPROTO_IPV6, IPV6_FLOWINFO_SEND, &on, sizeof on) == -1) {
+			perror ("can't send flowinfo");
+			exit(2);
+		}
+#else
+		fprintf(stderr, "Flowinfo is not supported.\n");
+		exit(2);
+#endif
+	}
+
+	printf("PING %s(%s) ", hostname, pr_addr(&whereto, sizeof whereto));
+	if (flowlabel)
+		printf(", flow 0x%05x, ", (unsigned)ntohl(flowlabel));
+	if (device || (options&F_STRICTSOURCE)) {
+		int saved_options = options;
+
+		options |= F_NUMERIC;
+		printf("from %s %s: ", pr_addr(&source6, sizeof source6), device ? : "");
+		options = saved_options;
+	}
+	printf("%d data bytes\n", datalen);
+
+	setup(sock);
+
+	drop_capabilities();
+
+	main_loop(&ping6_func_set, sock, packet, packlen);
+}
+
+int ping6_receive_error_msg(socket_st *sock)
+{
+	int res;
+	char cbuf[512];
+	struct iovec  iov;
+	struct msghdr msg;
+	struct cmsghdr *cmsg;
+	struct sock_extended_err *e;
+	struct icmp6_hdr icmph;
+	struct sockaddr_in6 target;
+	int net_errors = 0;
+	int local_errors = 0;
+	int saved_errno = errno;
+
+	iov.iov_base = &icmph;
+	iov.iov_len = sizeof(icmph);
+	msg.msg_name = (void*)&target;
+	msg.msg_namelen = sizeof(target);
+	msg.msg_iov = &iov;
+	msg.msg_iovlen = 1;
+	msg.msg_flags = 0;
+	msg.msg_control = cbuf;
+	msg.msg_controllen = sizeof(cbuf);
+
+	res = recvmsg(sock->fd, &msg, MSG_ERRQUEUE|MSG_DONTWAIT);
+	if (res < 0)
+		goto out;
+
+	e = NULL;
+	for (cmsg = CMSG_FIRSTHDR(&msg); cmsg; cmsg = CMSG_NXTHDR(&msg, cmsg)) {
+		if (cmsg->cmsg_level == IPPROTO_IPV6) {
+			if (cmsg->cmsg_type == IPV6_RECVERR)
+				e = (struct sock_extended_err *)CMSG_DATA(cmsg);
+		}
+	}
+	if (e == NULL)
+		abort();
+
+	if (e->ee_origin == SO_EE_ORIGIN_LOCAL) {
+		local_errors++;
+		if (options & F_QUIET)
+			goto out;
+		if (options & F_FLOOD)
+			write_stdout("E", 1);
+		else if (e->ee_errno != EMSGSIZE)
+			fprintf(stderr, "ping: local error: %s\n", strerror(e->ee_errno));
+		else
+			fprintf(stderr, "ping: local error: Message too long, mtu=%u\n", e->ee_info);
+		nerrors++;
+	} else if (e->ee_origin == SO_EE_ORIGIN_ICMP6) {
+		struct sockaddr_in6 *sin6 = (struct sockaddr_in6*)(e+1);
+
+		if (res < sizeof(icmph) ||
+		    memcmp(&target.sin6_addr, &whereto.sin6_addr, 16) ||
+		    icmph.icmp6_type != ICMP6_ECHO_REQUEST ||
+		    !is_ours(sock, icmph.icmp6_id)) {
+			/* Not our error, not an error at all. Clear. */
+			saved_errno = 0;
+			goto out;
+		}
+
+		net_errors++;
+		nerrors++;
+		if (options & F_QUIET)
+			goto out;
+		if (options & F_FLOOD) {
+			write_stdout("\bE", 2);
+		} else {
+			print_timestamp();
+			printf("From %s icmp_seq=%u ", pr_addr(sin6, sizeof *sin6), ntohs(icmph.icmp6_seq));
+			pr_icmph(e->ee_type, e->ee_code, e->ee_info);
+			putchar('\n');
+			fflush(stdout);
+		}
+	}
+
+out:
+	errno = saved_errno;
+	return net_errors ? : -local_errors;
+}
+
+/*
+ * pinger --
+ * 	Compose and transmit an ICMP ECHO REQUEST packet.  The IP packet
+ * will be added on by the kernel.  The ID field is our UNIX process ID,
+ * and the sequence number is an ascending integer.  The first 8 bytes
+ * of the data portion are used to hold a UNIX "timeval" struct in VAX
+ * byte-order, to compute the round-trip time.
+ */
+int build_echo(__u8 *_icmph, unsigned packet_size)
+{
+	struct icmp6_hdr *icmph;
+	int cc;
+
+	icmph = (struct icmp6_hdr *)_icmph;
+	icmph->icmp6_type = ICMP6_ECHO_REQUEST;
+	icmph->icmp6_code = 0;
+	icmph->icmp6_cksum = 0;
+	icmph->icmp6_seq = htons(ntransmitted+1);
+	icmph->icmp6_id = ident;
+
+	if (timing)
+		gettimeofday((struct timeval *)&_icmph[8],
+		    (struct timezone *)NULL);
+
+	cc = datalen + 8;			/* skips ICMP portion */
+
+	return cc;
+}
+
+
+int build_niquery(__u8 *_nih, unsigned packet_size)
+{
+	struct ni_hdr *nih;
+	int cc;
+
+	nih = (struct ni_hdr *)_nih;
+	nih->ni_cksum = 0;
+
+	nih->ni_type = ICMPV6_NI_QUERY;
+	cc = sizeof(*nih);
+	datalen = 0;
+
+	niquery_fill_nonce(ntransmitted + 1, nih->ni_nonce);
+	nih->ni_code = ni_subject_type;
+	nih->ni_qtype = htons(ni_query);
+	nih->ni_flags = ni_flag;
+	memcpy(nih + 1, ni_subject, ni_subject_len);
+	cc += ni_subject_len;
+
+	return cc;
+}
+
+int ping6_send_probe(socket_st *sock, void *packet, unsigned packet_size)
+{
+	int len, cc;
+
+	rcvd_clear(ntransmitted + 1);
+
+	if (niquery_is_enabled())
+		len = build_niquery(packet, packet_size);
+	else
+		len = build_echo(packet, packet_size);
+
+	if (cmsglen == 0) {
+		cc = sendto(sock->fd, (char *)packet, len, confirm,
+			    (struct sockaddr *) &whereto,
+			    sizeof(struct sockaddr_in6));
+	} else {
+		struct msghdr mhdr;
+		struct iovec iov;
+
+		iov.iov_len  = len;
+		iov.iov_base = packet;
+
+		memset(&mhdr, 0, sizeof(mhdr));
+		mhdr.msg_name = &whereto;
+		mhdr.msg_namelen = sizeof(struct sockaddr_in6);
+		mhdr.msg_iov = &iov;
+		mhdr.msg_iovlen = 1;
+		mhdr.msg_control = cmsgbuf;
+		mhdr.msg_controllen = cmsglen;
+
+		cc = sendmsg(sock->fd, &mhdr, confirm);
+	}
+	confirm = 0;
+
+	return (cc == len ? 0 : cc);
+}
+
+void pr_echo_reply(__u8 *_icmph, int cc)
+{
+	struct icmp6_hdr *icmph = (struct icmp6_hdr *) _icmph;
+	printf(" icmp_seq=%u", ntohs(icmph->icmp6_seq));
+};
+
+static void putchar_safe(char c)
+{
+	if (isprint(c))
+		putchar(c);
+	else
+		printf("\\%03o", c);
+}
+
+static
+void pr_niquery_reply_name(struct ni_hdr *nih, int len)
+{
+	__u8 *h = (__u8 *)(nih + 1);
+	__u8 *p = h + 4;
+	__u8 *end = (__u8 *)nih + len;
+	int continued = 0;
+	char buf[1024];
+	int ret;
+
+	len -= sizeof(struct ni_hdr) + 4;
+
+	if (len < 0) {
+		printf(" parse error (too short)");
+		return;
+	}
+	while (p < end) {
+		int fqdn = 1;
+		int i;
+
+		memset(buf, 0xff, sizeof(buf));
+
+		if (continued)
+			putchar(',');
+
+		ret = dn_expand(h, end, p, buf, sizeof(buf));
+		if (ret < 0) {
+			printf(" parse error (truncated)");
+			break;
+		}
+		if (p + ret < end && *(p + ret) == '\0')
+			fqdn = 0;
+
+		putchar(' ');
+		for (i = 0; i < strlen(buf); i++)
+			putchar_safe(buf[i]);
+		if (fqdn)
+			putchar('.');
+
+		p += ret + !fqdn;
+
+		continued = 1;
+	}
+}
+
+static
+void pr_niquery_reply_addr(struct ni_hdr *nih, int len)
+{
+	__u8 *h = (__u8 *)(nih + 1);
+	__u8 *p = h + 4;
+	__u8 *end = (__u8 *)nih + len;
+	int af;
+	int aflen;
+	int continued = 0;
+	int truncated;
+	char buf[1024];
+
+	switch (ntohs(nih->ni_qtype)) {
+	case NI_QTYPE_IPV4ADDR:
+		af = AF_INET;
+		aflen = sizeof(struct in_addr);
+		truncated = nih->ni_flags & NI_IPV6ADDR_F_TRUNCATE;
+		break;
+	case NI_QTYPE_IPV6ADDR:
+		af = AF_INET6;
+		aflen = sizeof(struct in6_addr);
+		truncated = nih->ni_flags & NI_IPV4ADDR_F_TRUNCATE;
+		break;
+	default:
+		/* should not happen */
+		af = aflen = truncated = 0;
+	}
+	p = h;
+	if (len < 0) {
+		printf(" parse error (too short)");
+		return;
+	}
+
+	while (p < end) {
+		if (continued)
+			putchar(',');
+
+		if (p + sizeof(__u32) + aflen > end) {
+			printf(" parse error (truncated)");
+			break;
+		}
+		if (!inet_ntop(af, p + sizeof(__u32), buf, sizeof(buf)))
+			printf(" unexpeced error in inet_ntop(%s)",
+			       strerror(errno));
+		else
+			printf(" %s", buf);
+		p += sizeof(__u32) + aflen;
+
+		continued = 1;
+	}
+	if (truncated)
+		printf(" (truncated)");
+}
+
+static
+void pr_niquery_reply(__u8 *_nih, int len)
+{
+	struct ni_hdr *nih = (struct ni_hdr *)_nih;
+
+	switch (nih->ni_code) {
+	case NI_SUCCESS:
+		switch (ntohs(nih->ni_qtype)) {
+		case NI_QTYPE_NAME:
+			pr_niquery_reply_name(nih, len);
+			break;
+		case NI_QTYPE_IPV4ADDR:
+		case NI_QTYPE_IPV6ADDR:
+			pr_niquery_reply_addr(nih, len);
+			break;
+		default:
+			printf(" unknown qtype(0x%02x)", ntohs(nih->ni_qtype));
+		}
+		break;
+	case NI_REFUSED:
+		printf(" refused");
+		break;
+	case NI_UNKNOWN:
+		printf(" unknown");
+		break;
+	default:
+		printf(" unknown code(%02x)", ntohs(nih->ni_code));
+	}
+	printf("; seq=%u;", ntohsp((__u16*)nih->ni_nonce));
+}
+
+/*
+ * parse_reply --
+ *	Print out the packet, if it came from us.  This logic is necessary
+ * because ALL readers of the ICMP socket get a copy of ALL ICMP packets
+ * which arrive ('tis only fair).  This permits multiple copies of this
+ * program to be run without having intermingled output (or statistics!).
+ */
+int
+ping6_parse_reply(socket_st *sock, struct msghdr *msg, int cc, void *addr, struct timeval *tv)
+{
+	struct sockaddr_in6 *from = addr;
+	__u8 *buf = msg->msg_iov->iov_base;
+	struct cmsghdr *c;
+	struct icmp6_hdr *icmph;
+	int hops = -1;
+
+	for (c = CMSG_FIRSTHDR(msg); c; c = CMSG_NXTHDR(msg, c)) {
+		if (c->cmsg_level != IPPROTO_IPV6)
+			continue;
+		switch(c->cmsg_type) {
+		case IPV6_HOPLIMIT:
+#ifdef IPV6_2292HOPLIMIT
+		case IPV6_2292HOPLIMIT:
+#endif
+			if (c->cmsg_len < CMSG_LEN(sizeof(int)))
+				continue;
+			memcpy(&hops, CMSG_DATA(c), sizeof(hops));
+		}
+	}
+
+
+	/* Now the ICMP part */
+
+	icmph = (struct icmp6_hdr *) buf;
+	if (cc < 8) {
+		if (options & F_VERBOSE)
+			fprintf(stderr, "ping: packet too short (%d bytes)\n", cc);
+		return 1;
+	}
+
+	if (icmph->icmp6_type == ICMP6_ECHO_REPLY) {
+		if (!is_ours(sock, icmph->icmp6_id))
+			return 1;
+		if (gather_statistics((__u8*)icmph, sizeof(*icmph), cc,
+				      ntohs(icmph->icmp6_seq),
+				      hops, 0, tv, pr_addr(from, sizeof *from),
+				      pr_echo_reply)) {
+			fflush(stdout);
+			return 0;
+		}
+	} else if (icmph->icmp6_type == ICMPV6_NI_REPLY) {
+		struct ni_hdr *nih = (struct ni_hdr *)icmph;
+		int seq = niquery_check_nonce(nih->ni_nonce);
+		if (seq < 0)
+			return 1;
+		if (gather_statistics((__u8*)icmph, sizeof(*icmph), cc,
+				      seq,
+				      hops, 0, tv, pr_addr(from, sizeof *from),
+				      pr_niquery_reply))
+			return 0;
+	} else {
+		int nexthdr;
+		struct ip6_hdr *iph1 = (struct ip6_hdr*)(icmph+1);
+		struct icmp6_hdr *icmph1 = (struct icmp6_hdr *)(iph1+1);
+
+		/* We must not ever fall here. All the messages but
+		 * echo reply are blocked by filter and error are
+		 * received with IPV6_RECVERR. Ugly code is preserved
+		 * however, just to remember what crap we avoided
+		 * using RECVRERR. :-)
+		 */
+
+		if (cc < 8+sizeof(struct ip6_hdr)+8)
+			return 1;
+
+		if (memcmp(&iph1->ip6_dst, &whereto.sin6_addr, 16))
+			return 1;
+
+		nexthdr = iph1->ip6_nxt;
+
+		if (nexthdr == 44) {
+			nexthdr = *(__u8*)icmph1;
+			icmph1++;
+		}
+		if (nexthdr == IPPROTO_ICMPV6) {
+			if (icmph1->icmp6_type != ICMP6_ECHO_REQUEST ||
+			    !is_ours(sock, icmph1->icmp6_id))
+				return 1;
+			acknowledge(ntohs(icmph1->icmp6_seq));
+			if (sock->working_recverr)
+				return 0;
+			nerrors++;
+			if (options & F_FLOOD) {
+				write_stdout("\bE", 2);
+				return 0;
+			}
+			print_timestamp();
+			printf("From %s: icmp_seq=%u ", pr_addr(from, sizeof *from), ntohs(icmph1->icmp6_seq));
+		} else {
+			/* We've got something other than an ECHOREPLY */
+			if (!(options & F_VERBOSE) || uid)
+				return 1;
+			print_timestamp();
+			printf("From %s: ", pr_addr(from, sizeof *from));
+		}
+		pr_icmph(icmph->icmp6_type, icmph->icmp6_code, ntohl(icmph->icmp6_mtu));
+	}
+
+	if (options & F_AUDIBLE) {
+		putchar('\a');
+		if(options & F_FLOOD)
+			fflush(stdout);
+	}
+	if (!(options & F_FLOOD)) {
+		putchar('\n');
+		fflush(stdout);
+	}
+	return 0;
+}
+
+
+int pr_icmph(__u8 type, __u8 code, __u32 info)
+{
+	switch(type) {
+	case ICMP6_DST_UNREACH:
+		printf("Destination unreachable: ");
+		switch (code) {
+		case ICMP6_DST_UNREACH_NOROUTE:
+			printf("No route");
+			break;
+		case ICMP6_DST_UNREACH_ADMIN:
+			printf("Administratively prohibited");
+			break;
+		case ICMP6_DST_UNREACH_BEYONDSCOPE:
+			printf("Beyond scope of source address");
+			break;
+		case ICMP6_DST_UNREACH_ADDR:
+			printf("Address unreachable");
+			break;
+		case ICMP6_DST_UNREACH_NOPORT:
+			printf("Port unreachable");
+			break;
+		default:
+			printf("Unknown code %d", code);
+			break;
+		}
+		break;
+	case ICMP6_PACKET_TOO_BIG:
+		printf("Packet too big: mtu=%u", info);
+		if (code)
+			printf(", code=%d", code);
+		break;
+	case ICMP6_TIME_EXCEEDED:
+		printf("Time exceeded: ");
+		if (code == ICMP6_TIME_EXCEED_TRANSIT)
+			printf("Hop limit");
+		else if (code == ICMP6_TIME_EXCEED_REASSEMBLY)
+			printf("Defragmentation failure");
+		else
+			printf("code %d", code);
+		break;
+	case ICMP6_PARAM_PROB:
+		printf("Parameter problem: ");
+		if (code == ICMP6_PARAMPROB_HEADER)
+			printf("Wrong header field ");
+		else if (code == ICMP6_PARAMPROB_NEXTHEADER)
+			printf("Unknown header ");
+		else if (code == ICMP6_PARAMPROB_OPTION)
+			printf("Unknown option ");
+		else
+			printf("code %d ", code);
+		printf ("at %u", info);
+		break;
+	case ICMP6_ECHO_REQUEST:
+		printf("Echo request");
+		break;
+	case ICMP6_ECHO_REPLY:
+		printf("Echo reply");
+		break;
+	case MLD_LISTENER_QUERY:
+		printf("MLD Query");
+		break;
+	case MLD_LISTENER_REPORT:
+		printf("MLD Report");
+		break;
+	case MLD_LISTENER_REDUCTION:
+		printf("MLD Reduction");
+		break;
+	default:
+		printf("unknown icmp type: %u", type);
+
+	}
+	return 0;
+}
+
+void ping6_install_filter(socket_st *sock)
+{
+	static int once;
+	static struct sock_filter insns[] = {
+		BPF_STMT(BPF_LD|BPF_H|BPF_ABS, 4),  /* Load icmp echo ident */
+		BPF_JUMP(BPF_JMP|BPF_JEQ|BPF_K, 0xAAAA, 0, 1),  /* Ours? */
+		BPF_STMT(BPF_RET|BPF_K, ~0U),  /* Yes, it passes. */
+		BPF_STMT(BPF_LD|BPF_B|BPF_ABS, 0),  /* Load icmp type */
+		BPF_JUMP(BPF_JMP|BPF_JEQ|BPF_K, ICMP6_ECHO_REPLY, 1, 0), /* Echo? */
+		BPF_STMT(BPF_RET|BPF_K, ~0U), /* No. It passes. This must not happen. */
+		BPF_STMT(BPF_RET|BPF_K, 0), /* Echo with wrong ident. Reject. */
+	};
+	static struct sock_fprog filter = {
+		sizeof insns / sizeof(insns[0]),
+		insns
+	};
+
+	if (once)
+		return;
+	once = 1;
+
+	/* Patch bpflet for current identifier. */
+	insns[1] = (struct sock_filter)BPF_JUMP(BPF_JMP|BPF_JEQ|BPF_K, htons(ident), 0, 1);
+
+	if (setsockopt(sock->fd, SOL_SOCKET, SO_ATTACH_FILTER, &filter, sizeof(filter)))
+		perror("WARNING: failed to install socket filter\n");
+}
+
+#define USAGE_NEWLINE	"\n            "
+
+void ping6_usage(unsigned from_ping)
+{
+	const char *name;
+	if (from_ping)
+		name = "ping -6";
+	else
+		name = "ping6";
+	fprintf(stderr,
+		"Usage: %s"
+		" [-"
+			"aAbBdDfhLnOqrRUvV"
+		"]"
+		" [-c count]"
+		" [-i interval]"
+		" [-I interface]"
+		USAGE_NEWLINE
+		" [-l preload]"
+		" [-m mark]"
+		" [-M pmtudisc_option]"
+		USAGE_NEWLINE
+		" [-N nodeinfo_option]"
+		" [-p pattern]"
+		" [-Q tclass]"
+		" [-s packetsize]"
+		USAGE_NEWLINE
+		" [-S sndbuf]"
+		" [-t ttl]"
+		" [-T timestamp_option]"
+		" [-w deadline]"
+		USAGE_NEWLINE
+		" [-W timeout]"
+#ifdef ENABLE_PING6_RTHDR
+		" [hop1 ...]"
+#endif
+		" destination"
+		"\n", name
+	);
+	exit(2);
+}
diff -Naur iputils-s20151218.orig/ping6_niquery.h iputils-s20151218/ping6_niquery.h
--- iputils-s20151218.orig/ping6_niquery.h	2015-12-17 15:45:51.000000000 +0000
+++ iputils-s20151218/ping6_niquery.h	1970-01-01 00:00:00.000000000 +0000
@@ -1,49 +0,0 @@
-#include <asm/byteorder.h>
-
-#define NI_NONCE_SIZE			8
-
-/* Node Information Query */
-struct ni_hdr {
-	struct icmp6_hdr		ni_u;
-	__u8				ni_nonce[NI_NONCE_SIZE];
-};
-
-#define ni_type		ni_u.icmp6_type
-#define ni_code		ni_u.icmp6_code
-#define ni_cksum	ni_u.icmp6_cksum
-#define ni_qtype	ni_u.icmp6_data16[0]
-#define ni_flags	ni_u.icmp6_data16[1]
-
-/* Types */
-#ifndef ICMPV6_NI_QUERY
-# define ICMPV6_NI_QUERY		139
-# define ICMPV6_NI_REPLY		140
-#endif
-
-/* Query Codes */
-#define NI_SUBJ_IPV6			0
-#define NI_SUBJ_NAME			1
-#define NI_SUBJ_IPV4			2
-
-/* Reply Codes */
-#define NI_SUCCESS			0
-#define NI_REFUSED			1
-#define NI_UNKNOWN			2
-
-/* Qtypes */
-#define NI_QTYPE_NOOP			0
-#define NI_QTYPE_NAME			2
-#define NI_QTYPE_IPV6ADDR		3
-#define NI_QTYPE_IPV4ADDR		4
-
-/* Flags */
-#define NI_IPV6ADDR_F_TRUNCATE		__constant_cpu_to_be16(0x0001)
-#define NI_IPV6ADDR_F_ALL		__constant_cpu_to_be16(0x0002)
-#define NI_IPV6ADDR_F_COMPAT		__constant_cpu_to_be16(0x0004)
-#define NI_IPV6ADDR_F_LINKLOCAL		__constant_cpu_to_be16(0x0008)
-#define NI_IPV6ADDR_F_SITELOCAL		__constant_cpu_to_be16(0x0010)
-#define NI_IPV6ADDR_F_GLOBAL		__constant_cpu_to_be16(0x0020)
-
-#define NI_IPV4ADDR_F_TRUNCATE		NI_IPV6ADDR_F_TRUNCATE
-#define NI_IPV4ADDR_F_ALL		NI_IPV6ADDR_F_ALL
-
diff -Naur iputils-s20151218.orig/ping.c iputils-s20151218/ping.c
--- iputils-s20151218.orig/ping.c	2015-12-17 15:45:51.000000000 +0000
+++ iputils-s20151218/ping.c	2016-05-17 23:17:09.000000000 +0000
@@ -33,13 +33,6 @@
  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
  * SUCH DAMAGE.
  */
-
-#ifndef lint
-char copyright[] =
-"@(#) Copyright (c) 1989 The Regents of the University of California.\n\
- All rights reserved.\n";
-#endif /* not lint */
-
 /*
  *			P I N G . C
  *
@@ -60,7 +53,7 @@
  *	net_cap_raw enabled.
  */
 
-#include "ping_common.h"
+#include "ping.h"
 
 #include <netinet/ip.h>
 #include <netinet/ip_icmp.h>
@@ -75,35 +68,32 @@
 };
 #endif
 
+ping_func_set_st ping4_func_set = {
+	.send_probe = ping4_send_probe,
+	.receive_error_msg = ping4_receive_error_msg,
+	.parse_reply = ping4_parse_reply,
+	.install_filter = ping4_install_filter
+};
 
 #define	MAXIPLEN	60
 #define	MAXICMPLEN	76
 #define	NROUTES		9		/* number of record route slots */
 #define TOS_MAX		255		/* 8-bit TOS field */
-#define MAX_HOSTNAMELEN	NI_MAXHOST
-
 
 static int ts_type;
 static int nroute = 0;
 static __u32 route[10];
 
-
-
-struct sockaddr_in whereto;	/* who to ping */
-int optlen = 0;
-int settos = 0;			/* Set TOS, Precendence or other QOS options */
-int icmp_sock;			/* socket file descriptor */
-extern int using_ping_socket;
-u_char outpack[0x10000];
-int maxpacket = sizeof(outpack);
+static struct sockaddr_in whereto;	/* who to ping */
+static int optlen = 0;
+static int settos = 0;			/* Set TOS, Precendence or other QOS options */
 
 static int broadcast_pings = 0;
 
-static char *pr_addr(__u32);
 static void pr_options(unsigned char * cp, int hlen);
 static void pr_iph(struct iphdr *ip);
 static void usage(void) __attribute__((noreturn));
-static u_short in_cksum(const u_short *addr, int len, u_short salt);
+static unsigned short in_cksum(const unsigned short *addr, int len, unsigned short salt);
 static void pr_icmph(__u8 type, __u8 code, __u32 info, struct icmphdr *icp);
 static int parsetos(char *str);
 
@@ -114,25 +104,56 @@
 	   {0, }};
 int cmsg_len;
 
-struct sockaddr_in source;
-char *device;
-int pmtudisc = -1;
+static struct sockaddr_in source = { .sin_family = AF_INET };
+static char *device;
+static int pmtudisc = -1;
+
+static void create_socket(socket_st *sock, int family, int socktype, int protocol, int requisite)
+{
+	errno = 0;
+
+	sock->fd = socket(family, socktype, protocol);
+
+	/* Attempt creating a raw socket when ping socket failed */
+	if (sock->fd == -1 && errno != EAFNOSUPPORT && socktype == SOCK_DGRAM) {
+		if (options & F_VERBOSE)
+			fprintf(stderr, "ping: socket: %s, attempting raw socket...\n", strerror(errno));
+		create_socket(sock, family, SOCK_RAW, protocol, requisite);
+		return;
+	}
+
+	if (sock->fd == -1) {
+		if (requisite || errno != EAFNOSUPPORT || options & F_VERBOSE)
+			fprintf(stderr, "ping: socket: %s\n", strerror(errno));
+		if (requisite)
+			exit(2);
+		return;
+	}
 
+	sock->socktype = socktype;
+}
+
+static void set_socket_option(socket_st *sock, int level, int optname, const void *optval, socklen_t optlen)
+{
+	if (sock->fd == -1)
+		return;
+
+	if (setsockopt(sock->fd, level, optname, optval, optlen) == -1) {
+		fprintf(stderr, "ping: setsockopt: %s\n", strerror(errno));
+		exit(2);
+	}
+}
 
 int
 main(int argc, char **argv)
 {
-	struct hostent *hp;
-	int ch, hold, packlen;
-	int socket_errno;
-	u_char *packet;
+	struct addrinfo hints = { .ai_family = AF_UNSPEC, .ai_protocol = IPPROTO_UDP, .ai_socktype = SOCK_DGRAM, .ai_flags = getaddrinfo_flags };
+	struct addrinfo *result, *ai;
+	int status;
+	int ch;
+	socket_st sock4 = { .fd = -1 };
+	socket_st sock6 = { .fd = -1 };
 	char *target;
-#ifdef USE_IDN
-	char *hnamebuf = NULL;
-#else
-	char hnamebuf[MAX_HOSTNAMELEN];
-#endif
-	char rspace[3 + 4 * NROUTES + 1];	/* record route space */
 
 	limit_capabilities();
 
@@ -140,34 +161,25 @@
 	setlocale(LC_ALL, "");
 #endif
 
-	enable_capability_raw();
-	icmp_sock = socket(AF_INET, SOCK_RAW, IPPROTO_ICMP);
-	disable_capability_raw();
-
-	if (icmp_sock < 0) {
-		icmp_sock = socket(AF_INET, SOCK_DGRAM, IPPROTO_ICMP);
-		using_ping_socket = 1;
-		working_recverr = 1;
-	}
-	socket_errno = errno;
-
+	/* Support being called using `ping4` or `ping6` symlinks */
+	if (argv[0][strlen(argv[0])-1] == '4')
+		hints.ai_family = AF_INET;
+	else if (argv[0][strlen(argv[0])-1] == '6')
+		hints.ai_family = AF_INET6;
 
-	source.sin_family = AF_INET;
-
-	preload = 1;
-	while ((ch = getopt(argc, argv, COMMON_OPTSTR "bRT:")) != EOF) {
+	/* Parse command line options */
+	while ((ch = getopt(argc, argv, "h?" "4bRT:" "6F:N:" "aABc:dDfi:I:l:Lm:M:nOp:qQ:rs:S:t:UvVw:W:")) != EOF) {
 		switch(ch) {
-		case 'b':
-			broadcast_pings = 1;
-			break;
-		case 'Q':
-			settos = parsetos(optarg);
-			if (settos &&
-			    (setsockopt(icmp_sock, IPPROTO_IP, IP_TOS,
-					(char *)&settos, sizeof(int)) < 0)) {
-				perror("ping: error setting QOS sockopts");
+		/* IPv4 specific options */
+		case '4':
+			if (hints.ai_family != AF_UNSPEC) {
+				fprintf(stderr, "ping: Only one -4 or -6 option may be specified\n");
 				exit(2);
 			}
+			hints.ai_family = AF_INET;
+			break;
+		case 'b':
+			broadcast_pings = 1;
 			break;
 		case 'R':
 			if (options & F_TIMESTAMP) {
@@ -193,30 +205,132 @@
 				exit(2);
 			}
 			break;
-		case 'I':
+		/* IPv6 specific options */
+		case '6':
+			if (hints.ai_family != AF_UNSPEC) {
+				fprintf(stderr, "ping: Only one -4 or -6 option may be specified\n");
+				exit(2);
+			}
+			hints.ai_family = AF_INET6;
+			break;
+		case 'F':
+			flowlabel = hextoui(optarg);
+			if (errno || (flowlabel & ~IPV6_FLOWINFO_FLOWLABEL)) {
+				fprintf(stderr, "ping: Invalid flowinfo %s\n", optarg);
+				exit(2);
+			}
+			options |= F_FLOWINFO;
+			break;
+		case 'N':
+			if (niquery_option_handler(optarg) < 0) {
+				ping6_usage(0);
+				exit(2);
+			}
+			hints.ai_socktype = SOCK_RAW;
+			break;
+		/* Common options */
+		case 'a':
+			options |= F_AUDIBLE;
+			break;
+		case 'A':
+			options |= F_ADAPTIVE;
+			break;
+		case 'B':
+			options |= F_STRICTSOURCE;
+			break;
+		case 'c':
+			npackets = atoi(optarg);
+			if (npackets <= 0) {
+				fprintf(stderr, "ping: bad number of packets to transmit.\n");
+				exit(2);
+			}
+			break;
+		case 'd':
+			options |= F_SO_DEBUG;
+			break;
+		case 'D':
+			options |= F_PTIMEOFDAY;
+			break;
+		case 'i':
 		{
-#if 0
-			char dummy;
-			int i1, i2, i3, i4;
-
-			if (sscanf(optarg, "%u.%u.%u.%u%c",
-				   &i1, &i2, &i3, &i4, &dummy) == 4) {
-				__u8 *ptr;
-				ptr = (__u8*)&source.sin_addr;
-				ptr[0] = i1;
-				ptr[1] = i2;
-				ptr[2] = i3;
-				ptr[3] = i4;
+			double dbl;
+			char *ep;
+
+			errno = 0;
+#ifdef USE_IDN
+			setlocale(LC_ALL, "C");
+#endif
+			dbl = strtod(optarg, &ep);
+#ifdef USE_IDN
+			setlocale(LC_ALL, "");
+#endif
+
+			if (errno || *ep != '\0' ||
+				!finite(dbl) || dbl < 0.0 || dbl >= (double)INT_MAX / 1000 - 1.0) {
+				fprintf(stderr, "ping: bad timing interval\n");
+				exit(2);
+			}
+
+			interval = (int)(dbl * 1000);
+
+			options |= F_INTERVAL;
+			break;
+		}
+		case 'I':
+			/* IPv6 */
+			if (strchr(optarg, ':')) {
+				char *p, *addr = strdup(optarg);
+
+				if (!addr) {
+					fprintf(stderr, "ping: out of memory\n");
+					exit(2);
+				}
+
+				p = strchr(addr, SCOPE_DELIMITER);
+				if (p) {
+					*p = '\0';
+					device = optarg + (p - addr) + 1;
+				}
+
+				if (inet_pton(AF_INET6, addr, (char*)&source6.sin6_addr) <= 0) {
+					fprintf(stderr, "ping: invalid source address %s\n", optarg);
+					exit(2);
+				}
+
+				options |= F_STRICTSOURCE;
+
+				free(addr);
+			} else if (inet_pton(AF_INET, optarg, &source.sin_addr) > 0) {
 				options |= F_STRICTSOURCE;
 			} else {
 				device = optarg;
 			}
-#else
-			if (inet_pton(AF_INET, optarg, &source.sin_addr) > 0)
-				options |= F_STRICTSOURCE;
-			else
-				device = optarg;
-#endif
+			break;
+		case 'l':
+			preload = atoi(optarg);
+			if (preload <= 0) {
+				fprintf(stderr, "ping: bad preload value, should be 1..%d\n", MAX_DUP_CHK);
+				exit(2);
+			}
+			if (preload > MAX_DUP_CHK)
+				preload = MAX_DUP_CHK;
+			if (uid && preload > 3) {
+				fprintf(stderr, "ping: cannot set preload to value > 3\n");
+				exit(2);
+			}
+			break;
+		case 'L':
+			options |= F_NOLOOP;
+			break;
+		case 'm':
+		{
+			char *endp;
+			mark = (int)strtoul(optarg, &endp, 10);
+			if (mark < 0 || *endp != '\0') {
+				fprintf(stderr, "mark cannot be negative\n");
+				exit(2);
+			}
+			options |= F_MARK;
 			break;
 		}
 		case 'M':
@@ -231,21 +345,162 @@
 				exit(2);
 			}
 			break;
+		case 'n':
+			options |= F_NUMERIC;
+			break;
+		case 'O':
+			options |= F_OUTSTANDING;
+			break;
+		case 'f':
+			/* avoid `getaddrinfo()` during flood */
+			options |= F_FLOOD | F_NUMERIC;
+			setbuf(stdout, (char *)NULL);
+			break;
+		case 'p':
+			options |= F_PINGFILLED;
+			fill(optarg, outpack, sizeof(outpack));
+			break;
+		case 'q':
+			options |= F_QUIET;
+			break;
+		case 'Q':
+			/* IPv4 */
+			settos = parsetos(optarg);
+			/* IPv6 */
+			tclass = hextoui(optarg);
+			if (errno || (tclass & ~0xff)) {
+				fprintf(stderr, "ping: Invalid tclass %s\n", optarg);
+				exit(2);
+			}
+			break;
+		case 'r':
+			options |= F_SO_DONTROUTE;
+			break;
+		case 's':
+			datalen = atoi(optarg);
+			if (datalen < 0) {
+				fprintf(stderr, "ping: illegal negative packet size %d.\n", datalen);
+				exit(2);
+			}
+			if (datalen > MAXPACKET - 8) {
+				fprintf(stderr, "ping: packet size too large: %d\n",
+					datalen);
+				exit(2);
+			}
+			break;
+		case 'S':
+			sndbuf = atoi(optarg);
+			if (sndbuf <= 0) {
+				fprintf(stderr, "ping: bad sndbuf value.\n");
+				exit(2);
+			}
+			break;
+		case 't':
+			options |= F_TTL;
+			ttl = atoi(optarg);
+			if (ttl < 0 || ttl > 255) {
+				fprintf(stderr, "ping: ttl %u out of range\n", ttl);
+				exit(2);
+			}
+			break;
+		case 'U':
+			options |= F_LATENCY;
+			break;
+		case 'v':
+			options |= F_VERBOSE;
+			break;
 		case 'V':
 			printf("ping utility, iputils-%s\n", SNAPSHOT);
 			exit(0);
-		COMMON_OPTIONS
-			common_options(ch);
+		case 'w':
+			deadline = atoi(optarg);
+			if (deadline < 0) {
+				fprintf(stderr, "ping: bad wait time.\n");
+				exit(2);
+			}
+			break;
+		case 'W':
+			lingertime = atoi(optarg);
+			if (lingertime < 0 || lingertime > INT_MAX/1000000) {
+				fprintf(stderr, "ping: bad linger time.\n");
+				exit(2);
+			}
+			lingertime *= 1000;
 			break;
 		default:
 			usage();
+			break;
 		}
 	}
+
 	argc -= optind;
 	argv += optind;
 
-	if (argc == 0)
+	if (!argc)
 		usage();
+
+	target = argv[argc-1];
+
+	/* Create sockets */
+	enable_capability_raw();
+	if (hints.ai_family != AF_INET6)
+		create_socket(&sock4, AF_INET, hints.ai_socktype, IPPROTO_ICMP, hints.ai_family == AF_INET);
+	if (hints.ai_family != AF_INET)
+		create_socket(&sock6, AF_INET6, hints.ai_socktype, IPPROTO_ICMPV6, sock4.fd == -1);
+	disable_capability_raw();
+
+	/* Limit address family on single-protocol systems */
+	if (hints.ai_family == AF_UNSPEC) {
+		if (sock4.fd == -1)
+			hints.ai_family = AF_INET6;
+		else if (sock6.fd == -1)
+			hints.ai_family = AF_INET;
+	}
+
+	/* Set socket options */
+	if (settos)
+		set_socket_option(&sock4, IPPROTO_IP, IP_TOS, &settos, sizeof settos);
+	if (tclass)
+		set_socket_option(&sock6, IPPROTO_IPV6, IPV6_TCLASS, &tclass, sizeof tclass);
+
+	status = getaddrinfo(target, NULL, &hints, &result);
+	if (status) {
+		fprintf(stderr, "ping: %s: %s\n", target, gai_strerror(status));
+		exit(2);
+	}
+
+	for (ai = result; ai; ai = ai->ai_next) {
+		switch (ai->ai_family) {
+		case AF_INET:
+			status = ping4_run(argc, argv, ai, &sock4);
+			break;
+		case AF_INET6:
+			status = ping6_run(argc, argv, ai, &sock6);
+			break;
+		default:
+			fprintf(stderr, "ping: unknown protocol family: %d\n", ai->ai_family);
+			exit(2);
+		}
+
+		if (status == 0)
+			break;
+	}
+
+	freeaddrinfo(result);
+
+	return status;
+}
+
+int ping4_run(int argc, char **argv, struct addrinfo *ai, socket_st *sock)
+{
+	static const struct addrinfo hints = { .ai_family = AF_INET, .ai_protocol = IPPROTO_UDP, .ai_flags = getaddrinfo_flags };
+	int hold, packlen;
+	unsigned char *packet;
+	char *target;
+	char hnamebuf[NI_MAXHOST];
+	char rspace[3 + 4 * NROUTES + 1];	/* record route space */
+	__u32 *tmp_rspace;
+
 	if (argc > 1) {
 		if (options & F_RROUTE)
 			usage();
@@ -270,45 +525,26 @@
 			if (argc == 1)
 				options |= F_NUMERIC;
 		} else {
-			char *idn;
-#ifdef USE_IDN
-			int rc;
-
-			if (hnamebuf) {
-				free(hnamebuf);
-				hnamebuf = NULL;
-			}
+			struct addrinfo *result = NULL;
+			int status;
 
-			rc = idna_to_ascii_lz(target, &idn, 0);
-			if (rc != IDNA_SUCCESS) {
-				fprintf(stderr, "ping: IDN encoding failed: %s\n", idna_strerror(rc));
-				exit(2);
-			}
-#else
-			idn = target;
-#endif
-			hp = gethostbyname(idn);
-			if (!hp) {
-				fprintf(stderr, "ping: unknown host %s\n", target);
-				exit(2);
-			}
-#ifdef USE_IDN
-			free(idn);
-#endif
-			memcpy(&whereto.sin_addr, hp->h_addr, 4);
-#ifdef USE_IDN
-			if (idna_to_unicode_lzlz(hp->h_name, &hnamebuf, 0) != IDNA_SUCCESS) {
-				hnamebuf = strdup(hp->h_name);
-				if (!hnamebuf) {
-					perror("ping: strdup");
-					exit(-1);
+			if (argc > 1 || !ai) {
+				status = getaddrinfo(target, NULL, &hints, &result);
+				if (status) {
+					fprintf(stderr, "ping: %s: %s\n", target, gai_strerror(status));
+					exit(2);
 				}
+				ai = result;
 			}
-#else
-			strncpy(hnamebuf, hp->h_name, sizeof(hnamebuf) - 1);
-			hnamebuf[sizeof(hnamebuf) - 1] = 0;
-#endif
+
+			memcpy(&whereto, ai->ai_addr, sizeof whereto);
+			memset(hnamebuf, 0, sizeof hnamebuf);
+			if (ai->ai_canonname)
+				strncpy(hnamebuf, ai->ai_canonname, sizeof hnamebuf - 1);
 			hostname = hnamebuf;
+
+			if (result)
+				freeaddrinfo(result);
 		}
 		if (argc > 1)
 			route[nroute++] = whereto.sin_addr.s_addr;
@@ -420,18 +656,12 @@
 	if (whereto.sin_addr.s_addr == 0)
 		whereto.sin_addr.s_addr = source.sin_addr.s_addr;
 
-	if (icmp_sock < 0) {
-		errno = socket_errno;
-		perror("ping: icmp open socket");
-		exit(2);
-	}
-
 	if (device) {
 		struct ifreq ifr;
 
 		memset(&ifr, 0, sizeof(ifr));
 		strncpy(ifr.ifr_name, device, IFNAMSIZ-1);
-		if (ioctl(icmp_sock, SIOCGIFINDEX, &ifr) < 0) {
+		if (ioctl(sock->fd, SIOCGIFINDEX, &ifr) < 0) {
 			fprintf(stderr, "ping: unknown iface %s\n", device);
 			exit(2);
 		}
@@ -455,19 +685,19 @@
 	}
 
 	if (pmtudisc >= 0) {
-		if (setsockopt(icmp_sock, SOL_IP, IP_MTU_DISCOVER, &pmtudisc, sizeof(pmtudisc)) == -1) {
+		if (setsockopt(sock->fd, SOL_IP, IP_MTU_DISCOVER, &pmtudisc, sizeof pmtudisc) == -1) {
 			perror("ping: IP_MTU_DISCOVER");
 			exit(2);
 		}
 	}
 
 	if ((options&F_STRICTSOURCE) &&
-	    bind(icmp_sock, (struct sockaddr*)&source, sizeof(source)) == -1) {
+	    bind(sock->fd, (struct sockaddr *) &source, sizeof source) == -1) {
 		perror("bind");
 		exit(2);
 	}
 
-	if (!using_ping_socket) {
+	if (sock->socktype == SOCK_RAW) {
 		struct icmp_filter filt;
 		filt.data = ~((1<<ICMP_SOURCE_QUENCH)|
 			      (1<<ICMP_DEST_UNREACH)|
@@ -475,19 +705,18 @@
 			      (1<<ICMP_PARAMETERPROB)|
 			      (1<<ICMP_REDIRECT)|
 			      (1<<ICMP_ECHOREPLY));
-		if (setsockopt(icmp_sock, SOL_RAW, ICMP_FILTER, (char*)&filt, sizeof(filt)) == -1)
+		if (setsockopt(sock->fd, SOL_RAW, ICMP_FILTER, &filt, sizeof filt) == -1)
 			perror("WARNING: setsockopt(ICMP_FILTER)");
 	}
 
 	hold = 1;
-	if (setsockopt(icmp_sock, SOL_IP, IP_RECVERR, (char *)&hold, sizeof(hold)))
+	if (setsockopt(sock->fd, SOL_IP, IP_RECVERR, &hold, sizeof hold))
 		fprintf(stderr, "WARNING: your kernel is veeery old. No problems.\n");
-	if (using_ping_socket) {
-		if (setsockopt(icmp_sock, SOL_IP, IP_RECVTTL,
-		    (char *)&hold, sizeof(hold)))
+
+	if (sock->socktype == SOCK_DGRAM) {
+		if (setsockopt(sock->fd, SOL_IP, IP_RECVTTL, &hold, sizeof hold))
 			perror("WARNING: setsockopt(IP_RECVTTL)");
-		if (setsockopt(icmp_sock, SOL_IP, IP_RETOPTS,
-		    (char *)&hold, sizeof(hold)))
+		if (setsockopt(sock->fd, SOL_IP, IP_RETOPTS, &hold, sizeof hold))
 			perror("WARNING: setsockopt(IP_RETOPTS)");
 	}
 
@@ -499,7 +728,7 @@
 		rspace[1+IPOPT_OLEN] = sizeof(rspace)-1;
 		rspace[1+IPOPT_OFFSET] = IPOPT_MINOFF;
 		optlen = 40;
-		if (setsockopt(icmp_sock, IPPROTO_IP, IP_OPTIONS, rspace, sizeof(rspace)) < 0) {
+		if (setsockopt(sock->fd, IPPROTO_IP, IP_OPTIONS, rspace, sizeof rspace) < 0) {
 			perror("ping: record route");
 			exit(2);
 		}
@@ -513,12 +742,14 @@
 		if (ts_type == IPOPT_TS_PRESPEC) {
 			int i;
 			rspace[1] = 4+nroute*8;
-			for (i=0; i<nroute; i++)
-				*(__u32*)&rspace[4+i*8] = route[i];
+			for (i = 0; i < nroute; i++) {
+				tmp_rspace = (__u32*)&rspace[4+i*8];
+				*tmp_rspace = route[i];
+			}
 		}
-		if (setsockopt(icmp_sock, IPPROTO_IP, IP_OPTIONS, rspace, rspace[1]) < 0) {
+		if (setsockopt(sock->fd, IPPROTO_IP, IP_OPTIONS, rspace, rspace[1]) < 0) {
 			rspace[3] = 2;
-			if (setsockopt(icmp_sock, IPPROTO_IP, IP_OPTIONS, rspace, rspace[1]) < 0) {
+			if (setsockopt(sock->fd, IPPROTO_IP, IP_OPTIONS, rspace, rspace[1]) < 0) {
 				perror("ping: ts option");
 				exit(2);
 			}
@@ -533,10 +764,12 @@
 			: IPOPT_LSRR;
 		rspace[1+IPOPT_OLEN] = 3 + nroute*4;
 		rspace[1+IPOPT_OFFSET] = IPOPT_MINOFF;
-		for (i=0; i<nroute; i++)
-			*(__u32*)&rspace[4+i*4] = route[i];
+		for (i = 0; i < nroute; i++) {
+			tmp_rspace = (__u32*)&rspace[4+i*4];
+			*tmp_rspace = route[i];
+		}
 
-		if (setsockopt(icmp_sock, IPPROTO_IP, IP_OPTIONS, rspace, 4 + nroute*4) < 0) {
+		if (setsockopt(sock->fd, IPPROTO_IP, IP_OPTIONS, rspace, 4 + nroute*4) < 0) {
 			perror("ping: record route");
 			exit(2);
 		}
@@ -547,11 +780,10 @@
 	 * Actually, for small datalen's it depends on kernel side a lot. */
 	hold = datalen + 8;
 	hold += ((hold+511)/512)*(optlen + 20 + 16 + 64 + 160);
-	sock_setbufs(icmp_sock, hold);
+	sock_setbufs(sock, hold);
 
 	if (broadcast_pings) {
-		if (setsockopt(icmp_sock, SOL_SOCKET, SO_BROADCAST,
-			       &broadcast_pings, sizeof(broadcast_pings)) < 0) {
+		if (setsockopt(sock->fd, SOL_SOCKET, SO_BROADCAST, &broadcast_pings, sizeof broadcast_pings) < 0) {
 			perror ("ping: can't set broadcasting");
 			exit(2);
 		}
@@ -559,39 +791,32 @@
 
 	if (options & F_NOLOOP) {
 		int loop = 0;
-		if (setsockopt(icmp_sock, IPPROTO_IP, IP_MULTICAST_LOOP,
-							&loop, 1) == -1) {
+		if (setsockopt(sock->fd, IPPROTO_IP, IP_MULTICAST_LOOP, &loop, 1) == -1) {
 			perror ("ping: can't disable multicast loopback");
 			exit(2);
 		}
 	}
 	if (options & F_TTL) {
 		int ittl = ttl;
-		if (setsockopt(icmp_sock, IPPROTO_IP, IP_MULTICAST_TTL,
-							&ttl, 1) == -1) {
+		if (setsockopt(sock->fd, IPPROTO_IP, IP_MULTICAST_TTL, &ttl, 1) == -1) {
 			perror ("ping: can't set multicast time-to-live");
 			exit(2);
 		}
-		if (setsockopt(icmp_sock, IPPROTO_IP, IP_TTL,
-							&ittl, sizeof(ittl)) == -1) {
+		if (setsockopt(sock->fd, IPPROTO_IP, IP_TTL, &ittl, sizeof ittl) == -1) {
 			perror ("ping: can't set unicast time-to-live");
 			exit(2);
 		}
 	}
 
 	if (datalen > 0xFFFF - 8 - optlen - 20) {
-		if (uid || datalen > sizeof(outpack)-8) {
-			fprintf(stderr, "Error: packet size %d is too large. Maximum is %d\n", datalen, 0xFFFF-8-20-optlen);
-			exit(2);
-		}
-		/* Allow small oversize to root yet. It will cause EMSGSIZE. */
-		fprintf(stderr, "WARNING: packet size %d is too large. Maximum is %d\n", datalen, 0xFFFF-8-20-optlen);
+		fprintf(stderr, "Error: packet size %d is too large. Maximum is %d\n", datalen, 0xFFFF-8-20-optlen);
+		exit(2);
 	}
 
 	if (datalen >= sizeof(struct timeval))	/* can we time transfer */
 		timing = 1;
 	packlen = datalen + MAXIPLEN + MAXICMPLEN;
-	if (!(packet = (u_char *)malloc((u_int)packlen))) {
+	if (!(packet = (unsigned char *)malloc((unsigned int)packlen))) {
 		fprintf(stderr, "ping: out of memory.\n");
 		exit(2);
 	}
@@ -601,13 +826,13 @@
 		printf("from %s %s: ", inet_ntoa(source.sin_addr), device ?: "");
 	printf("%d(%d) bytes of data.\n", datalen, datalen+8+optlen+20);
 
-	setup(icmp_sock);
+	setup(sock);
 
-	main_loop(icmp_sock, packet, packlen);
+	main_loop(&ping4_func_set, sock, packet, packlen);
 }
 
 
-int receive_error_msg()
+int ping4_receive_error_msg(socket_st *sock)
 {
 	int res;
 	char cbuf[512];
@@ -631,7 +856,7 @@
 	msg.msg_control = cbuf;
 	msg.msg_controllen = sizeof(cbuf);
 
-	res = recvmsg(icmp_sock, &msg, MSG_ERRQUEUE|MSG_DONTWAIT);
+	res = recvmsg(sock->fd, &msg, MSG_ERRQUEUE|MSG_DONTWAIT);
 	if (res < 0)
 		goto out;
 
@@ -662,7 +887,7 @@
 		if (res < sizeof(icmph) ||
 		    target.sin_addr.s_addr != whereto.sin_addr.s_addr ||
 		    icmph.type != ICMP_ECHO ||
-		    !is_ours(icmph.un.echo.id)) {
+		    !is_ours(sock, icmph.un.echo.id)) {
 			/* Not our error, not an error at all. Clear. */
 			saved_errno = 0;
 			goto out;
@@ -670,14 +895,14 @@
 
 		acknowledge(ntohs(icmph.un.echo.sequence));
 
-		if (!using_ping_socket && !working_recverr) {
+		if (sock->socktype == SOCK_RAW && !sock->working_recverr) {
 			struct icmp_filter filt;
-			working_recverr = 1;
+			sock->working_recverr = 1;
 			/* OK, it works. Add stronger filter. */
-			filt.data = ~((1<<ICMP_SOURCE_QUENCH)|
-				      (1<<ICMP_REDIRECT)|
-				      (1<<ICMP_ECHOREPLY));
-			if (setsockopt(icmp_sock, SOL_RAW, ICMP_FILTER, (char*)&filt, sizeof(filt)) == -1)
+			filt.data = ~((1<<ICMP_SOURCE_QUENCH)|  
+					(1<<ICMP_REDIRECT)|
+					(1<<ICMP_ECHOREPLY));
+			if (setsockopt(sock->fd, SOL_RAW, ICMP_FILTER, (char*)&filt, sizeof(filt)) == -1)
 				perror("\rWARNING: setsockopt(ICMP_FILTER)");
 		}
 
@@ -689,7 +914,7 @@
 			write_stdout("\bE", 2);
 		} else {
 			print_timestamp();
-			printf("From %s icmp_seq=%u ", pr_addr(sin->sin_addr.s_addr), ntohs(icmph.un.echo.sequence));
+			printf("From %s icmp_seq=%u ", pr_addr(sin, sizeof *sin), ntohs(icmph.un.echo.sequence));
 			pr_icmph(e->ee_type, e->ee_code, e->ee_info, NULL);
 			fflush(stdout);
 		}
@@ -708,13 +933,13 @@
  * of the data portion are used to hold a UNIX "timeval" struct in VAX
  * byte-order, to compute the round-trip time.
  */
-int send_probe()
+int ping4_send_probe(socket_st *sock, void *packet, unsigned packet_size)
 {
 	struct icmphdr *icp;
 	int cc;
 	int i;
 
-	icp = (struct icmphdr *)outpack;
+	icp = (struct icmphdr *)packet;
 	icp->type = ICMP_ECHO;
 	icp->code = 0;
 	icp->checksum = 0;
@@ -736,25 +961,16 @@
 	cc = datalen + 8;			/* skips ICMP portion */
 
 	/* compute ICMP checksum here */
-	icp->checksum = in_cksum((u_short *)icp, cc, 0);
+	icp->checksum = in_cksum((unsigned short *)icp, cc, 0);
 
 	if (timing && !(options&F_LATENCY)) {
 		struct timeval tmp_tv;
 		gettimeofday(&tmp_tv, NULL);
 		memcpy(icp+1, &tmp_tv, sizeof(tmp_tv));
-		icp->checksum = in_cksum((u_short *)&tmp_tv, sizeof(tmp_tv), ~icp->checksum);
+		icp->checksum = in_cksum((unsigned short *)&tmp_tv, sizeof(tmp_tv), ~icp->checksum);
 	}
 
-	do {
-		static struct iovec iov = {outpack, 0};
-		static struct msghdr m = { &whereto, sizeof(whereto),
-						   &iov, 1, &cmsg, 0, 0 };
-		m.msg_controllen = cmsg_len;
-		iov.iov_len = cc;
-
-		i = sendmsg(icmp_sock, &m, confirm);
-		confirm = 0;
-	} while (0);
+	i = sendto(sock->fd, icp, cc, 0, (struct sockaddr*)&whereto, sizeof(whereto));
 
 	return (cc == i ? 0 : i);
 }
@@ -766,6 +982,7 @@
  * which arrive ('tis only fair).  This permits multiple copies of this
  * program to be run without having intermingled output (or statistics!).
  */
+static
 void pr_echo_reply(__u8 *_icp, int len)
 {
 	struct icmphdr *icp = (struct icmphdr *)_icp;
@@ -773,7 +990,7 @@
 }
 
 int
-parse_reply(struct msghdr *msg, int cc, void *addr, struct timeval *tv)
+ping4_parse_reply(struct socket_st *sock, struct msghdr *msg, int cc, void *addr, struct timeval *tv)
 {
 	struct sockaddr_in *from = addr;
 	__u8 *buf = msg->msg_iov->iov_base;
@@ -783,17 +1000,17 @@
 	int csfailed;
 	struct cmsghdr *cmsg;
 	int ttl;
-	__u8 *opts;
+	__u8 *opts, *tmp_ttl;
 	int optlen;
 
 	/* Check the IP header */
 	ip = (struct iphdr *)buf;
-	if (!using_ping_socket) {
+	if (sock->socktype == SOCK_RAW) {
 		hlen = ip->ihl*4;
 		if (cc < hlen + 8 || ip->ihl < 5) {
 			if (options & F_VERBOSE)
 				fprintf(stderr, "ping: packet too short (%d bytes) from %s\n", cc,
-					pr_addr(from->sin_addr.s_addr));
+					pr_addr(from, sizeof *from));
 			return 1;
 		}
 		ttl = ip->ttl;
@@ -810,7 +1027,8 @@
 			if (cmsg->cmsg_type == IP_TTL) {
 				if (cmsg->cmsg_len < sizeof(int))
 					continue;
-				ttl = *(int *) CMSG_DATA(cmsg);
+				tmp_ttl = (__u8 *) CMSG_DATA(cmsg);
+				ttl = (int)*tmp_ttl;
 			} else if (cmsg->cmsg_type == IP_RETOPTS) {
 				opts = (__u8 *) CMSG_DATA(cmsg);
 				optlen = cmsg->cmsg_len;
@@ -821,20 +1039,20 @@
 	/* Now the ICMP part */
 	cc -= hlen;
 	icp = (struct icmphdr *)(buf + hlen);
-	csfailed = in_cksum((u_short *)icp, cc, 0);
+	csfailed = in_cksum((unsigned short *)icp, cc, 0);
 
 	if (icp->type == ICMP_ECHOREPLY) {
-		if (!is_ours(icp->un.echo.id))
+		if (!is_ours(sock, icp->un.echo.id))
 			return 1;			/* 'Twas not our ECHO */
 		if (gather_statistics((__u8*)icp, sizeof(*icp), cc,
 				      ntohs(icp->un.echo.sequence),
-				      ttl, 0, tv, pr_addr(from->sin_addr.s_addr),
-				      pr_echo_reply))
+				      ttl, 0, tv, pr_addr(from, sizeof *from),
+				      pr_echo_reply)) {
+			fflush(stdout);
 			return 0;
+		}
 	} else {
-		/* We fall here when a redirect or source quench arrived.
-		 * Also this branch processes icmp errors, when IP_RECVERR
-		 * is broken. */
+		/* We fall here when a redirect or source quench arrived. */
 
 		switch (icp->type) {
 		case ICMP_ECHO:
@@ -854,42 +1072,24 @@
 					return 1;
 				if (icp1->type != ICMP_ECHO ||
 				    iph->daddr != whereto.sin_addr.s_addr ||
-				    !is_ours(icp1->un.echo.id))
+				    !is_ours(sock, icp1->un.echo.id))
 					return 1;
 				error_pkt = (icp->type != ICMP_REDIRECT &&
 					     icp->type != ICMP_SOURCE_QUENCH);
 				if (error_pkt) {
 					acknowledge(ntohs(icp1->un.echo.sequence));
-					if (working_recverr) {
-						return 0;
-					} else {
-						static int once;
-						/* Sigh, IP_RECVERR for raw socket
-						 * was broken until 2.4.9. So, we ignore
-						 * the first error and warn on the second.
-						 */
-						if (once++ == 1)
-							fprintf(stderr, "\rWARNING: kernel is not very fresh, upgrade is recommended.\n");
-						if (once == 1)
-							return 0;
-					}
-				}
-				nerrors+=error_pkt;
-				if (options&F_QUIET)
-					return !error_pkt;
-				if (options & F_FLOOD) {
-					if (error_pkt)
-						write_stdout("\bE", 2);
-					return !error_pkt;
+					return 0;
 				}
+				if (options & (F_QUIET | F_FLOOD))
+					return 1;
 				print_timestamp();
 				printf("From %s: icmp_seq=%u ",
-				       pr_addr(from->sin_addr.s_addr),
+				       pr_addr(from, sizeof *from),
 				       ntohs(icp1->un.echo.sequence));
 				if (csfailed)
 					printf("(BAD CHECKSUM)");
 				pr_icmph(icp->type, icp->code, ntohl(icp->un.gateway), icp);
-				return !error_pkt;
+				return 1;
 			}
 		default:
 			/* MUST NOT */
@@ -909,7 +1109,7 @@
 			gettimeofday(&recv_time, NULL);
 			printf("%lu.%06lu ", (unsigned long)recv_time.tv_sec, (unsigned long)recv_time.tv_usec);
 		}
-		printf("From %s: ", pr_addr(from->sin_addr.s_addr));
+		printf("From %s: ", pr_addr(from, sizeof *from));
 		if (csfailed) {
 			printf("(BAD CHECKSUM)\n");
 			return 0;
@@ -920,11 +1120,12 @@
 
 	if (options & F_AUDIBLE) {
 		putchar('\a');
-		if (options & F_FLOOD)
+		if(options & F_FLOOD)
 			fflush(stdout);
 	}
 	if (!(options & F_FLOOD)) {
 		pr_options(opts, optlen + sizeof(struct iphdr));
+
 		putchar('\n');
 		fflush(stdout);
 	}
@@ -935,17 +1136,17 @@
 #if BYTE_ORDER == LITTLE_ENDIAN
 # define ODDBYTE(v)	(v)
 #elif BYTE_ORDER == BIG_ENDIAN
-# define ODDBYTE(v)	((u_short)(v) << 8)
+# define ODDBYTE(v)	((unsigned short)(v) << 8)
 #else
-# define ODDBYTE(v)	htons((u_short)(v) << 8)
+# define ODDBYTE(v)	htons((unsigned short)(v) << 8)
 #endif
 
-u_short
-in_cksum(const u_short *addr, register int len, u_short csum)
+unsigned short
+in_cksum(const unsigned short *addr, register int len, unsigned short csum)
 {
 	register int nleft = len;
-	const u_short *w = addr;
-	register u_short answer;
+	const unsigned short *w = addr;
+	register unsigned short answer;
 	register int sum = csum;
 
 	/*
@@ -961,7 +1162,7 @@
 
 	/* mop up an odd byte, if necessary */
 	if (nleft == 1)
-		sum += ODDBYTE(*(u_char *)w); /* le16toh() may be unavailable on old systems */
+		sum += ODDBYTE(*(unsigned char *)w); /* le16toh() may be unavailable on old systems */
 
 	/*
 	 * add back carry outs from top 16 bits to low 16 bits
@@ -1063,8 +1264,11 @@
 			printf("Redirect, Bad Code: %d", code);
 			break;
 		}
-		printf("(New nexthop: %s)\n",
-		       pr_addr(icp ? icp->un.gateway : info));
+		{
+			struct sockaddr_in sin = { .sin_family = AF_INET, .sin_addr =  { icp ? icp->un.gateway : info } };
+
+			printf("(New nexthop: %s)\n", pr_addr(&sin, sizeof sin));
+		}
 		if (icp && (options & F_VERBOSE))
 			pr_iph((struct iphdr*)(icp + 1));
 		break;
@@ -1163,8 +1367,11 @@
 					cp += 4;
 					if (address == 0)
 						printf("\t0.0.0.0");
-					else
-						printf("\t%s", pr_addr(address));
+					else {
+						struct sockaddr_in sin = { .sin_family = AF_INET, .sin_addr = { address } };
+
+						printf("\t%s", pr_addr(&sin, sizeof sin));
+					}
 					j -= 4;
 					putchar('\n');
 					if (j <= IPOPT_MINOFF)
@@ -1198,8 +1405,11 @@
 				cp += 4;
 				if (address == 0)
 					printf("\t0.0.0.0");
-				else
-					printf("\t%s", pr_addr(address));
+				else {
+					struct sockaddr_in sin = { .sin_family = AF_INET, .sin_addr = { address } };
+
+					printf("\t%s", pr_addr(&sin, sizeof sin));
+				}
 				i -= 4;
 				putchar('\n');
 				if (i <= 0)
@@ -1229,8 +1439,11 @@
 					cp += 4;
 					if (address == 0)
 						printf("\t0.0.0.0");
-					else
-						printf("\t%s", pr_addr(address));
+					else {
+						struct sockaddr_in sin = { .sin_family = AF_INET, .sin_addr = { address } };
+
+						printf("\t%s", pr_addr(&sin, sizeof sin));
+					}
 					i -= 4;
 					if (i <= 0)
 						break;
@@ -1279,10 +1492,10 @@
 void pr_iph(struct iphdr *ip)
 {
 	int hlen;
-	u_char *cp;
+	unsigned char *cp;
 
 	hlen = ip->ihl << 2;
-	cp = (u_char *)ip + 20;		/* point to options */
+	cp = (unsigned char *)ip + 20;		/* point to options */
 
 	printf("Vr HL TOS  Len   ID Flg  off TTL Pro  cks      Src      Dst Data\n");
 	printf(" %1x  %1x  %02x %04x %04x",
@@ -1298,38 +1511,37 @@
 
 /*
  * pr_addr --
- *	Return an ascii host address as a dotted quad and optionally with
- * a hostname.
+ *
+ * Return an ascii host address optionally with a hostname.
  */
 char *
-pr_addr(__u32 addr)
+pr_addr(void *sa, socklen_t salen)
 {
-	struct hostent *hp;
-	static char buf[4096];
+	static char buffer[4096] = "";
+	static struct sockaddr_storage last_sa = { 0 };
+	static socklen_t last_salen = 0;
+	char name[NI_MAXHOST] = "";
+	char address[NI_MAXHOST] = "";
+
+	if (salen == last_salen && !memcmp(sa, &last_sa, salen))
+		return buffer;
+
+	memcpy(&last_sa, sa, (last_salen = salen));
 
 	in_pr_addr = !setjmp(pr_addr_jmp);
 
-	if (exiting || (options & F_NUMERIC) ||
-	    !(hp = gethostbyaddr((char *)&addr, 4, AF_INET)))
-		sprintf(buf, "%s", inet_ntoa(*(struct in_addr *)&addr));
-	else {
-		char *s;
-#if USE_IDN
-		if (idna_to_unicode_lzlz(hp->h_name, &s, 0) != IDNA_SUCCESS)
-			s = NULL;
-#else
-		s = NULL;
-#endif
-		snprintf(buf, sizeof(buf), "%s (%s)", s ? s : hp->h_name,
-			 inet_ntoa(*(struct in_addr *)&addr));
-#if USE_IDN
-		free(s);
-#endif
-	}
+	getnameinfo(sa, salen, address, sizeof address, NULL, 0, getnameinfo_flags | NI_NUMERICHOST);
+	if (!exiting && !(options & F_NUMERIC))
+		getnameinfo(sa, salen, name, sizeof name, NULL, 0, getnameinfo_flags);
+
+	if (*name)
+		snprintf(buffer, sizeof buffer, "%s (%s)", name, address);
+	else
+		snprintf(buffer, sizeof buffer, "%s", address);
 
 	in_pr_addr = 0;
 
-	return(buf);
+	return(buffer);
 }
 
 
@@ -1360,9 +1572,7 @@
 	return(tos);
 }
 
-#include <linux/filter.h>
-
-void install_filter(void)
+void ping4_install_filter(socket_st *sock)
 {
 	static int once;
 	static struct sock_filter insns[] = {
@@ -1387,7 +1597,7 @@
 	/* Patch bpflet for current identifier. */
 	insns[2] = (struct sock_filter)BPF_JUMP(BPF_JMP|BPF_JEQ|BPF_K, htons(ident), 0, 1);
 
-	if (setsockopt(icmp_sock, SOL_SOCKET, SO_ATTACH_FILTER, &filter, sizeof(filter)))
+	if (setsockopt(sock->fd, SOL_SOCKET, SO_ATTACH_FILTER, &filter, sizeof(filter)))
 		perror("WARNING: failed to install socket filter\n");
 }
 
@@ -1398,7 +1608,7 @@
 	fprintf(stderr,
 		"Usage: ping"
 		" [-"
-			"aAbBdDfhLnOqrRUvV"
+			"aAbBdDfhLnOqrRUvV64"
 		"]"
 		" [-c count]"
 		" [-i interval]"
@@ -1420,5 +1630,6 @@
 		" [hop1 ...] destination"
 		"\n"
 	);
+	ping6_usage(1);
 	exit(2);
 }
diff -Naur iputils-s20151218.orig/ping_common.c iputils-s20151218/ping_common.c
--- iputils-s20151218.orig/ping_common.c	2015-12-17 15:45:51.000000000 +0000
+++ iputils-s20151218/ping_common.c	2016-05-17 23:17:09.000000000 +0000
@@ -1,7 +1,8 @@
-#include "ping_common.h"
-#include <ctype.h>
-#include <sched.h>
-#include <math.h>
+#include "ping.h"
+
+#ifndef HZ
+#define HZ sysconf(_SC_CLK_TCK)
+#endif
 
 int options;
 
@@ -12,9 +13,8 @@
 int rtt_addend;
 __u16 acked;
 
+unsigned char outpack[MAXPACKET];
 struct rcvd_table rcvd_tbl;
-int using_ping_socket = 0;
-
 
 /* counters */
 long npackets;			/* max packets to transmit */
@@ -24,7 +24,7 @@
 long nchecksum;			/* replies with bad checksum */
 long nerrors;			/* icmp errors */
 int interval = 1000;		/* interval between packets (msec) */
-int preload;
+int preload = 1;
 int deadline = 0;		/* time to die */
 int lingertime = MAXWAIT*1000;
 struct timeval start_time, cur_time;
@@ -38,9 +38,6 @@
  * confirm_flag fixes refusing service of kernels without MSG_CONFIRM.
  * i.e. for linux-2.2 */
 int confirm_flag = MSG_CONFIRM;
-/* And this is workaround for bug in IP_RECVERR on raw sockets which is present
- * in linux-2.2.[0-19], linux-2.4.[0-7] */
-int working_recverr;
 
 /* timing */
 int timing;			/* flag to do timing */
@@ -201,12 +198,12 @@
 /* Fills all the outpack, excluding ICMP header, but _including_
  * timestamp area with supplied pattern.
  */
-static void fill(char *patp)
+void fill(char *patp, void *packet, unsigned packet_size)
 {
 	int ii, jj, kk;
 	int pat[16];
 	char *cp;
-	u_char *bp = outpack+8;
+	unsigned char *bp = packet+8;
 
 #ifdef USE_IDN
 	setlocale(LC_ALL, "C");
@@ -226,7 +223,7 @@
 	    &pat[13], &pat[14], &pat[15]);
 
 	if (ii > 0) {
-		for (kk = 0; kk <= maxpacket - (8 + ii); kk += ii)
+		for (kk = 0; kk <= packet_size - (8 + ii); kk += ii)
 			for (jj = 0; jj < ii; ++jj)
 				bp[jj + kk] = pat[jj];
 	}
@@ -242,154 +239,6 @@
 #endif
 }
 
-void common_options(int ch)
-{
-	switch(ch) {
-	case 'a':
-		options |= F_AUDIBLE;
-		break;
-	case 'A':
-		options |= F_ADAPTIVE;
-		break;
-	case 'c':
-		npackets = atoi(optarg);
-		if (npackets <= 0) {
-			fprintf(stderr, "ping: bad number of packets to transmit.\n");
-			exit(2);
-		}
-		break;
-	case 'd':
-		options |= F_SO_DEBUG;
-		break;
-	case 'D':
-		options |= F_PTIMEOFDAY;
-		break;
-	case 'i':		/* wait between sending packets */
-	{
-		double dbl;
-		char *ep;
-
-		errno = 0;
-		dbl = strtod(optarg, &ep);
-
-		if (errno || *ep != '\0' ||
-		    !finite(dbl) || dbl < 0.0 || dbl >= (double)INT_MAX / 1000 - 1.0) {
-			fprintf(stderr, "ping: bad timing interval\n");
-			exit(2);
-		}
-
-		interval = (int)(dbl * 1000);
-
-		options |= F_INTERVAL;
-		break;
-	}
-	case 'm':
-	{
-		char *endp;
-		mark = (int)strtoul(optarg, &endp, 10);
-		if (mark < 0 || *endp != '\0') {
-			fprintf(stderr, "mark cannot be negative\n");
-			exit(2);
-		}
-		options |= F_MARK;
-		break;
-	}
-	case 'w':
-		deadline = atoi(optarg);
-		if (deadline < 0) {
-			fprintf(stderr, "ping: bad wait time.\n");
-			exit(2);
-		}
-		break;
-	case 'l':
-		preload = atoi(optarg);
-		if (preload <= 0) {
-			fprintf(stderr, "ping: bad preload value, should be 1..%d\n", MAX_DUP_CHK);
-			exit(2);
-		}
-		if (preload > MAX_DUP_CHK)
-			preload = MAX_DUP_CHK;
-		if (uid && preload > 3) {
-			fprintf(stderr, "ping: cannot set preload to value > 3\n");
-			exit(2);
-		}
-		break;
-	case 'O':
-		options |= F_OUTSTANDING;
-		break;
-	case 'S':
-		sndbuf = atoi(optarg);
-		if (sndbuf <= 0) {
-			fprintf(stderr, "ping: bad sndbuf value.\n");
-			exit(2);
-		}
-		break;
-	case 'f':
-		options |= F_FLOOD;
-		setbuf(stdout, (char *)NULL);
-		/* fallthrough to numeric - avoid gethostbyaddr during flood */
-	case 'n':
-		options |= F_NUMERIC;
-		break;
-	case 'p':		/* fill buffer with user pattern */
-		options |= F_PINGFILLED;
-		fill(optarg);
-		break;
-	case 'q':
-		options |= F_QUIET;
-		break;
-	case 'r':
-		options |= F_SO_DONTROUTE;
-		break;
-	case 's':		/* size of packet to send */
-		datalen = atoi(optarg);
-		if (datalen < 0) {
-			fprintf(stderr, "ping: illegal negative packet size %d.\n", datalen);
-			exit(2);
-		}
-		if (datalen > maxpacket - 8) {
-			fprintf(stderr, "ping: packet size too large: %d\n",
-				datalen);
-			exit(2);
-		}
-		break;
-	case 'v':
-		options |= F_VERBOSE;
-		break;
-	case 'L':
-		options |= F_NOLOOP;
-		break;
-	case 't':
-		options |= F_TTL;
-		ttl = atoi(optarg);
-		if (ttl < 0 || ttl > 255) {
-			fprintf(stderr, "ping: ttl %u out of range\n", ttl);
-			exit(2);
-		}
-		break;
-	case 'U':
-		options |= F_LATENCY;
-		break;
-	case 'B':
-		options |= F_STRICTSOURCE;
-		break;
-	case 'W':
-		lingertime = atoi(optarg);
-		if (lingertime < 0 || lingertime > INT_MAX/1000000) {
-			fprintf(stderr, "ping: bad linger time.\n");
-			exit(2);
-		}
-		lingertime *= 1000;
-		break;
-	case 'V':
-		printf("ping utility, iputils-%s\n", SNAPSHOT);
-		exit(0);
-	default:
-		abort();
-	}
-}
-
-
 static void sigexit(int signo)
 {
 	exiting = 1;
@@ -459,7 +308,7 @@
  * of the data portion are used to hold a UNIX "timeval" struct in VAX
  * byte-order, to compute the round-trip time.
  */
-int pinger(void)
+int pinger(ping_func_set_st *fset, socket_st *sock)
 {
 	static int oom_count;
 	static int tokens;
@@ -505,7 +354,7 @@
 	}
 
 resend:
-	i = send_probe();
+	i = fset->send_probe(sock, outpack, sizeof(outpack));
 
 	if (i == 0) {
 		oom_count = 0;
@@ -549,10 +398,15 @@
 		tokens += interval;
 		return MININTERVAL;
 	} else {
-		if ((i=receive_error_msg()) > 0) {
-			/* An ICMP error arrived. */
-			tokens += interval;
-			return MININTERVAL;
+		if ((i=fset->receive_error_msg(sock)) > 0) {
+			/* An ICMP error arrived. In this case, we've received
+			 * an error from sendto(), but we've also received an
+			 * ICMP message, which means the packet did in fact
+			 * send in some capacity. So, in this odd case, report
+			 * the more specific errno as the error, and treat this
+			 * as a hard local error. */
+			i = 0;
+			goto hard_local_error;
 		}
 		/* Compatibility with old linuces. */
 		if (i == 0 && confirm_flag && errno == EINVAL) {
@@ -563,6 +417,7 @@
 			goto resend;
 	}
 
+hard_local_error:
 	/* Hard local error. Pretend we sent packet. */
 	advance_ntransmitted();
 
@@ -578,20 +433,20 @@
 
 /* Set socket buffers, "alloc" is an estimate of memory taken by single packet. */
 
-void sock_setbufs(int icmp_sock, int alloc)
+void sock_setbufs(socket_st *sock, int alloc)
 {
 	int rcvbuf, hold;
 	socklen_t tmplen = sizeof(hold);
 
 	if (!sndbuf)
 		sndbuf = alloc;
-	setsockopt(icmp_sock, SOL_SOCKET, SO_SNDBUF, (char *)&sndbuf, sizeof(sndbuf));
+	setsockopt(sock->fd, SOL_SOCKET, SO_SNDBUF, (char *)&sndbuf, sizeof(sndbuf));
 
 	rcvbuf = hold = alloc * preload;
 	if (hold < 65536)
 		hold = 65536;
-	setsockopt(icmp_sock, SOL_SOCKET, SO_RCVBUF, (char *)&hold, sizeof(hold));
-	if (getsockopt(icmp_sock, SOL_SOCKET, SO_RCVBUF, (char *)&hold, &tmplen) == 0) {
+	setsockopt(sock->fd, SOL_SOCKET, SO_RCVBUF, (char *)&hold, sizeof(hold));
+	if (getsockopt(sock->fd, SOL_SOCKET, SO_RCVBUF, (char *)&hold, &tmplen) == 0) {
 		if (hold < rcvbuf)
 			fprintf(stderr, "WARNING: probably, rcvbuf is not enough to hold preload.\n");
 	}
@@ -599,7 +454,7 @@
 
 /* Protocol independent setup and parameter checks. */
 
-void setup(int icmp_sock)
+void setup(socket_st *sock)
 {
 	int hold;
 	struct timeval tv;
@@ -609,7 +464,7 @@
 		interval = 0;
 
 	if (uid && interval < MINUSERINTERVAL) {
-		fprintf(stderr, "ping: cannot flood; minimal interval, allowed for user, is %dms\n", MINUSERINTERVAL);
+		fprintf(stderr, "ping: cannot flood; minimal interval allowed for user is %dms\n", MINUSERINTERVAL);
 		exit(2);
 	}
 
@@ -620,14 +475,14 @@
 
 	hold = 1;
 	if (options & F_SO_DEBUG)
-		setsockopt(icmp_sock, SOL_SOCKET, SO_DEBUG, (char *)&hold, sizeof(hold));
+		setsockopt(sock->fd, SOL_SOCKET, SO_DEBUG, (char *)&hold, sizeof(hold));
 	if (options & F_SO_DONTROUTE)
-		setsockopt(icmp_sock, SOL_SOCKET, SO_DONTROUTE, (char *)&hold, sizeof(hold));
+		setsockopt(sock->fd, SOL_SOCKET, SO_DONTROUTE, (char *)&hold, sizeof(hold));
 
 #ifdef SO_TIMESTAMP
 	if (!(options&F_LATENCY)) {
 		int on = 1;
-		if (setsockopt(icmp_sock, SOL_SOCKET, SO_TIMESTAMP, &on, sizeof(on)))
+		if (setsockopt(sock->fd, SOL_SOCKET, SO_TIMESTAMP, &on, sizeof(on)))
 			fprintf(stderr, "Warning: no SO_TIMESTAMP support, falling back to SIOCGSTAMP\n");
 	}
 #endif
@@ -636,7 +491,7 @@
 		int ret;
 
 		enable_capability_admin();
-		ret = setsockopt(icmp_sock, SOL_SOCKET, SO_MARK, &mark, sizeof(mark));
+		ret = setsockopt(sock->fd, SOL_SOCKET, SO_MARK, &mark, sizeof(mark));
 		disable_capability_admin();
 
 		if (ret == -1) {
@@ -658,18 +513,18 @@
 		tv.tv_sec = 0;
 		tv.tv_usec = 1000 * SCHINT(interval);
 	}
-	setsockopt(icmp_sock, SOL_SOCKET, SO_SNDTIMEO, (char*)&tv, sizeof(tv));
+	setsockopt(sock->fd, SOL_SOCKET, SO_SNDTIMEO, (char*)&tv, sizeof(tv));
 
 	/* Set RCVTIMEO to "interval". Note, it is just an optimization
 	 * allowing to avoid redundant poll(). */
 	tv.tv_sec = SCHINT(interval)/1000;
 	tv.tv_usec = 1000*(SCHINT(interval)%1000);
-	if (setsockopt(icmp_sock, SOL_SOCKET, SO_RCVTIMEO, (char*)&tv, sizeof(tv)))
+	if (setsockopt(sock->fd, SOL_SOCKET, SO_RCVTIMEO, (char*)&tv, sizeof(tv)))
 		options |= F_FLOOD_POLL;
 
 	if (!(options & F_PINGFILLED)) {
 		int i;
-		u_char *p = outpack+8;
+		unsigned char *p = outpack+8;
 
 		/* Do not forget about case of small datalen,
 		 * fill timestamp area too!
@@ -678,7 +533,7 @@
 			*p++ = i;
 	}
 
-	if (!using_ping_socket)
+	if (sock->socktype == SOCK_RAW)
 		ident = htons(getpid() & 0xFFFF);
 
 	set_signal(SIGINT, sigexit);
@@ -710,7 +565,7 @@
 	}
 }
 
-void main_loop(int icmp_sock, __u8 *packet, int packlen)
+void main_loop(ping_func_set_st *fset, socket_st *sock, __u8 *packet, int packlen)
 {
 	char addrbuf[128];
 	char ans_data[4096];
@@ -737,7 +592,7 @@
 
 		/* Send probes scheduled to this time. */
 		do {
-			next = pinger();
+			next = pinger(fset, sock);
 			next = schedule_exit(next);
 		} while (next <= 0);
 
@@ -776,7 +631,7 @@
 			if (!polling &&
 			    ((options & (F_ADAPTIVE|F_FLOOD_POLL)) || interval)) {
 				struct pollfd pset;
-				pset.fd = icmp_sock;
+				pset.fd = sock->fd;
 				pset.events = POLLIN|POLLERR;
 				pset.revents = 0;
 				if (poll(&pset, 1, next) < 1 ||
@@ -801,13 +656,13 @@
 			msg.msg_control = ans_data;
 			msg.msg_controllen = sizeof(ans_data);
 
-			cc = recvmsg(icmp_sock, &msg, polling);
+			cc = recvmsg(sock->fd, &msg, polling);
 			polling = MSG_DONTWAIT;
 
 			if (cc < 0) {
 				if (errno == EAGAIN || errno == EINTR)
 					break;
-				if (!receive_error_msg()) {
+				if (!fset->receive_error_msg(sock)) {
 					if (errno) {
 						perror("ping: recvmsg");
 						break;
@@ -829,17 +684,17 @@
 
 				if ((options&F_LATENCY) || recv_timep == NULL) {
 					if ((options&F_LATENCY) ||
-					    ioctl(icmp_sock, SIOCGSTAMP, &recv_time))
+					    ioctl(sock->fd, SIOCGSTAMP, &recv_time))
 						gettimeofday(&recv_time, NULL);
 					recv_timep = &recv_time;
 				}
 
-				not_ours = parse_reply(&msg, cc, addrbuf, recv_timep);
+				not_ours = fset->parse_reply(sock, &msg, cc, addrbuf, recv_timep);
 			}
 
 			/* See? ... someone runs another ping on this host. */
-			if (not_ours && !using_ping_socket)
-				install_filter();
+			if (not_ours && sock->socktype == SOCK_RAW)
+				fset->install_filter(sock);
 
 			/* If nothing is in flight, "break" returns us to pinger. */
 			if (in_flight() == 0)
@@ -956,13 +811,13 @@
 			printf(" (BAD CHECKSUM!)");
 
 		/* check the data */
-		cp = ((u_char*)ptr) + sizeof(struct timeval);
+		cp = ((unsigned char*)ptr) + sizeof(struct timeval);
 		dp = &outpack[8 + sizeof(struct timeval)];
 		for (i = sizeof(struct timeval); i < datalen; ++i, ++cp, ++dp) {
 			if (*cp != *dp) {
 				printf("\nwrong data byte #%d should be 0x%x but was 0x%x",
 				       i, *dp, *cp);
-				cp = (u_char*)ptr + sizeof(struct timeval);
+				cp = (unsigned char*)ptr + sizeof(struct timeval);
 				for (i = sizeof(struct timeval); i < datalen; ++i, ++cp) {
 					if ((i % 32) == sizeof(struct timeval))
 						printf("\n#%d\t", i);
@@ -1059,7 +914,7 @@
 	if (ntransmitted)
 		loss = (((long long)(ntransmitted - nreceived)) * 100) / ntransmitted;
 
-	fprintf(stderr, "\r%ld/%ld packets, %d%% loss", ntransmitted, nreceived, loss);
+	fprintf(stderr, "\r%ld/%ld packets, %d%% loss", nreceived, ntransmitted, loss);
 
 	if (nreceived && timing) {
 		tavg = tsum / (nreceived + nrepeats);
@@ -1074,6 +929,6 @@
 	fprintf(stderr, "\n");
 }
 
-inline int is_ours(uint16_t id) {
-	return using_ping_socket || id == ident;
+inline int is_ours(socket_st *sock, uint16_t id) {
+       return sock->socktype == SOCK_DGRAM || id == ident;
 }
diff -Naur iputils-s20151218.orig/ping_common.h iputils-s20151218/ping_common.h
--- iputils-s20151218.orig/ping_common.h	2015-12-17 15:45:51.000000000 +0000
+++ iputils-s20151218/ping_common.h	1970-01-01 00:00:00.000000000 +0000
@@ -1,291 +0,0 @@
-#include <stdio.h>
-#include <stdlib.h>
-#include <unistd.h>
-#include <time.h>
-#include <sys/param.h>
-#include <sys/socket.h>
-#include <linux/types.h>
-#include <linux/sockios.h>
-#include <sys/file.h>
-#include <sys/time.h>
-#include <sys/signal.h>
-#include <sys/ioctl.h>
-#include <net/if.h>
-#include <sys/uio.h>
-#include <sys/poll.h>
-#include <ctype.h>
-#include <errno.h>
-#include <string.h>
-#include <netdb.h>
-#include <setjmp.h>
-
-#ifdef CAPABILITIES
-#include <sys/prctl.h>
-#include <sys/capability.h>
-#endif
-
-#ifdef USE_IDN
-#include <locale.h>
-#include <idna.h>
-#endif
-
-#include <netinet/in.h>
-#include <arpa/inet.h>
-#include <linux/types.h>
-#include <linux/errqueue.h>
-
-#include "SNAPSHOT.h"
-
-#define	DEFDATALEN	(64 - 8)	/* default data length */
-
-#define	MAXWAIT		10		/* max seconds to wait for response */
-#define MININTERVAL	10		/* Minimal interpacket gap */
-#define MINUSERINTERVAL	200		/* Minimal allowed interval for non-root */
-
-#define SCHINT(a)	(((a) <= MININTERVAL) ? MININTERVAL : (a))
-
-/* various options */
-extern int options;
-#define	F_FLOOD		0x001
-#define	F_INTERVAL	0x002
-#define	F_NUMERIC	0x004
-#define	F_PINGFILLED	0x008
-#define	F_QUIET		0x010
-#define	F_RROUTE	0x020
-#define	F_SO_DEBUG	0x040
-#define	F_SO_DONTROUTE	0x080
-#define	F_VERBOSE	0x100
-#define	F_TIMESTAMP	0x200
-#define	F_FLOWINFO	0x200
-#define	F_SOURCEROUTE	0x400
-#define	F_TCLASS	0x400
-#define	F_FLOOD_POLL	0x800
-#define	F_LATENCY	0x1000
-#define	F_AUDIBLE	0x2000
-#define	F_ADAPTIVE	0x4000
-#define	F_STRICTSOURCE	0x8000
-#define F_NOLOOP	0x10000
-#define F_TTL		0x20000
-#define F_MARK		0x40000
-#define F_PTIMEOFDAY	0x80000
-#define F_OUTSTANDING	0x100000
-
-/*
- * MAX_DUP_CHK is the number of bits in received table, i.e. the maximum
- * number of received sequence numbers we can keep track of.
- */
-#define	MAX_DUP_CHK	0x10000
-
-#if defined(__WORDSIZE) && __WORDSIZE == 64
-# define USE_BITMAP64
-#endif
-
-#ifdef USE_BITMAP64
-typedef __u64	bitmap_t;
-# define BITMAP_SHIFT	6
-#else
-typedef __u32	bitmap_t;
-# define BITMAP_SHIFT	5
-#endif
-
-#if ((MAX_DUP_CHK >> (BITMAP_SHIFT + 3)) << (BITMAP_SHIFT + 3)) != MAX_DUP_CHK
-# error Please MAX_DUP_CHK and/or BITMAP_SHIFT
-#endif
-
-struct rcvd_table {
-	bitmap_t bitmap[MAX_DUP_CHK / (sizeof(bitmap_t) * 8)];
-};
-
-extern struct rcvd_table rcvd_tbl;
-
-#define	A(bit)	(rcvd_tbl.bitmap[(bit) >> BITMAP_SHIFT])	/* identify word in array */
-#define	B(bit)	(((bitmap_t)1) << ((bit) & ((1 << BITMAP_SHIFT) - 1)))	/* identify bit in word */
-
-static inline void rcvd_set(__u16 seq)
-{
-	unsigned bit = seq % MAX_DUP_CHK;
-	A(bit) |= B(bit);
-}
-
-static inline void rcvd_clear(__u16 seq)
-{
-	unsigned bit = seq % MAX_DUP_CHK;
-	A(bit) &= ~B(bit);
-}
-
-static inline bitmap_t rcvd_test(__u16 seq)
-{
-	unsigned bit = seq % MAX_DUP_CHK;
-	return A(bit) & B(bit);
-}
-
-extern u_char outpack[];
-extern int maxpacket;
-
-extern int datalen;
-extern char *hostname;
-extern int uid;
-extern int ident;			/* process id to identify our packets */
-
-extern int using_ping_socket;
-extern int sndbuf;
-extern int ttl;
-
-extern long npackets;			/* max packets to transmit */
-extern long nreceived;			/* # of packets we got back */
-extern long nrepeats;			/* number of duplicates */
-extern long ntransmitted;		/* sequence # for outbound packets = #sent */
-extern long nchecksum;			/* replies with bad checksum */
-extern long nerrors;			/* icmp errors */
-extern int interval;			/* interval between packets (msec) */
-extern int preload;
-extern int deadline;			/* time to die */
-extern int lingertime;
-extern struct timeval start_time, cur_time;
-extern volatile int exiting;
-extern volatile int status_snapshot;
-extern int confirm;
-extern int confirm_flag;
-extern int working_recverr;
-
-extern volatile int in_pr_addr;		/* pr_addr() is executing */
-extern jmp_buf pr_addr_jmp;
-
-#ifndef MSG_CONFIRM
-#define MSG_CONFIRM 0
-#endif
-
-
-/* timing */
-extern int timing;			/* flag to do timing */
-extern long tmin;			/* minimum round trip time */
-extern long tmax;			/* maximum round trip time */
-extern long long tsum;			/* sum of all times, for doing average */
-extern long long tsum2;
-extern int rtt;
-extern __u16 acked;
-extern int pipesize;
-
-#define COMMON_OPTIONS \
-case 'a': case 'U': case 'c': case 'd': \
-case 'f': case 'i': case 'w': case 'l': \
-case 'S': case 'n': case 'p': case 'q': \
-case 'r': case 's': case 'v': case 'L': \
-case 't': case 'A': case 'W': case 'B': case 'm': \
-case 'D': case 'O':
-
-#define COMMON_OPTSTR "h?VQ:I:M:aUc:dfi:w:l:S:np:qrs:vLt:AW:Bm:DO"
-
-/*
- * Write to stdout
- */
-static inline void write_stdout(const char *str, size_t len)
-{
-	size_t o = 0;
-	ssize_t cc;
-	do {
-		cc = write(STDOUT_FILENO, str + o, len - o);
-		o += cc;
-	} while (len > o || cc < 0);
-}
-
-/*
- * tvsub --
- *	Subtract 2 timeval structs:  out = out - in.  Out is assumed to
- * be >= in.
- */
-static inline void tvsub(struct timeval *out, struct timeval *in)
-{
-	if ((out->tv_usec -= in->tv_usec) < 0) {
-		--out->tv_sec;
-		out->tv_usec += 1000000;
-	}
-	out->tv_sec -= in->tv_sec;
-}
-
-static inline void set_signal(int signo, void (*handler)(int))
-{
-	struct sigaction sa;
-
-	memset(&sa, 0, sizeof(sa));
-
-	sa.sa_handler = (void (*)(int))handler;
-#ifdef SA_INTERRUPT
-	sa.sa_flags = SA_INTERRUPT;
-#endif
-	sigaction(signo, &sa, NULL);
-}
-
-extern int __schedule_exit(int next);
-
-static inline int schedule_exit(int next)
-{
-	if (npackets && ntransmitted >= npackets && !deadline)
-		next = __schedule_exit(next);
-	return next;
-}
-
-static inline int in_flight(void)
-{
-	__u16 diff = (__u16)ntransmitted - acked;
-	return (diff<=0x7FFF) ? diff : ntransmitted-nreceived-nerrors;
-}
-
-static inline void acknowledge(__u16 seq)
-{
-	__u16 diff = (__u16)ntransmitted - seq;
-	if (diff <= 0x7FFF) {
-		if ((int)diff+1 > pipesize)
-			pipesize = (int)diff+1;
-		if ((__s16)(seq - acked) > 0 ||
-		    (__u16)ntransmitted - acked > 0x7FFF)
-			acked = seq;
-	}
-}
-
-static inline void advance_ntransmitted(void)
-{
-	ntransmitted++;
-	/* Invalidate acked, if 16 bit seq overflows. */
-	if ((__u16)ntransmitted - acked > 0x7FFF)
-		acked = (__u16)ntransmitted + 1;
-}
-
-extern void limit_capabilities(void);
-static int enable_capability_raw(void);
-static int disable_capability_raw(void);
-static int enable_capability_admin(void);
-static int disable_capability_admin(void);
-#ifdef CAPABILITIES
-extern int modify_capability(cap_value_t, cap_flag_value_t);
-static inline int enable_capability_raw(void)		{ return modify_capability(CAP_NET_RAW,   CAP_SET);   };
-static inline int disable_capability_raw(void)		{ return modify_capability(CAP_NET_RAW,   CAP_CLEAR); };
-static inline int enable_capability_admin(void)		{ return modify_capability(CAP_NET_ADMIN, CAP_SET);   };
-static inline int disable_capability_admin(void)	{ return modify_capability(CAP_NET_ADMIN, CAP_CLEAR); };
-#else
-extern int modify_capability(int);
-static inline int enable_capability_raw(void)		{ return modify_capability(1); };
-static inline int disable_capability_raw(void)		{ return modify_capability(0); };
-static inline int enable_capability_admin(void)		{ return modify_capability(1); };
-static inline int disable_capability_admin(void)	{ return modify_capability(0); };
-#endif
-extern void drop_capabilities(void);
-
-extern int send_probe(void);
-extern int receive_error_msg(void);
-extern int parse_reply(struct msghdr *msg, int len, void *addr, struct timeval *);
-extern void install_filter(void);
-extern int is_ours(uint16_t id);
-
-extern int pinger(void);
-extern void sock_setbufs(int icmp_sock, int alloc);
-extern void setup(int icmp_sock);
-extern void main_loop(int icmp_sock, __u8 *buf, int buflen) __attribute__((noreturn));
-extern void finish(void) __attribute__((noreturn));
-extern void status(void);
-extern void common_options(int ch);
-extern int gather_statistics(__u8 *ptr, int icmplen,
-			     int cc, __u16 seq, int hops,
-			     int csfailed, struct timeval *tv, char *from,
-			     void (*pr_reply)(__u8 *ptr, int cc));
-extern void print_timestamp(void);
diff -Naur iputils-s20151218.orig/ping.h iputils-s20151218/ping.h
--- iputils-s20151218.orig/ping.h	1970-01-01 00:00:00.000000000 +0000
+++ iputils-s20151218/ping.h	2016-05-17 23:17:09.000000000 +0000
@@ -0,0 +1,396 @@
+#include <stdio.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include <time.h>
+#include <signal.h>
+#include <poll.h>
+#include <sys/param.h>
+#include <sys/socket.h>
+#include <linux/types.h>
+#include <linux/sockios.h>
+#include <sys/file.h>
+#include <sys/time.h>
+#include <sys/ioctl.h>
+#include <net/if.h>
+#include <sys/uio.h>
+#include <ctype.h>
+#include <errno.h>
+#include <string.h>
+#include <netdb.h>
+#include <setjmp.h>
+#include <netinet/icmp6.h>
+#include <asm/byteorder.h>
+#include <sched.h>
+#include <math.h>
+#include <netinet/ip.h>
+#include <netinet/ip6.h>
+#include <netinet/ip_icmp.h>
+#include <netinet/icmp6.h>
+#include <linux/filter.h>
+#include <resolv.h>
+
+#ifdef CAPABILITIES
+#include <sys/prctl.h>
+#include <sys/capability.h>
+#endif
+
+#ifdef USE_IDN
+#include <locale.h>
+#include <idna.h>
+#include <stringprep.h>
+#define getaddrinfo_flags (AI_CANONNAME | AI_IDN | AI_CANONIDN)
+#define getnameinfo_flags NI_IDN
+#else
+#define getaddrinfo_flags (AI_CANONNAME)
+#define getnameinfo_flags 0
+#endif
+
+#ifndef WITHOUT_IFADDRS
+#include <ifaddrs.h>
+#endif
+
+#include <netinet/in.h>
+#include <arpa/inet.h>
+#include <linux/types.h>
+#include <linux/errqueue.h>
+
+#include "in6_flowlabel.h"
+#include "SNAPSHOT.h"
+
+#ifndef SCOPE_DELIMITER
+#define SCOPE_DELIMITER '%'
+#endif
+
+#define	DEFDATALEN	(64 - 8)	/* default data length */
+
+#define	MAXWAIT		10		/* max seconds to wait for response */
+#define MININTERVAL	10		/* Minimal interpacket gap */
+#define MINUSERINTERVAL	200		/* Minimal allowed interval for non-root */
+
+#define SCHINT(a)	(((a) <= MININTERVAL) ? MININTERVAL : (a))
+
+/* various options */
+extern int options;
+#define	F_FLOOD		0x001
+#define	F_INTERVAL	0x002
+#define	F_NUMERIC	0x004
+#define	F_PINGFILLED	0x008
+#define	F_QUIET		0x010
+#define	F_RROUTE	0x020
+#define	F_SO_DEBUG	0x040
+#define	F_SO_DONTROUTE	0x080
+#define	F_VERBOSE	0x100
+#define	F_TIMESTAMP	0x200
+#define	F_FLOWINFO	0x200
+#define	F_SOURCEROUTE	0x400
+#define	F_TCLASS	0x400
+#define	F_FLOOD_POLL	0x800
+#define	F_LATENCY	0x1000
+#define	F_AUDIBLE	0x2000
+#define	F_ADAPTIVE	0x4000
+#define	F_STRICTSOURCE	0x8000
+#define F_NOLOOP	0x10000
+#define F_TTL		0x20000
+#define F_MARK		0x40000
+#define F_PTIMEOFDAY	0x80000
+#define F_OUTSTANDING	0x100000
+
+/*
+ * MAX_DUP_CHK is the number of bits in received table, i.e. the maximum
+ * number of received sequence numbers we can keep track of.
+ */
+#define	MAX_DUP_CHK	0x10000
+
+#if defined(__WORDSIZE) && __WORDSIZE == 64
+# define USE_BITMAP64
+#endif
+
+#ifdef USE_BITMAP64
+typedef __u64	bitmap_t;
+# define BITMAP_SHIFT	6
+#else
+typedef __u32	bitmap_t;
+# define BITMAP_SHIFT	5
+#endif
+
+#if ((MAX_DUP_CHK >> (BITMAP_SHIFT + 3)) << (BITMAP_SHIFT + 3)) != MAX_DUP_CHK
+# error Please MAX_DUP_CHK and/or BITMAP_SHIFT
+#endif
+
+struct rcvd_table {
+	bitmap_t bitmap[MAX_DUP_CHK / (sizeof(bitmap_t) * 8)];
+};
+
+extern struct rcvd_table rcvd_tbl;
+
+#define	A(bit)	(rcvd_tbl.bitmap[(bit) >> BITMAP_SHIFT])	/* identify word in array */
+#define	B(bit)	(((bitmap_t)1) << ((bit) & ((1 << BITMAP_SHIFT) - 1)))	/* identify bit in word */
+
+static inline void rcvd_set(__u16 seq)
+{
+	unsigned bit = seq % MAX_DUP_CHK;
+	A(bit) |= B(bit);
+}
+
+static inline void rcvd_clear(__u16 seq)
+{
+	unsigned bit = seq % MAX_DUP_CHK;
+	A(bit) &= ~B(bit);
+}
+
+static inline bitmap_t rcvd_test(__u16 seq)
+{
+	unsigned bit = seq % MAX_DUP_CHK;
+	return A(bit) & B(bit);
+}
+
+extern int datalen;
+extern char *hostname;
+extern int uid;
+extern int ident;			/* process id to identify our packets */
+
+extern int sndbuf;
+extern int ttl;
+
+extern long npackets;			/* max packets to transmit */
+extern long nreceived;			/* # of packets we got back */
+extern long nrepeats;			/* number of duplicates */
+extern long ntransmitted;		/* sequence # for outbound packets = #sent */
+extern long nchecksum;			/* replies with bad checksum */
+extern long nerrors;			/* icmp errors */
+extern int interval;			/* interval between packets (msec) */
+extern int preload;
+extern int deadline;			/* time to die */
+extern int lingertime;
+extern struct timeval start_time, cur_time;
+extern volatile int exiting;
+extern volatile int status_snapshot;
+extern int confirm;
+extern int confirm_flag;
+
+extern volatile int in_pr_addr;		/* pr_addr() is executing */
+extern jmp_buf pr_addr_jmp;
+
+#ifndef MSG_CONFIRM
+#define MSG_CONFIRM 0
+#endif
+
+
+/* timing */
+extern int timing;			/* flag to do timing */
+extern long tmin;			/* minimum round trip time */
+extern long tmax;			/* maximum round trip time */
+extern long long tsum;			/* sum of all times, for doing average */
+extern long long tsum2;
+extern int rtt;
+extern __u16 acked;
+extern int pipesize;
+
+/*
+ * Write to stdout
+ */
+static inline void write_stdout(const char *str, size_t len)
+{
+	size_t o = 0;
+	ssize_t cc;
+	do {
+		cc = write(STDOUT_FILENO, str + o, len - o);
+		o += cc;
+	} while (len > o || cc < 0);
+}
+
+/*
+ * tvsub --
+ *	Subtract 2 timeval structs:  out = out - in.  Out is assumed to
+ * be >= in.
+ */
+static inline void tvsub(struct timeval *out, struct timeval *in)
+{
+	if ((out->tv_usec -= in->tv_usec) < 0) {
+		--out->tv_sec;
+		out->tv_usec += 1000000;
+	}
+	out->tv_sec -= in->tv_sec;
+}
+
+static inline void set_signal(int signo, void (*handler)(int))
+{
+	struct sigaction sa;
+
+	memset(&sa, 0, sizeof(sa));
+
+	sa.sa_handler = (void (*)(int))handler;
+#ifdef SA_INTERRUPT
+	sa.sa_flags = SA_INTERRUPT;
+#endif
+	sigaction(signo, &sa, NULL);
+}
+
+extern int __schedule_exit(int next);
+
+static inline int schedule_exit(int next)
+{
+	if (npackets && ntransmitted >= npackets && !deadline)
+		next = __schedule_exit(next);
+	return next;
+}
+
+static inline int in_flight(void)
+{
+	__u16 diff = (__u16)ntransmitted - acked;
+	return (diff<=0x7FFF) ? diff : ntransmitted-nreceived-nerrors;
+}
+
+static inline void acknowledge(__u16 seq)
+{
+	__u16 diff = (__u16)ntransmitted - seq;
+	if (diff <= 0x7FFF) {
+		if ((int)diff+1 > pipesize)
+			pipesize = (int)diff+1;
+		if ((__s16)(seq - acked) > 0 ||
+		    (__u16)ntransmitted - acked > 0x7FFF)
+			acked = seq;
+	}
+}
+
+static inline void advance_ntransmitted(void)
+{
+	ntransmitted++;
+	/* Invalidate acked, if 16 bit seq overflows. */
+	if ((__u16)ntransmitted - acked > 0x7FFF)
+		acked = (__u16)ntransmitted + 1;
+}
+
+extern void limit_capabilities(void);
+static int enable_capability_raw(void);
+static int disable_capability_raw(void);
+static int enable_capability_admin(void);
+static int disable_capability_admin(void);
+#ifdef CAPABILITIES
+extern int modify_capability(cap_value_t, cap_flag_value_t);
+static inline int enable_capability_raw(void)		{ return modify_capability(CAP_NET_RAW,   CAP_SET);   };
+static inline int disable_capability_raw(void)		{ return modify_capability(CAP_NET_RAW,   CAP_CLEAR); };
+static inline int enable_capability_admin(void)		{ return modify_capability(CAP_NET_ADMIN, CAP_SET);   };
+static inline int disable_capability_admin(void)	{ return modify_capability(CAP_NET_ADMIN, CAP_CLEAR); };
+#else
+extern int modify_capability(int);
+static inline int enable_capability_raw(void)		{ return modify_capability(1); };
+static inline int disable_capability_raw(void)		{ return modify_capability(0); };
+static inline int enable_capability_admin(void)		{ return modify_capability(1); };
+static inline int disable_capability_admin(void)	{ return modify_capability(0); };
+#endif
+extern void drop_capabilities(void);
+
+typedef struct socket_st {
+	int fd;
+	int socktype;
+	/* And this is workaround for bug in IP_RECVERR on raw sockets which is present
+	 * in linux-2.2.[0-19], linux-2.4.[0-7] */
+	int working_recverr;
+} socket_st;
+
+char *pr_addr(void *sa, socklen_t salen);
+
+int is_ours(socket_st *sock, uint16_t id);
+
+int ping4_run(int argc, char **argv, struct addrinfo *ai, socket_st *sock);
+int ping4_send_probe(socket_st *, void *packet, unsigned packet_size);
+int ping4_receive_error_msg(socket_st *);
+int ping4_parse_reply(socket_st *, struct msghdr *msg, int len, void *addr, struct timeval *);
+void ping4_install_filter(socket_st *);
+
+typedef struct ping_func_set_st {
+	int (*send_probe)(socket_st *, void *packet, unsigned packet_size);
+	int (*receive_error_msg)(socket_st *sock);
+	int (*parse_reply)(socket_st *, struct msghdr *msg, int len, void *addr, struct timeval *);
+	void (*install_filter)(socket_st *);
+} ping_func_set_st;
+
+#define	MAXPACKET	128000		/* max packet size */
+extern ping_func_set_st ping4_func_set;
+
+extern int pinger(ping_func_set_st *fset, socket_st *sock);
+extern void sock_setbufs(socket_st*, int alloc);
+extern void setup(socket_st *);
+extern void main_loop(ping_func_set_st *fset, socket_st*, __u8 *buf, int buflen) __attribute__((noreturn));
+extern void finish(void) __attribute__((noreturn));
+extern void status(void);
+extern void common_options(int ch);
+extern int gather_statistics(__u8 *ptr, int icmplen,
+			     int cc, __u16 seq, int hops,
+			     int csfailed, struct timeval *tv, char *from,
+			     void (*pr_reply)(__u8 *ptr, int cc));
+extern void print_timestamp(void);
+void fill(char *patp, void *packet, unsigned packet_size);
+
+extern int mark;
+extern unsigned char outpack[MAXPACKET];
+
+/* IPv6 */
+
+int ping6_run(int argc, char **argv, struct addrinfo *ai, socket_st *sock);
+void ping6_usage(unsigned from_ping);
+
+int ping6_send_probe(socket_st *sockets, void *packet, unsigned packet_size);
+int ping6_receive_error_msg(socket_st *sockets);
+int ping6_parse_reply(socket_st *, struct msghdr *msg, int len, void *addr, struct timeval *);
+void ping6_install_filter(socket_st *sockets);
+
+extern ping_func_set_st ping6_func_set;
+
+int niquery_option_handler(const char *opt_arg);
+int hextoui(const char *str);
+
+extern __u32 tclass;
+extern __u32 flowlabel;
+extern struct sockaddr_in6 source6;
+extern struct sockaddr_in6 whereto6;
+extern struct sockaddr_in6 firsthop6;
+
+/* IPv6 node information query */
+
+#define NI_NONCE_SIZE			8
+
+struct ni_hdr {
+	struct icmp6_hdr		ni_u;
+	__u8				ni_nonce[NI_NONCE_SIZE];
+};
+
+#define ni_type		ni_u.icmp6_type
+#define ni_code		ni_u.icmp6_code
+#define ni_cksum	ni_u.icmp6_cksum
+#define ni_qtype	ni_u.icmp6_data16[0]
+#define ni_flags	ni_u.icmp6_data16[1]
+
+/* Types */
+#ifndef ICMPV6_NI_QUERY
+# define ICMPV6_NI_QUERY		139
+# define ICMPV6_NI_REPLY		140
+#endif
+
+/* Query Codes */
+#define NI_SUBJ_IPV6			0
+#define NI_SUBJ_NAME			1
+#define NI_SUBJ_IPV4			2
+
+/* Reply Codes */
+#define NI_SUCCESS			0
+#define NI_REFUSED			1
+#define NI_UNKNOWN			2
+
+/* Qtypes */
+#define NI_QTYPE_NOOP			0
+#define NI_QTYPE_NAME			2
+#define NI_QTYPE_IPV6ADDR		3
+#define NI_QTYPE_IPV4ADDR		4
+
+/* Flags */
+#define NI_IPV6ADDR_F_TRUNCATE		__constant_cpu_to_be16(0x0001)
+#define NI_IPV6ADDR_F_ALL		__constant_cpu_to_be16(0x0002)
+#define NI_IPV6ADDR_F_COMPAT		__constant_cpu_to_be16(0x0004)
+#define NI_IPV6ADDR_F_LINKLOCAL		__constant_cpu_to_be16(0x0008)
+#define NI_IPV6ADDR_F_SITELOCAL		__constant_cpu_to_be16(0x0010)
+#define NI_IPV6ADDR_F_GLOBAL		__constant_cpu_to_be16(0x0020)
+
+#define NI_IPV4ADDR_F_TRUNCATE		NI_IPV6ADDR_F_TRUNCATE
+#define NI_IPV4ADDR_F_ALL		NI_IPV6ADDR_F_ALL
diff -Naur iputils-s20151218.orig/rarpd.c iputils-s20151218/rarpd.c
--- iputils-s20151218.orig/rarpd.c	2015-12-17 15:45:51.000000000 +0000
+++ iputils-s20151218/rarpd.c	2016-05-17 23:17:09.000000000 +0000
@@ -17,18 +17,19 @@
 #include <unistd.h>
 #include <stdlib.h>
 #include <netdb.h>
+#include <errno.h>
+#include <fcntl.h>
+#include <signal.h>
+#include <poll.h>
 #include <arpa/inet.h>
-#include <sys/ioctl.h>
-#include <sys/poll.h>
-#include <sys/errno.h>
-#include <sys/fcntl.h>
-#include <sys/socket.h>
-#include <sys/signal.h>
+#include <netinet/in.h>
 #include <linux/if.h>
 #include <linux/if_arp.h>
-#include <netinet/in.h>
 #include <linux/if_packet.h>
 #include <linux/filter.h>
+#include <sys/ioctl.h>
+#include <sys/socket.h>
+
 
 int do_reload = 1;
 
@@ -99,7 +100,7 @@
 	}
 
 	ifc.ifc_len = sizeof ibuf;
-	ifc.ifc_buf = (caddr_t)ibuf;
+	ifc.ifc_buf = (char *)ibuf;
 	if (ioctl(fd, SIOCGIFCONF, (char *)&ifc) < 0 ||
 	    ifc.ifc_len < (int)sizeof(struct ifreq)) {
 		syslog(LOG_ERR, "SIOCGIFCONF: %m");
diff -Naur iputils-s20151218.orig/rdisc.c iputils-s20151218/rdisc.c
--- iputils-s20151218.orig/rdisc.c	2015-12-17 15:45:51.000000000 +0000
+++ iputils-s20151218/rdisc.c	2016-05-17 23:17:09.000000000 +0000
@@ -37,6 +37,7 @@
 
 #include <sys/param.h>
 #include <sys/socket.h>
+#include <sys/types.h>
 #include <sys/file.h>
 #include <malloc.h>
 
@@ -114,15 +115,15 @@
 
 #define MAXIFS 32
 
-#if !defined(__GLIBC__) || __GLIBC__ < 2
+#if defined(__GLIBC__) && __GLIBC__ < 2
 /* For router advertisement */
 struct icmp_ra
 {
-	u_char	icmp_type;		/* type of message, see below */
-	u_char	icmp_code;		/* type sub code */
-	u_short	icmp_cksum;		/* ones complement cksum of struct */
-	u_char	icmp_num_addrs;
-	u_char	icmp_wpa;		/* Words per address */
+	unsigned char	icmp_type;		/* type of message, see below */
+	unsigned char	icmp_code;		/* type sub code */
+	unsigned short	icmp_cksum;		/* ones complement cksum of struct */
+	unsigned char	icmp_num_addrs;
+	unsigned char	icmp_wpa;		/* Words per address */
 	short 	icmp_lifetime;
 };
 
@@ -207,7 +208,7 @@
 static void finish(void);
 static void timer(void);
 static void initifs(void);
-static u_short in_cksum(u_short *addr, int len);
+static unsigned short in_cksum(unsigned short *addr, int len);
 
 static int logging = 0;
 
@@ -459,7 +460,7 @@
 	timer();	/* start things going */
 
 	for (;;) {
-		u_char	packet[MAXPACKET];
+		unsigned char	packet[MAXPACKET];
 		int len = sizeof (packet);
 		socklen_t fromlen = sizeof (from);
 		int cc;
@@ -539,7 +540,7 @@
 void
 solicitor(struct sockaddr_in *sin)
 {
-	static u_char outpack[MAXPACKET];
+	static unsigned char outpack[MAXPACKET];
 	struct icmphdr *icp = (struct icmphdr *) ALLIGN(outpack);
 	int packetlen, i;
 
@@ -554,7 +555,7 @@
 	packetlen = 8;
 
 	/* Compute ICMP checksum here */
-	icp->checksum = in_cksum( (u_short *)icp, packetlen );
+	icp->checksum = in_cksum( (unsigned short *)icp, packetlen );
 
 	if (isbroadcast(sin))
 		i = sendbcast(s, (char *)outpack, packetlen);
@@ -583,7 +584,7 @@
 void
 advertise(struct sockaddr_in *sin, int lft)
 {
-	static u_char outpack[MAXPACKET];
+	static unsigned char outpack[MAXPACKET];
 	struct icmp_ra *rap = (struct icmp_ra *) ALLIGN(outpack);
 	struct icmp_ra_addr *ap;
 	int packetlen, i, cc;
@@ -614,7 +615,7 @@
 		rap->icmp_num_addrs++;
 
 		/* Compute ICMP checksum here */
-		rap->icmp_cksum = in_cksum( (u_short *)rap, packetlen );
+		rap->icmp_cksum = in_cksum( (unsigned short *)rap, packetlen );
 
 		if (isbroadcast(sin))
 			cc = sendbcastif(s, (char *)outpack, packetlen,
@@ -698,13 +699,12 @@
  */
 char *pr_name(struct in_addr addr)
 {
-	struct hostent *phe;
+	struct sockaddr_in sin = { .sin_family = AF_INET, .sin_addr = addr };
+	char hnamebuf[NI_MAXHOST] = "";
 	static char buf[80];
 
-	phe = gethostbyaddr((char *)&addr.s_addr, 4, AF_INET);
-	if (phe == NULL)
-		return( inet_ntoa(addr));
-	snprintf(buf, sizeof(buf), "%s (%s)", phe->h_name, inet_ntoa(addr));
+	getnameinfo((struct sockaddr *) &sin, sizeof sin, hnamebuf, sizeof hnamebuf, NULL, 0, 0);
+	snprintf(buf, sizeof buf, "%s (%s)", hnamebuf, inet_ntoa(addr));
 	return(buf);
 }
 
@@ -748,7 +748,7 @@
 
 		/* TBD verify that the link is multicast or broadcast */
 		/* XXX Find out the link it came in over? */
-		if (in_cksum((u_short *)ALLIGN(buf+hlen), cc)) {
+		if (in_cksum((unsigned short *)ALLIGN(buf+hlen), cc)) {
 			if (verbose)
 				logtrace("ICMP %s from %s: Bad checksum\n",
 					 pr_type((int)rap->icmp_type),
@@ -837,7 +837,7 @@
 		/* TBD verify that the link is multicast or broadcast */
 		/* XXX Find out the link it came in over? */
 
-		if (in_cksum((u_short *)ALLIGN(buf+hlen), cc)) {
+		if (in_cksum((unsigned short *)ALLIGN(buf+hlen), cc)) {
 			if (verbose)
 				logtrace("ICMP %s from %s: Bad checksum\n",
 					      pr_type((int)icp->type),
@@ -913,16 +913,16 @@
 #if BYTE_ORDER == LITTLE_ENDIAN
 # define ODDBYTE(v)	(v)
 #elif BYTE_ORDER == BIG_ENDIAN
-# define ODDBYTE(v)	((u_short)(v) << 8)
+# define ODDBYTE(v)	((unsigned short)(v) << 8)
 #else
-# define ODDBYTE(v)	htons((u_short)(v) << 8)
+# define ODDBYTE(v)	htons((unsigned short)(v) << 8)
 #endif
 
-u_short in_cksum(u_short *addr, int len)
+unsigned short in_cksum(unsigned short *addr, int len)
 {
 	register int nleft = len;
-	register u_short *w = addr;
-	register u_short answer;
+	register unsigned short *w = addr;
+	register unsigned short answer;
 	register int sum = 0;
 
 	/*
@@ -938,7 +938,7 @@
 
 	/* mop up an odd byte, if necessary */
 	if( nleft == 1 )
-		sum += ODDBYTE(*(u_char *)w);	/* le16toh() may be unavailable on old systems */
+		sum += ODDBYTE(*(unsigned char *)w);	/* le16toh() may be unavailable on old systems */
 
 	/*
 	 * add back carry outs from top 16 bits to low 16 bits
@@ -1262,7 +1262,7 @@
 int support_multicast()
 {
 	int sock;
-	u_char ttl = 1;
+	unsigned char ttl = 1;
 
 	sock = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);
 	if (sock < 0) {
diff -Naur iputils-s20151218.orig/README.md iputils-s20151218/README.md
--- iputils-s20151218.orig/README.md	1970-01-01 00:00:00.000000000 +0000
+++ iputils-s20151218/README.md	2016-05-17 23:17:09.000000000 +0000
@@ -0,0 +1,24 @@
+[![Build Status](https://travis-ci.org/iputils/iputils.svg?branch=master)](https://travis-ci.org/iputils/iputils)
+[![Coverity Status](https://scan.coverity.com/projects/1944/badge.svg?flat=1)](https://scan.coverity.com/projects/1944)
+
+The iputils package is set of small useful utilities for Linux networking.
+
+These tools are included in iputils
+- arping
+- clockdiff
+- ipg
+- ping
+- ping6
+- rarpd
+- rdisc
+- tftpd
+- tracepath
+- tracepath6
+- traceroute6
+
+If you using [old version](http://www.skbuff.net/iputils/), please consider to move forward to new releases placed here.
+
+This version also fully support support glibc, uClibc and musl-libc.
+
+<!-- vim: set tw=80: -->
+
diff -Naur iputils-s20151218.orig/RELNOTES iputils-s20151218/RELNOTES
--- iputils-s20151218.orig/RELNOTES	2015-12-17 15:45:51.000000000 +0000
+++ iputils-s20151218/RELNOTES	2016-05-17 23:17:09.000000000 +0000
@@ -1,41 +1,229 @@
-[s20151218]
+[s20160308]
+
+Aaro Koskinen (1):
+      use syntax compatible with busybox date in Makefile
+
+Chris Morrow (1):
+      'admin prohibited' should print !X not !S.
+
+David Heidelberg (3):
+      Makefile: use #define as in previous code changes
+      iputils-s20150815
+      doc/Makefile: require bash, because we use pushd and popd
+
+David McMackins II (1):
+      ping: status() now returns received/transmitted instead of trans/recv
+
+Felix Janda (1):
+      ping: don't mess with internals of struct msghdr
+
+Jan Synacek (5):
+      tracepath,doc: fix corrupted tag
+      doc: ping: add missing options and remove ping6
+      ping: always use POSIX locale when parsing -i
+      doc: don't timestamp manpages by default
+      ninfod: remove unused variables
+
+Jason A. Donenfeld (1):
+      ping: ICMP error replies while errno < 0 is a hard error
+
+Kylie McClain (1):
+      Fix building with musl
+
+Martin Bark (1):
+      ping: link against libm
+
+Nikos Mavrogiannopoulos (10):
+      made ping functions protocol independent
+      Allow ping to use IPv6 addresses
+      if IPv4 resolving fails fallback to ping6
+      ping: in usage print the 'ping -6' options as well
+      ping: allow option -4 which forces IPv4
+      combine sock and errno into a single structure
+      This patch allows running ping and ping6 without root privileges on
+      use better names for socket variables
+      travis.yml: install nettle-dev
+      Allow using nettle instead of libgcrypt for MD5
+
+Pavel Šimerda (14):
+      avoid compiler warning caused by snapshot.h
+      make `getaddrinfo()` and `getnameinfo()` usage consistent
+      enable IDN by default
+      ping: perform dual-stack ping by default
+      remove IPV4_TARGETS and IPV6_TARGETS
+      ping: remove obsolete preprocessor directives
+      ping: avoid name clashes between IPv4 and IPv6 code
+      ping: merge all ping header files into a single one
+      ping: merge `ping6` command into `ping`
+      ping: refactor ping options
+      ping: refactor ping socket code
+      ping: merge IPv4 and IPv6 `pr_addr()`
+      ping: fix defines and libs in Makefile
+      ping: handle single protocol systems
+
+Peter Dave Hello (1):
+      Use svg instead of png to get better image quality
+
+Salvatore Mesoraca (1):
+      iputils ping/ping6: Add a function to check if a packet is ours
+
+YOSHIFUJI Hideaki (9):
+      ping: Add <linux/types.h> to fix compilation error.
+      ping6: Use GNUTLS API directly for MD5. (v2)
+      ping6: Use libgcrypt instead of gnutls for MD5.
+      ninfod: Regenerate configure by autoconf-2.69.
+      ninfod: libgcrypt support.
+      spec: Configure before building ninfod.
+      spec: Fix date in %changelog.
+      make,spec: Add rpm target.
+      ping,ping6 doc: More description on CAP_NET_RAW usage.
+
+
+[s20150815]
+
+Aaro Koskinen (1):
+      use syntax compatible with busybox date in Makefile
+
+David Heidelberg (1):
+      Makefile: use #define as in previous code changes
+
+David McMackins II (1):
+      ping: status() now returns received/transmitted instead of trans/recv
+
+Felix Janda (1):
+      ping: don't mess with internals of struct msghdr
+
+Jan Synacek (1):
+      tracepath,doc: fix corrupted tag
+
+Nikos Mavrogiannopoulos (10):
+      made ping functions protocol independent
+      Allow ping to use IPv6 addresses
+      if IPv4 resolving fails fallback to ping6
+      ping: in usage print the 'ping -6' options as well
+      ping: allow option -4 which forces IPv4
+      combine sock and errno into a single structure
+      This patch allows running ping and ping6 without root privileges on
+      use better names for socket variables
+      travis.yml: install nettle-dev
+      Allow using nettle instead of libgcrypt for MD5
+
+Pavel Šimerda (12):
+      avoid compiler warning caused by snapshot.h
+      make `getaddrinfo()` and `getnameinfo()` usage consistent
+      enable IDN by default
+      ping: perform dual-stack ping by default
+      remove IPV4_TARGETS and IPV6_TARGETS
+      ping: remove obsolete preprocessor directives
+      ping: avoid name clashes between IPv4 and IPv6 code
+      ping: merge all ping header files into a single one
+      ping: merge `ping6` command into `ping`
+      ping: refactor ping options
+      ping: refactor ping socket code
+      ping: merge IPv4 and IPv6 `pr_addr()`
+
+Peter Dave Hello (1):
+      Use svg instead of png to get better image quality
+
+Salvatore Mesoraca (1):
+      iputils ping/ping6: Add a function to check if a packet is ours
+
+YOSHIFUJI Hideaki (9):
+      ping: Add <linux/types.h> to fix compilation error.
+      ping6: Use GNUTLS API directly for MD5. (v2)
+      ping6: Use libgcrypt instead of gnutls for MD5.
+      ninfod: Regenerate configure by autoconf-2.69.
+      ninfod: libgcrypt support.
+      spec: Configure before building ninfod.
+      spec: Fix date in %changelog.
+      make,spec: Add rpm target.
+      ping,ping6 doc: More description on CAP_NET_RAW usage.
+
+
+[s20140519]
+
+David Gibson (3):
+      arping: Avoid confusing local names
+      arping: Use monotonic clock for timeouts
+      arping: Clarify and correct interaction of -c and -w options
+
+David Heidelberger (3):
+      rdisc: ifdef only apply on historic glibc < 2
+      get rid of unused lint and copyright array
+      cleanup, get rid of if(1), #if 0 and constify on
+
+Jan Synacek (3):
+      ninfod: Fix more unused variables.
+      arping: fix arping hang if SIGALRM is blocked
+      ping_common.c: fix message flood when EPERM is encountered in ping
+
+
+[s20140420]
+
+David Heidelberger (1):
+      improve autobuild bot configuration
+
+Mike Frysinger (5):
+      improve gitignore
+      doc: fix parallel build of html/man pages
+      ping6: allow disabling of openssl support
+      fix handling of CFLAGS
+      tftpd: check return value of set*id calls
+
+
+[s20140419]
 
 Arjan van de Ven (1):
       ping6: Fix build command line argument with gnutls.
 
+Bjørn Mork (1):
+      tracepath: return correct number of hops
+
+Christophe Le Roy (1):
+      ping: flush stdout when a truncated response is received
+
+David Fries (1):
+      Only emit an audible ping when requested (including flooding).
+
+David Heidelberger (13):
+      add missing limits.h
+      in case that HZ is undefined, define it
+      fix include paths, now compile with both glibc and musl
+      protocol/timed.h is no longer required
+      fix ifdef to apply only on uclibc and old glibc
+      replace non-POSIX compilant caddr_t with char *
+      replace u_TYPE with compilant unsigned TYPE
+      add .gitignore and .travis.yml
+      ping_common.c: fix typo
+      fix tracepath docs
+      Makefile: set CC only if it's not defined before
+      add README.md
+      .travis.yml, improve build testing
+
+Hendrik Lönngren (1):
+      arping: return immediately
+
 Jan Synacek (1):
       ping doc: Fix typo.
 
+Jeremie Koenig (1):
+      replace gethostbyname with gethostbyname2
+
+Matija Nalis (1):
+      Disable DNS-lookup on every ping
+
 Mike Frysinger (1):
       tracepath, tracepath6: re-use printf return in print_host
 
-Salvatore Mesoraca (2):
-      iputils ping/ping6: Add a function to check if a packet is ours
-      iputils ping/ping6: add (non-raw) ICMP socket support
+Noah Meyerhans (1):
+      remove bogus check required for < 2.4.9 kernels
 
-YOSHIFUJI Hideaki (22):
+YOSHIFUJI Hideaki (5):
       rdisc: Fix memory leakage in initifs() in error path.
       ninfod: Clean up signal/logfile handling
       ninfod: Open pidfile exclusively for write.
       ping, ping6: fix building with older linux headers that don't define SO_MARK
       tracepath, tracepath6: Support -m (maximum hops) option.
-      ping: Add <linux/types.h> to fix compilation error.
-      ping: Add <linux/types.h> to fix compilation error.
-      ping6: Use GNUTLS API directly for MD5.
-      ping6: Use libgcrypt instead of gnutls for MD5.
-      ninfod: Regenerate configure by autoconf-2.69.
-      ping6: Use libgcrypt for MD5, instead of gnutls.
-      ninfod: libgcrypt support.
-      tracepath: Fix missing end tag for OPTION.
-      spec: Configure before building ninfod.
-      spec: Update changelog.
-      spec: Fix date in %changelog.
-      tftpd: Exit if setuid()/setgid() failed.
-      make,spec: Add rpm target.
-      ping,ping6 doc: More description on CAP_NET_RAW usage.
-      tracepath,tracepath6: Fix incorrect 'back' hops.
-      ping,ping6: Do not emit audible pings without request.
-      arping: Exit when there is nothing left to do
 
 
 [s20121221]
diff -Naur iputils-s20151218.orig/SNAPSHOT.h iputils-s20151218/SNAPSHOT.h
--- iputils-s20151218.orig/SNAPSHOT.h	2015-12-17 15:45:51.000000000 +0000
+++ iputils-s20151218/SNAPSHOT.h	2016-05-17 23:17:09.000000000 +0000
@@ -1 +1 @@
-static char SNAPSHOT[] = "s20151218";
+#define SNAPSHOT "s20160308"
diff -Naur iputils-s20151218.orig/tftpd.c iputils-s20151218/tftpd.c
--- iputils-s20151218.orig/tftpd.c	2015-12-17 15:45:51.000000000 +0000
+++ iputils-s20151218/tftpd.c	2016-05-17 23:17:09.000000000 +0000
@@ -30,18 +30,6 @@
  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
  * SUCH DAMAGE.
  */
-
-#ifndef lint
-char copyright[] =
-"@(#) Copyright (c) 1983 Regents of the University of California.\n\
- All rights reserved.\n";
-#endif /* not lint */
-
-#ifndef lint
-/*static char sccsid[] = "from: @(#)tftpd.c	5.13 (Berkeley) 2/26/91";*/
-/*static char rcsid[] = "$Id: tftpd.c,v 1.3 1993/08/01 18:28:53 mycroft Exp $";*/
-#endif /* not lint */
-
 /*
  * Trivial file transfer protocol server.
  *
@@ -109,14 +97,12 @@
 	register int n = 0;
 	int on = 1;
 
+	openlog("tftpd", LOG_PID, LOG_DAEMON);
+
 	/* Sanity. If parent forgot to setuid() on us. */
 	if (geteuid() == 0) {
-		if (setgid(65534)) {
-			syslog(LOG_ERR, "setgid");
-			exit(1);
-		}
-		if (setuid(65534)) {
-			syslog(LOG_ERR, "setuid");
+		if (setgid(65534) || setuid(65534)) {
+			syslog(LOG_ERR, "set*id failed: %m\n");
 			exit(1);
 		}
 	}
@@ -125,7 +111,6 @@
 	while (ac-- > 0 && n < MAXARG)
 		dirs[n++] = *av++;
 
-	openlog("tftpd", LOG_PID, LOG_DAEMON);
 	if (ioctl(0, FIONBIO, &on) < 0) {
 		syslog(LOG_ERR, "ioctl(FIONBIO): %m\n");
 		exit(1);
@@ -369,8 +354,8 @@
 			nak(errno + 100);
 			goto abort;
 		}
-		dp->th_opcode = htons((u_short)DATA);
-		dp->th_block = htons((u_short)block);
+		dp->th_opcode = htons((unsigned short)DATA);
+		dp->th_block = htons((unsigned short)block);
 		timeout = 0;
 		(void) setjmp(timeoutbuf);
 
@@ -389,8 +374,8 @@
 				syslog(LOG_ERR, "tftpd: read: %m\n");
 				goto abort;
 			}
-			ap->th_opcode = ntohs((u_short)ap->th_opcode);
-			ap->th_block = ntohs((u_short)ap->th_block);
+			ap->th_opcode = ntohs((unsigned short)ap->th_opcode);
+			ap->th_block = ntohs((unsigned short)ap->th_block);
 
 			if (ap->th_opcode == ERROR)
 				goto abort;
@@ -435,8 +420,8 @@
 	ap = (struct tftphdr *)ackbuf;
 	do {
 		timeout = 0;
-		ap->th_opcode = htons((u_short)ACK);
-		ap->th_block = htons((u_short)block);
+		ap->th_opcode = htons((unsigned short)ACK);
+		ap->th_block = htons((unsigned short)block);
 		block++;
 		(void) setjmp(timeoutbuf);
 send_ack:
@@ -454,8 +439,8 @@
 				syslog(LOG_ERR, "tftpd: read: %m\n");
 				goto abort;
 			}
-			dp->th_opcode = ntohs((u_short)dp->th_opcode);
-			dp->th_block = ntohs((u_short)dp->th_block);
+			dp->th_opcode = ntohs((unsigned short)dp->th_opcode);
+			dp->th_block = ntohs((unsigned short)dp->th_block);
 			if (dp->th_opcode == ERROR)
 				goto abort;
 			if (dp->th_opcode == DATA) {
@@ -480,8 +465,8 @@
 	write_behind(file, pf->f_convert);
 	(void) fclose(file);            /* close data file */
 
-	ap->th_opcode = htons((u_short)ACK);    /* send the "final" ack */
-	ap->th_block = htons((u_short)(block));
+	ap->th_opcode = htons((unsigned short)ACK);    /* send the "final" ack */
+	ap->th_block = htons((unsigned short)(block));
 	(void) send(peer, ackbuf, 4, confirmed);
 
 	signal(SIGALRM, justquit);      /* just quit on timeout */
@@ -525,8 +510,8 @@
 	register struct errmsg *pe;
 
 	tp = (struct tftphdr *)buf;
-	tp->th_opcode = htons((u_short)ERROR);
-	tp->th_code = htons((u_short)error);
+	tp->th_opcode = htons((unsigned short)ERROR);
+	tp->th_code = htons((unsigned short)error);
 	for (pe = errmsgs; pe->e_code >= 0; pe++)
 		if (pe->e_code == error)
 			break;
diff -Naur iputils-s20151218.orig/tftpsubs.c iputils-s20151218/tftpsubs.c
--- iputils-s20151218.orig/tftpsubs.c	2015-12-17 15:45:51.000000000 +0000
+++ iputils-s20151218/tftpsubs.c	2016-05-17 23:17:09.000000000 +0000
@@ -30,12 +30,6 @@
  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
  * SUCH DAMAGE.
  */
-
-#ifndef lint
-/*static char sccsid[] = "from: @(#)tftpsubs.c	5.6 (Berkeley) 2/28/91";*/
-/* static char rcsid[] = "$Id: tftpsubs.c,v 1.2 1993/08/01 18:07:04 mycroft Exp $"; */
-#endif /* not lint */
-
 /* Simple minded read-ahead/write-behind subroutines for tftp user and
    server.  Written originally with multiple buffers in mind, but current
    implementation has two buffer logic wired in.
diff -Naur iputils-s20151218.orig/tracepath6.c iputils-s20151218/tracepath6.c
--- iputils-s20151218.orig/tracepath6.c	2015-12-17 15:45:51.000000000 +0000
+++ iputils-s20151218/tracepath6.c	1970-01-01 00:00:00.000000000 +0000
@@ -1,591 +0,0 @@
-/*
- * tracepath6.c
- *
- *		This program is free software; you can redistribute it and/or
- *		modify it under the terms of the GNU General Public License
- *		as published by the Free Software Foundation; either version
- *		2 of the License, or (at your option) any later version.
- *
- * Authors:	Alexey Kuznetsov, <kuznet@ms2.inr.ac.ru>
- */
-
-#include <stdio.h>
-#include <stdlib.h>
-#include <unistd.h>
-#include <sys/socket.h>
-#include <netinet/in.h>
-#include <netinet/icmp6.h>
-
-#include <linux/types.h>
-#include <linux/errqueue.h>
-#include <errno.h>
-#include <string.h>
-#include <netdb.h>
-#include <resolv.h>
-#include <sys/time.h>
-#include <sys/uio.h>
-#include <arpa/inet.h>
-
-#ifdef USE_IDN
-#include <idna.h>
-#include <locale.h>
-#endif
-
-#ifndef SOL_IPV6
-#define SOL_IPV6 IPPROTO_IPV6
-#endif
-
-#ifndef IP_PMTUDISC_DO
-#define IP_PMTUDISC_DO		3
-#endif
-#ifndef IPV6_PMTUDISC_DO
-#define IPV6_PMTUDISC_DO	3
-#endif
-
-#define MAX_HOPS_LIMIT		255
-#define MAX_HOPS_DEFAULT	30
-
-struct hhistory
-{
-	int	hops;
-	struct timeval sendtime;
-};
-
-struct hhistory his[64];
-int hisptr;
-
-sa_family_t family = AF_INET6;
-struct sockaddr_storage target;
-socklen_t targetlen;
-__u16 base_port;
-int max_hops = MAX_HOPS_DEFAULT;
-
-int overhead;
-int mtu;
-void *pktbuf;
-int hops_to = -1;
-int hops_from = -1;
-int no_resolve = 0;
-int show_both = 0;
-int mapped;
-
-#define HOST_COLUMN_SIZE	52
-
-struct probehdr
-{
-	__u32 ttl;
-	struct timeval tv;
-};
-
-void data_wait(int fd)
-{
-	fd_set fds;
-	struct timeval tv;
-	FD_ZERO(&fds);
-	FD_SET(fd, &fds);
-	tv.tv_sec = 1;
-	tv.tv_usec = 0;
-	select(fd+1, &fds, NULL, NULL, &tv);
-}
-
-void print_host(const char *a, const char *b, int both)
-{
-	int plen;
-	plen = printf("%s", a);
-	if (both)
-		plen += printf(" (%s)", b);
-	if (plen >= HOST_COLUMN_SIZE)
-		plen = HOST_COLUMN_SIZE - 1;
-	printf("%*s", HOST_COLUMN_SIZE - plen, "");
-}
-
-int recverr(int fd, int ttl)
-{
-	int res;
-	struct probehdr rcvbuf;
-	char cbuf[512];
-	struct iovec  iov;
-	struct msghdr msg;
-	struct cmsghdr *cmsg;
-	struct sock_extended_err *e;
-	struct sockaddr_storage addr;
-	struct timeval tv;
-	struct timeval *rettv;
-	int slot = 0;
-	int rethops;
-	int sndhops;
-	int progress = -1;
-	int broken_router;
-
-restart:
-	memset(&rcvbuf, -1, sizeof(rcvbuf));
-	iov.iov_base = &rcvbuf;
-	iov.iov_len = sizeof(rcvbuf);
-	msg.msg_name = (caddr_t)&addr;
-	msg.msg_namelen = sizeof(addr);
-	msg.msg_iov = &iov;
-	msg.msg_iovlen = 1;
-	msg.msg_flags = 0;
-	msg.msg_control = cbuf;
-	msg.msg_controllen = sizeof(cbuf);
-
-	gettimeofday(&tv, NULL);
-	res = recvmsg(fd, &msg, MSG_ERRQUEUE);
-	if (res < 0) {
-		if (errno == EAGAIN)
-			return progress;
-		goto restart;
-	}
-
-	progress = mtu;
-
-	rethops = -1;
-	sndhops = -1;
-	e = NULL;
-	rettv = NULL;
-
-	slot = -base_port;
-	switch (family) {
-	case AF_INET6:
-		slot += ntohs(((struct sockaddr_in6 *)&addr)->sin6_port);
-		break;
-	case AF_INET:
-		slot += ntohs(((struct sockaddr_in *)&addr)->sin_port);
-		break;
-	}
-
-	if (slot >= 0 && slot < 63 && his[slot].hops) {
-		sndhops = his[slot].hops;
-		rettv = &his[slot].sendtime;
-		his[slot].hops = 0;
-	}
-	broken_router = 0;
-	if (res == sizeof(rcvbuf)) {
-		if (rcvbuf.ttl == 0 || rcvbuf.tv.tv_sec == 0)
-			broken_router = 1;
-		else {
-			sndhops = rcvbuf.ttl;
-			rettv = &rcvbuf.tv;
-		}
-	}
-
-	for (cmsg = CMSG_FIRSTHDR(&msg); cmsg; cmsg = CMSG_NXTHDR(&msg, cmsg)) {
-		switch (cmsg->cmsg_level) {
-		case SOL_IPV6:
-			switch(cmsg->cmsg_type) {
-			case IPV6_RECVERR:
-				e = (struct sock_extended_err *)CMSG_DATA(cmsg);
-				break;
-			case IPV6_HOPLIMIT:
-#ifdef IPV6_2292HOPLIMIT
-			case IPV6_2292HOPLIMIT:
-#endif
-				memcpy(&rethops, CMSG_DATA(cmsg), sizeof(rethops));
-				break;
-			default:
-				printf("cmsg6:%d\n ", cmsg->cmsg_type);
-			}
-			break;
-		case SOL_IP:
-			switch(cmsg->cmsg_type) {
-			case IP_RECVERR:
-				e = (struct sock_extended_err *)CMSG_DATA(cmsg);
-				break;
-			case IP_TTL:
-				rethops = *(__u8*)CMSG_DATA(cmsg);
-				break;
-			default:
-				printf("cmsg4:%d\n ", cmsg->cmsg_type);
-			}
-		}
-	}
-	if (e == NULL) {
-		printf("no info\n");
-		return 0;
-	}
-	if (e->ee_origin == SO_EE_ORIGIN_LOCAL)
-		printf("%2d?: %-32s ", ttl, "[LOCALHOST]");
-	else if (e->ee_origin == SO_EE_ORIGIN_ICMP6 ||
-		 e->ee_origin == SO_EE_ORIGIN_ICMP) {
-		char abuf[NI_MAXHOST], hbuf[NI_MAXHOST];
-		struct sockaddr *sa = (struct sockaddr *)(e + 1);
-		socklen_t salen;
-
-		if (sndhops>0)
-			printf("%2d:  ", sndhops);
-		else
-			printf("%2d?: ", ttl);
-
-		switch (sa->sa_family) {
-		case AF_INET6:
-			salen = sizeof(struct sockaddr_in6);
-			break;
-		case AF_INET:
-			salen = sizeof(struct sockaddr_in);
-			break;
-		default:
-			salen = 0;
-		}
-
-		if (no_resolve || show_both) {
-			if (getnameinfo(sa, salen,
-					abuf, sizeof(abuf), NULL, 0,
-					NI_NUMERICHOST))
-				strcpy(abuf, "???");
-		} else
-			abuf[0] = 0;
-
-		if (!no_resolve || show_both) {
-			fflush(stdout);
-			if (getnameinfo(sa, salen,
-					hbuf, sizeof(hbuf), NULL, 0,
-					0
-#ifdef USE_IDN
-					| NI_IDN
-#endif
-				        ))
-				strcpy(hbuf, "???");
-		} else
-			hbuf[0] = 0;
-
-		if (no_resolve)
-			print_host(abuf, hbuf, show_both);
-		else
-			print_host(hbuf, abuf, show_both);
-	}
-
-	if (rettv) {
-		int diff = (tv.tv_sec-rettv->tv_sec)*1000000+(tv.tv_usec-rettv->tv_usec);
-		printf("%3d.%03dms ", diff/1000, diff%1000);
-		if (broken_router)
-			printf("(This broken router returned corrupted payload) ");
-	}
-
-	if (rethops >= 0) {
-		if (rethops<=64)
-			rethops = 65-rethops;
-		else if (rethops<=128)
-			rethops = 129-rethops;
-		else
-			rethops = 256-rethops;
-	}
-
-	switch (e->ee_errno) {
-	case ETIMEDOUT:
-		printf("\n");
-		break;
-	case EMSGSIZE:
-		printf("pmtu %d\n", e->ee_info);
-		mtu = e->ee_info;
-		progress = mtu;
-		break;
-	case ECONNREFUSED:
-		printf("reached\n");
-		hops_to = sndhops<0 ? ttl : sndhops;
-		hops_from = rethops;
-		return 0;
-	case EPROTO:
-		printf("!P\n");
-		return 0;
-	case EHOSTUNREACH:
-		if ((e->ee_origin == SO_EE_ORIGIN_ICMP &&
-		     e->ee_type == 11 &&
-		     e->ee_code == 0) ||
-		    (e->ee_origin == SO_EE_ORIGIN_ICMP6 &&
-		     e->ee_type == 3 &&
-		     e->ee_code == 0)) {
-			if (rethops>=0) {
-				if (sndhops>=0 && rethops != sndhops)
-					printf("asymm %2d ", rethops);
-				else if (sndhops<0 && rethops != ttl)
-					printf("asymm %2d ", rethops);
-			}
-			printf("\n");
-			break;
-		}
-		printf("!H\n");
-		return 0;
-	case ENETUNREACH:
-		printf("!N\n");
-		return 0;
-	case EACCES:
-		printf("!A\n");
-		return 0;
-	default:
-		printf("\n");
-		errno = e->ee_errno;
-		perror("NET ERROR");
-		return 0;
-	}
-	goto restart;
-}
-
-int probe_ttl(int fd, int ttl)
-{
-	int i;
-	struct probehdr *hdr = pktbuf;
-
-	memset(pktbuf, 0, mtu);
-restart:
-
-	for (i=0; i<10; i++) {
-		int res;
-
-		hdr->ttl = ttl;
-		switch (family) {
-		case AF_INET6:
-			((struct sockaddr_in6 *)&target)->sin6_port = htons(base_port + hisptr);
-			break;
-		case AF_INET:
-			((struct sockaddr_in *)&target)->sin_port = htons(base_port + hisptr);
-			break;
-		}
-		gettimeofday(&hdr->tv, NULL);
-		his[hisptr].hops = ttl;
-		his[hisptr].sendtime = hdr->tv;
-		if (sendto(fd, pktbuf, mtu-overhead, 0, (struct sockaddr *)&target, targetlen) > 0)
-			break;
-		res = recverr(fd, ttl);
-		his[hisptr].hops = 0;
-		if (res==0)
-			return 0;
-		if (res > 0)
-			goto restart;
-	}
-	hisptr = (hisptr + 1) & 63;
-
-	if (i<10) {
-		data_wait(fd);
-		if (recv(fd, pktbuf, mtu, MSG_DONTWAIT) > 0) {
-			printf("%2d?: reply received 8)\n", ttl);
-			return 0;
-		}
-		return recverr(fd, ttl);
-	}
-
-	printf("%2d:  send failed\n", ttl);
-	return 0;
-}
-
-static void usage(void) __attribute((noreturn));
-
-static void usage(void)
-{
-	fprintf(stderr, "Usage: tracepath6 [-n] [-b] [-l <len>] [-p port] <destination>\n");
-	exit(-1);
-}
-
-
-int main(int argc, char **argv)
-{
-	int fd;
-	int on;
-	int ttl;
-	char *p;
-	struct addrinfo hints, *ai, *ai0;
-	int ch;
-	int gai;
-	char pbuf[NI_MAXSERV];
-
-#ifdef USE_IDN
-	setlocale(LC_ALL, "");
-#endif
-
-	while ((ch = getopt(argc, argv, "nbh?l:m:p:")) != EOF) {
-		switch(ch) {
-		case 'n':
-			no_resolve = 1;
-			break;
-		case 'b':
-			show_both = 1;
-			break;
-		case 'l':
-			mtu = atoi(optarg);
-			break;
-		case 'm':
-			max_hops = atoi(optarg);
-			if (max_hops < 0 || max_hops > MAX_HOPS_LIMIT) {
-				fprintf(stderr,
-					"Error: max hops must be 0 .. %d (inclusive).\n",
-					MAX_HOPS_LIMIT);
-			}
-			break;
-		case 'p':
-			base_port = atoi(optarg);
-			break;
-		default:
-			usage();
-		}
-	}
-
-	argc -= optind;
-	argv += optind;
-
-	if (argc != 1)
-		usage();
-
-	/* Backward compatiblity */
-	if (!base_port) {
-		p = strchr(argv[0], '/');
-		if (p) {
-			*p = 0;
-			base_port = (unsigned)atoi(p+1);
-		} else {
-			base_port = 44444;
-		}
-	}
-	sprintf(pbuf, "%u", base_port);
-
-	memset(&hints, 0, sizeof(hints));
-	hints.ai_family = family;
-	hints.ai_socktype = SOCK_DGRAM;
-	hints.ai_protocol = IPPROTO_UDP;
-#ifdef USE_IDN
-	hints.ai_flags = AI_IDN;
-#endif
-	gai = getaddrinfo(argv[0], pbuf, &hints, &ai0);
-	if (gai) {
-		fprintf(stderr, "getaddrinfo: %s\n", gai_strerror(gai));
-		exit(1);
-	}
-
-	fd = -1;
-	for (ai = ai0; ai; ai = ai->ai_next) {
-		/* sanity check */
-		if (family && ai->ai_family != family)
-			continue;
-		if (ai->ai_family != AF_INET6 &&
-		    ai->ai_family != AF_INET)
-			continue;
-		family = ai->ai_family;
-		fd = socket(ai->ai_family, ai->ai_socktype, ai->ai_protocol);
-		if (fd < 0)
-			continue;
-		memcpy(&target, ai->ai_addr, sizeof(target));
-		targetlen = ai->ai_addrlen;
-		break;
-	}
-	if (fd < 0) {
-		perror("socket/connect");
-		exit(1);
-	}
-	freeaddrinfo(ai0);
-
-	switch (family) {
-	case AF_INET6:
-		overhead = 48;
-		if (!mtu)
-			mtu = 128000;
-		if (mtu <= overhead)
-			goto pktlen_error;
-
-		on = IPV6_PMTUDISC_DO;
-		if (setsockopt(fd, SOL_IPV6, IPV6_MTU_DISCOVER, &on, sizeof(on)) &&
-		    (on = IPV6_PMTUDISC_DO,
-		     setsockopt(fd, SOL_IPV6, IPV6_MTU_DISCOVER, &on, sizeof(on)))) {
-			perror("IPV6_MTU_DISCOVER");
-			exit(1);
-		}
-		on = 1;
-		if (setsockopt(fd, SOL_IPV6, IPV6_RECVERR, &on, sizeof(on))) {
-			perror("IPV6_RECVERR");
-			exit(1);
-		}
-		if (
-#ifdef IPV6_RECVHOPLIMIT
-		    setsockopt(fd, SOL_IPV6, IPV6_HOPLIMIT, &on, sizeof(on)) &&
-		    setsockopt(fd, SOL_IPV6, IPV6_2292HOPLIMIT, &on, sizeof(on))
-#else
-		    setsockopt(fd, SOL_IPV6, IPV6_HOPLIMIT, &on, sizeof(on))
-#endif
-		    ) {
-			perror("IPV6_HOPLIMIT");
-			exit(1);
-		}
-		if (!IN6_IS_ADDR_V4MAPPED(&(((struct sockaddr_in6 *)&target)->sin6_addr)))
-			break;
-		mapped = 1;
-		/*FALLTHROUGH*/
-	case AF_INET:
-		overhead = 28;
-		if (!mtu)
-			mtu = 65535;
-		if (mtu <= overhead)
-			goto pktlen_error;
-
-		on = IP_PMTUDISC_DO;
-		if (setsockopt(fd, SOL_IP, IP_MTU_DISCOVER, &on, sizeof(on))) {
-			perror("IP_MTU_DISCOVER");
-			exit(1);
-		}
-		on = 1;
-		if (setsockopt(fd, SOL_IP, IP_RECVERR, &on, sizeof(on))) {
-			perror("IP_RECVERR");
-			exit(1);
-		}
-		if (setsockopt(fd, SOL_IP, IP_RECVTTL, &on, sizeof(on))) {
-			perror("IP_RECVTTL");
-			exit(1);
-		}
-	}
-
-	pktbuf = malloc(mtu);
-	if (!pktbuf) {
-		perror("malloc");
-		exit(1);
-	}
-
-	for (ttl = 1; ttl <= max_hops; ttl++) {
-		int res;
-		int i;
-
-		on = ttl;
-		switch (family) {
-		case AF_INET6:
-			if (setsockopt(fd, SOL_IPV6, IPV6_UNICAST_HOPS, &on, sizeof(on))) {
-				perror("IPV6_UNICAST_HOPS");
-				exit(1);
-			}
-			if (!mapped)
-				break;
-			/*FALLTHROUGH*/
-		case AF_INET:
-			if (setsockopt(fd, SOL_IP, IP_TTL, &on, sizeof(on))) {
-				perror("IP_TTL");
-				exit(1);
-			}
-		}
-
-restart:
-		for (i=0; i<3; i++) {
-			int old_mtu;
-
-			old_mtu = mtu;
-			res = probe_ttl(fd, ttl);
-			if (mtu != old_mtu)
-				goto restart;
-			if (res == 0)
-				goto done;
-			if (res > 0)
-				break;
-		}
-
-		if (res < 0)
-			printf("%2d:  no reply\n", ttl);
-	}
-	printf("     Too many hops: pmtu %d\n", mtu);
-
-done:
-	printf("     Resume: pmtu %d ", mtu);
-	if (hops_to>=0)
-		printf("hops %d ", hops_to);
-	if (hops_from>=0)
-		printf("back %d ", hops_from);
-	printf("\n");
-	exit(0);
-
-pktlen_error:
-	fprintf(stderr, "Error: pktlen must be > %d and <= %d\n",
-		overhead, INT_MAX);
-	exit(1);
-}
diff -Naur iputils-s20151218.orig/tracepath.c iputils-s20151218/tracepath.c
--- iputils-s20151218.orig/tracepath.c	2015-12-17 15:45:51.000000000 +0000
+++ iputils-s20151218/tracepath.c	2016-05-17 23:17:09.000000000 +0000
@@ -13,23 +13,37 @@
 #include <stdlib.h>
 #include <unistd.h>
 #include <sys/socket.h>
+#include <netinet/in.h>
+#include <netinet/icmp6.h>
+
 #include <linux/types.h>
 #include <linux/errqueue.h>
 #include <errno.h>
 #include <string.h>
 #include <netdb.h>
-#include <netinet/in.h>
+#include <limits.h>
 #include <resolv.h>
 #include <sys/time.h>
 #include <sys/uio.h>
 #include <arpa/inet.h>
+
 #ifdef USE_IDN
 #include <idna.h>
 #include <locale.h>
+#define getnameinfo_flags	NI_IDN
+#else
+#define getnameinfo_flags	0
+#endif
+
+#ifndef SOL_IPV6
+#define SOL_IPV6 IPPROTO_IPV6
 #endif
 
-#ifndef IP_PMTUDISC_PROBE
-#define IP_PMTUDISC_PROBE	3
+#ifndef IP_PMTUDISC_DO
+#define IP_PMTUDISC_DO		3
+#endif
+#ifndef IPV6_PMTUDISC_DO
+#define IPV6_PMTUDISC_DO	3
 #endif
 
 #define MAX_HOPS_LIMIT		255
@@ -44,17 +58,19 @@
 struct hhistory his[64];
 int hisptr;
 
-struct sockaddr_in target;
+struct sockaddr_storage target;
+socklen_t targetlen;
 __u16 base_port;
 int max_hops = MAX_HOPS_DEFAULT;
 
-const int overhead = 28;
-int mtu = 65535;
+int overhead;
+int mtu;
 void *pktbuf;
 int hops_to = -1;
 int hops_from = -1;
 int no_resolve = 0;
 int show_both = 0;
+int mapped;
 
 #define HOST_COLUMN_SIZE	52
 
@@ -86,7 +102,7 @@
 	printf("%*s", HOST_COLUMN_SIZE - plen, "");
 }
 
-int recverr(int fd, int ttl)
+int recverr(int fd, struct addrinfo *ai, int ttl)
 {
 	int res;
 	struct probehdr rcvbuf;
@@ -95,14 +111,15 @@
 	struct msghdr msg;
 	struct cmsghdr *cmsg;
 	struct sock_extended_err *e;
-	struct sockaddr_in addr;
+	struct sockaddr_storage addr;
 	struct timeval tv;
 	struct timeval *rettv;
-	int slot;
+	int slot = 0;
 	int rethops;
 	int sndhops;
 	int progress = -1;
 	int broken_router;
+	char hnamebuf[NI_MAXHOST] = "";
 
 restart:
 	memset(&rcvbuf, -1, sizeof(rcvbuf));
@@ -130,30 +147,59 @@
 	sndhops = -1;
 	e = NULL;
 	rettv = NULL;
-	slot = ntohs(addr.sin_port) - base_port;
-	if (slot>=0 && slot < 63 && his[slot].hops) {
+
+	slot = -base_port;
+	switch (ai->ai_family) {
+	case AF_INET6:
+		slot += ntohs(((struct sockaddr_in6 *)&addr)->sin6_port);
+		break;
+	case AF_INET:
+		slot += ntohs(((struct sockaddr_in *)&addr)->sin_port);
+		break;
+	}
+
+	if (slot >= 0 && slot < 63 && his[slot].hops) {
 		sndhops = his[slot].hops;
 		rettv = &his[slot].sendtime;
 		his[slot].hops = 0;
 	}
 	broken_router = 0;
 	if (res == sizeof(rcvbuf)) {
-		if (rcvbuf.ttl == 0 || rcvbuf.tv.tv_sec == 0) {
+		if (rcvbuf.ttl == 0 || rcvbuf.tv.tv_sec == 0)
 			broken_router = 1;
-		} else {
+		else {
 			sndhops = rcvbuf.ttl;
 			rettv = &rcvbuf.tv;
 		}
 	}
 
 	for (cmsg = CMSG_FIRSTHDR(&msg); cmsg; cmsg = CMSG_NXTHDR(&msg, cmsg)) {
-		if (cmsg->cmsg_level == SOL_IP) {
-			if (cmsg->cmsg_type == IP_RECVERR) {
-				e = (struct sock_extended_err *) CMSG_DATA(cmsg);
-			} else if (cmsg->cmsg_type == IP_TTL) {
+		switch (cmsg->cmsg_level) {
+		case SOL_IPV6:
+			switch(cmsg->cmsg_type) {
+			case IPV6_RECVERR:
+				e = (struct sock_extended_err *)CMSG_DATA(cmsg);
+				break;
+			case IPV6_HOPLIMIT:
+#ifdef IPV6_2292HOPLIMIT
+			case IPV6_2292HOPLIMIT:
+#endif
 				memcpy(&rethops, CMSG_DATA(cmsg), sizeof(rethops));
-			} else {
-				printf("cmsg:%d\n ", cmsg->cmsg_type);
+				break;
+			default:
+				printf("cmsg6:%d\n ", cmsg->cmsg_type);
+			}
+			break;
+		case SOL_IP:
+			switch(cmsg->cmsg_type) {
+			case IP_RECVERR:
+				e = (struct sock_extended_err *)CMSG_DATA(cmsg);
+				break;
+			case IP_TTL:
+				rethops = *(__u8*)CMSG_DATA(cmsg);
+				break;
+			default:
+				printf("cmsg4:%d\n ", cmsg->cmsg_type);
 			}
 		}
 	}
@@ -161,38 +207,49 @@
 		printf("no info\n");
 		return 0;
 	}
-	if (e->ee_origin == SO_EE_ORIGIN_LOCAL) {
-		printf("%2d?: %*s ", ttl, -(HOST_COLUMN_SIZE - 1), "[LOCALHOST]");
-	} else if (e->ee_origin == SO_EE_ORIGIN_ICMP) {
-		char abuf[128];
-		struct sockaddr_in *sin = (struct sockaddr_in*)(e+1);
-		struct hostent *h = NULL;
-		char *idn = NULL;
-
-		inet_ntop(AF_INET, &sin->sin_addr, abuf, sizeof(abuf));
+	if (e->ee_origin == SO_EE_ORIGIN_LOCAL)
+		printf("%2d?: %-32s ", ttl, "[LOCALHOST]");
+	else if (e->ee_origin == SO_EE_ORIGIN_ICMP6 ||
+		 e->ee_origin == SO_EE_ORIGIN_ICMP) {
+		char abuf[NI_MAXHOST];
+		struct sockaddr *sa = (struct sockaddr *)(e + 1);
+		socklen_t salen;
 
 		if (sndhops>0)
 			printf("%2d:  ", sndhops);
 		else
 			printf("%2d?: ", ttl);
 
+		switch (sa->sa_family) {
+		case AF_INET6:
+			salen = sizeof(struct sockaddr_in6);
+			break;
+		case AF_INET:
+			salen = sizeof(struct sockaddr_in);
+			break;
+		default:
+			salen = 0;
+		}
+
+		if (no_resolve || show_both) {
+			if (getnameinfo(sa, salen,
+					abuf, sizeof(abuf), NULL, 0,
+					NI_NUMERICHOST))
+				strcpy(abuf, "???");
+		} else
+			abuf[0] = 0;
+
 		if (!no_resolve || show_both) {
 			fflush(stdout);
-			h = gethostbyaddr((char *) &sin->sin_addr, sizeof(sin->sin_addr), AF_INET);
-		}
+			if (getnameinfo(sa, salen, hnamebuf, sizeof hnamebuf, NULL, 0, getnameinfo_flags))
+				strcpy(hnamebuf, "???");
+		} else
+			hnamebuf[0] = 0;
 
-#ifdef USE_IDN
-		if (h && idna_to_unicode_lzlz(h->h_name, &idn, 0) != IDNA_SUCCESS)
-			idn = NULL;
-#endif
 		if (no_resolve)
-			print_host(abuf, h ? (idn ? idn : h->h_name) : abuf, show_both);
+			print_host(abuf, hnamebuf, show_both);
 		else
-			print_host(h ? (idn ? idn : h->h_name) : abuf, abuf, show_both);
-
-#ifdef USE_IDN
-		free(idn);
-#endif
+			print_host(hnamebuf, abuf, show_both);
 	}
 
 	if (rettv) {
@@ -202,14 +259,12 @@
 			printf("(This broken router returned corrupted payload) ");
 	}
 
-	if (rethops >= 0) {
-		if (rethops<=64)
-			rethops = 65-rethops;
-		else if (rethops<=128)
-			rethops = 129-rethops;
-		else
-			rethops = 256-rethops;
-	}
+	if (rethops<=64)
+		rethops = 65-rethops;
+	else if (rethops<=128)
+		rethops = 129-rethops;
+	else
+		rethops = 256-rethops;
 
 	switch (e->ee_errno) {
 	case ETIMEDOUT:
@@ -229,9 +284,12 @@
 		printf("!P\n");
 		return 0;
 	case EHOSTUNREACH:
-		if (e->ee_origin == SO_EE_ORIGIN_ICMP &&
-		    e->ee_type == 11 &&
-		    e->ee_code == 0) {
+		if ((e->ee_origin == SO_EE_ORIGIN_ICMP &&
+		     e->ee_type == 11 &&
+		     e->ee_code == 0) ||
+		    (e->ee_origin == SO_EE_ORIGIN_ICMP6 &&
+		     e->ee_type == 3 &&
+		     e->ee_code == 0)) {
 			if (rethops>=0) {
 				if (sndhops>=0 && rethops != sndhops)
 					printf("asymm %2d ", rethops);
@@ -258,7 +316,7 @@
 	goto restart;
 }
 
-int probe_ttl(int fd, int ttl)
+int probe_ttl(int fd, struct addrinfo *ai, int ttl)
 {
 	int i;
 	struct probehdr *hdr = pktbuf;
@@ -269,20 +327,27 @@
 		int res;
 
 		hdr->ttl = ttl;
-		target.sin_port = htons(base_port + hisptr);
+		switch (ai->ai_family) {
+		case AF_INET6:
+			((struct sockaddr_in6 *)&target)->sin6_port = htons(base_port + hisptr);
+			break;
+		case AF_INET:
+			((struct sockaddr_in *)&target)->sin_port = htons(base_port + hisptr);
+			break;
+		}
 		gettimeofday(&hdr->tv, NULL);
 		his[hisptr].hops = ttl;
 		his[hisptr].sendtime = hdr->tv;
-		if (sendto(fd, pktbuf, mtu-overhead, 0, (struct sockaddr*)&target, sizeof(target)) > 0)
+		if (sendto(fd, pktbuf, mtu-overhead, 0, (struct sockaddr *)&target, targetlen) > 0)
 			break;
-		res = recverr(fd, ttl);
+		res = recverr(fd, ai, ttl);
 		his[hisptr].hops = 0;
 		if (res==0)
 			return 0;
 		if (res > 0)
 			goto restart;
 	}
-	hisptr = (hisptr + 1)&63;
+	hisptr = (hisptr + 1) & 63;
 
 	if (i<10) {
 		data_wait(fd);
@@ -290,7 +355,7 @@
 			printf("%2d?: reply received 8)\n", ttl);
 			return 0;
 		}
-		return recverr(fd, ttl);
+		return recverr(fd, ai, ttl);
 	}
 
 	printf("%2d:  send failed\n", ttl);
@@ -305,22 +370,46 @@
 	exit(-1);
 }
 
-int
-main(int argc, char **argv)
+
+int main(int argc, char **argv)
 {
-	struct hostent *he;
+	struct addrinfo hints = {
+		.ai_family = AF_UNSPEC,
+		.ai_socktype = SOCK_DGRAM,
+		.ai_protocol = IPPROTO_UDP,
+#ifdef USE_IDN
+		.ai_flags = AI_IDN | AI_CANONNAME,
+#endif
+	};
+	struct addrinfo *ai, *result;
+	int ch;
+	int status;
 	int fd;
 	int on;
 	int ttl;
 	char *p;
-	int ch;
+	char pbuf[NI_MAXSERV];
+
 #ifdef USE_IDN
-	int rc;
 	setlocale(LC_ALL, "");
 #endif
 
-	while ((ch = getopt(argc, argv, "nbh?l:m:p:")) != EOF) {
+	while ((ch = getopt(argc, argv, "46nbh?l:m:p:")) != EOF) {
 		switch(ch) {
+		case '4':
+			if (hints.ai_family != AF_UNSPEC) {
+				fprintf(stderr, "tracepath: Only one -4 or -6 option may be specified\n");
+				exit(2);
+			}
+			hints.ai_family = AF_INET;
+			break;
+		case '6':
+			if (hints.ai_family != AF_UNSPEC) {
+				fprintf(stderr, "tracepath: Only one -4 or -6 option may be specified\n");
+				exit(2);
+			}
+			hints.ai_family = AF_INET6;
+			break;
 		case 'n':
 			no_resolve = 1;
 			break;
@@ -356,13 +445,6 @@
 	if (argc != 1)
 		usage();
 
-	fd = socket(AF_INET, SOCK_DGRAM, 0);
-	if (fd < 0) {
-		perror("socket");
-		exit(1);
-	}
-	target.sin_family = AF_INET;
-
 	/* Backward compatiblity */
 	if (!base_port) {
 		p = strchr(argv[0], '/');
@@ -372,43 +454,87 @@
 		} else
 			base_port = 44444;
 	}
+	sprintf(pbuf, "%u", base_port);
 
-	p = argv[0];
-#ifdef USE_IDN
-	rc = idna_to_ascii_lz(argv[0], &p, 0);
-	if (rc != IDNA_SUCCESS) {
-		fprintf(stderr, "IDNA encoding failed: %s\n", idna_strerror(rc));
-		exit(2);
-	}
-#endif
-
-	he = gethostbyname(p);
-	if (he == NULL) {
-		herror("gethostbyname");
+	status = getaddrinfo(argv[0], pbuf, &hints, &result);
+	if (status) {
+		fprintf(stderr, "tracepath: %s: %s\n", argv[0], gai_strerror(status));
 		exit(1);
 	}
 
-#ifdef USE_IDN
-	free(p);
-#endif
-
-	memcpy(&target.sin_addr, he->h_addr, 4);
-
-	on = IP_PMTUDISC_PROBE;
-	if (setsockopt(fd, SOL_IP, IP_MTU_DISCOVER, &on, sizeof(on)) &&
-	    (on = IP_PMTUDISC_DO,
-	     setsockopt(fd, SOL_IP, IP_MTU_DISCOVER, &on, sizeof(on)))) {
-		perror("IP_MTU_DISCOVER");
-		exit(1);
+	fd = -1;
+	for (ai = result; ai; ai = ai->ai_next) {
+		if (ai->ai_family != AF_INET6 &&
+		    ai->ai_family != AF_INET)
+			continue;
+		fd = socket(ai->ai_family, ai->ai_socktype, ai->ai_protocol);
+		if (fd < 0)
+			continue;
+		memcpy(&target, ai->ai_addr, sizeof(target));
+		targetlen = ai->ai_addrlen;
+		break;
 	}
-	on = 1;
-	if (setsockopt(fd, SOL_IP, IP_RECVERR, &on, sizeof(on))) {
-		perror("IP_RECVERR");
+	if (fd < 0) {
+		perror("socket/connect");
 		exit(1);
 	}
-	if (setsockopt(fd, SOL_IP, IP_RECVTTL, &on, sizeof(on))) {
-		perror("IP_RECVTTL");
-		exit(1);
+
+	switch (ai->ai_family) {
+	case AF_INET6:
+		overhead = 48;
+		if (!mtu)
+			mtu = 128000;
+		if (mtu <= overhead)
+			goto pktlen_error;
+
+		on = IPV6_PMTUDISC_DO;
+		if (setsockopt(fd, SOL_IPV6, IPV6_MTU_DISCOVER, &on, sizeof(on)) &&
+		    (on = IPV6_PMTUDISC_DO,
+		     setsockopt(fd, SOL_IPV6, IPV6_MTU_DISCOVER, &on, sizeof(on)))) {
+			perror("IPV6_MTU_DISCOVER");
+			exit(1);
+		}
+		on = 1;
+		if (setsockopt(fd, SOL_IPV6, IPV6_RECVERR, &on, sizeof(on))) {
+			perror("IPV6_RECVERR");
+			exit(1);
+		}
+		if (
+#ifdef IPV6_RECVHOPLIMIT
+		    setsockopt(fd, SOL_IPV6, IPV6_HOPLIMIT, &on, sizeof(on)) &&
+		    setsockopt(fd, SOL_IPV6, IPV6_2292HOPLIMIT, &on, sizeof(on))
+#else
+		    setsockopt(fd, SOL_IPV6, IPV6_HOPLIMIT, &on, sizeof(on))
+#endif
+		    ) {
+			perror("IPV6_HOPLIMIT");
+			exit(1);
+		}
+		if (!IN6_IS_ADDR_V4MAPPED(&(((struct sockaddr_in6 *)&target)->sin6_addr)))
+			break;
+		mapped = 1;
+		/*FALLTHROUGH*/
+	case AF_INET:
+		overhead = 28;
+		if (!mtu)
+			mtu = 65535;
+		if (mtu <= overhead)
+			goto pktlen_error;
+
+		on = IP_PMTUDISC_DO;
+		if (setsockopt(fd, SOL_IP, IP_MTU_DISCOVER, &on, sizeof(on))) {
+			perror("IP_MTU_DISCOVER");
+			exit(1);
+		}
+		on = 1;
+		if (setsockopt(fd, SOL_IP, IP_RECVERR, &on, sizeof(on))) {
+			perror("IP_RECVERR");
+			exit(1);
+		}
+		if (setsockopt(fd, SOL_IP, IP_RECVTTL, &on, sizeof(on))) {
+			perror("IP_RECVTTL");
+			exit(1);
+		}
 	}
 
 	pktbuf = malloc(mtu);
@@ -422,9 +548,20 @@
 		int i;
 
 		on = ttl;
-		if (setsockopt(fd, SOL_IP, IP_TTL, &on, sizeof(on))) {
-			perror("IP_TTL");
-			exit(1);
+		switch (ai->ai_family) {
+		case AF_INET6:
+			if (setsockopt(fd, SOL_IPV6, IPV6_UNICAST_HOPS, &on, sizeof(on))) {
+				perror("IPV6_UNICAST_HOPS");
+				exit(1);
+			}
+			if (!mapped)
+				break;
+			/*FALLTHROUGH*/
+		case AF_INET:
+			if (setsockopt(fd, SOL_IP, IP_TTL, &on, sizeof(on))) {
+				perror("IP_TTL");
+				exit(1);
+			}
 		}
 
 restart:
@@ -432,7 +569,7 @@
 			int old_mtu;
 
 			old_mtu = mtu;
-			res = probe_ttl(fd, ttl);
+			res = probe_ttl(fd, ai, ttl);
 			if (mtu != old_mtu)
 				goto restart;
 			if (res == 0)
@@ -445,7 +582,10 @@
 			printf("%2d:  no reply\n", ttl);
 	}
 	printf("     Too many hops: pmtu %d\n", mtu);
+
 done:
+	freeaddrinfo(result);
+
 	printf("     Resume: pmtu %d ", mtu);
 	if (hops_to>=0)
 		printf("hops %d ", hops_to);
@@ -453,4 +593,9 @@
 		printf("back %d ", hops_from);
 	printf("\n");
 	exit(0);
+
+pktlen_error:
+	fprintf(stderr, "Error: pktlen must be > %d and <= %d\n",
+		overhead, INT_MAX);
+	exit(1);
 }
diff -Naur iputils-s20151218.orig/traceroute6.c iputils-s20151218/traceroute6.c
--- iputils-s20151218.orig/traceroute6.c	2015-12-17 15:45:51.000000000 +0000
+++ iputils-s20151218/traceroute6.c	2016-05-17 23:17:09.000000000 +0000
@@ -52,13 +52,6 @@
  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
  * SUCH DAMAGE.
  */
-
-#ifndef lint
-char copyright[] =
-"@(#) Copyright (c) 1990, 1993\n\
-	The Regents of the University of California.  All rights reserved.\n";
-#endif /* not lint */
-
 /*
  * traceroute host  - trace the route ip packets follow going to "host".
  *
@@ -172,7 +165,8 @@
  * Other possible annotations after the time are !H, !N, !P (got a host,
  * network or protocol unreachable, respectively), !S or !F (source
  * route failed or fragmentation needed -- neither of these should
- * ever occur and the associated gateway is busted if you see one).  If
+ * ever occur and the associated gateway is busted if you see one),
+ * !X (communication administratively prohibited). If
  * almost all the probes result in some kind of unreachable, traceroute
  * will give up and exit.
  *
@@ -256,6 +250,10 @@
 #ifdef USE_IDN
 #include <idna.h>
 #include <locale.h>
+
+#define getnameinfo_flags	NI_IDN
+#else
+#define getnameinfo_flags	0
 #endif
 
 #include <arpa/inet.h>
@@ -274,7 +272,6 @@
 #endif
 
 #define	MAXPACKET	65535
-#define MAX_HOSTNAMELEN	NI_MAXHOST
 
 #ifndef FD_SET
 #define NFDBITS         (8*sizeof(fd_set))
@@ -288,10 +285,10 @@
 #define Fprintf (void)fprintf
 #define Printf (void)printf
 
-u_char	packet[512];		/* last inbound (icmp) packet */
+unsigned char	packet[512];		/* last inbound (icmp) packet */
 
 int	wait_for_reply(int, struct sockaddr_in6 *, struct in6_addr *, int);
-int	packet_ok(u_char *buf, int cc, struct sockaddr_in6 *from,
+int	packet_ok(unsigned char *buf, int cc, struct sockaddr_in6 *from,
 		  struct in6_addr *to, int seq, struct timeval *);
 void	send_probe(int seq, int ttl);
 double	deltaT (struct timeval *, struct timeval *);
@@ -314,7 +311,7 @@
 int nprobes = 3;
 int max_ttl = 30;
 pid_t ident;
-u_short port = 32768+666;	/* start udp dest port # for probe packets */
+unsigned short port = 32768+666;	/* start udp dest port # for probe packets */
 int options;			/* socket options */
 int verbose;
 int waittime = 5;		/* time to wait for response (in seconds) */
@@ -335,10 +332,12 @@
 
 int main(int argc, char *argv[])
 {
-	char pa[MAX_HOSTNAMELEN];
+	char pa[NI_MAXHOST];
 	extern char *optarg;
 	extern int optind;
-	struct hostent *hp;
+	struct addrinfo hints6 = { .ai_family = AF_INET6, .ai_socktype = SOCK_RAW, .ai_flags = AI_CANONNAME };
+	struct addrinfo *result;
+	int status;
 	struct sockaddr_in6 from, *to;
 	int ch, i, on, probe, seq, tos, ttl;
 	int socket_errno;
@@ -455,15 +454,16 @@
 		if (idna_to_ascii_lz(*argv, &idn, 0) != IDNA_SUCCESS)
 			idn = NULL;
 #endif
-		hp = gethostbyname2(idn ? idn : *argv, AF_INET6);
-		if (hp) {
-			memmove((caddr_t)&to->sin6_addr, hp->h_addr, sizeof(to->sin6_addr));
-			hostname = (char *)hp->h_name;
-		} else {
+		status = getaddrinfo(idn ? idn : *argv, NULL, &hints6, &result);
+		if (status) {
 			(void)fprintf(stderr,
-			    "traceroute: unknown host %s\n", *argv);
+			    "traceroute: %s: %s\n", *argv, gai_strerror(status));
 			exit(1);
 		}
+
+		memcpy(to, result->ai_addr, sizeof *to);
+		hostname = result->ai_canonname;
+		freeaddrinfo(result);
 	}
 	firsthop = *to;
 	if (*++argv) {
@@ -633,7 +633,7 @@
 
 					case ICMP6_DST_UNREACH_ADMIN:
 						++unreachable;
-						Printf(" !S");
+						Printf(" !X");
 						break;
 					}
 					break;
@@ -821,12 +821,12 @@
 }
 
 
-int packet_ok(u_char *buf, int cc, struct sockaddr_in6 *from,
+int packet_ok(unsigned char *buf, int cc, struct sockaddr_in6 *from,
 	      struct in6_addr *to, int seq,
 	      struct timeval *tv)
 {
 	struct icmp6_hdr *icp;
-	u_char type, code;
+	unsigned char type, code;
 
 	icp = (struct icmp6_hdr *) buf;
 
@@ -866,8 +866,8 @@
 
 	if (verbose) {
 		unsigned char *p;
-		char pa1[MAX_HOSTNAMELEN];
-		char pa2[MAX_HOSTNAMELEN];
+		char pa1[NI_MAXHOST];
+		char pa2[NI_MAXHOST];
 		int i;
 
 		p = (unsigned char *) (icp + 1);
@@ -898,30 +898,17 @@
 
 void print(unsigned char *buf, int cc, struct sockaddr_in6 *from)
 {
-	char pa[MAX_HOSTNAMELEN];
+	char pa[NI_MAXHOST] = "";
+	char hnamebuf[NI_MAXHOST] = "";
 
 	if (nflag)
 		Printf(" %s", inet_ntop(AF_INET6, &from->sin6_addr,
 					pa, sizeof(pa)));
-	else
-	{
-		const char *hostname;
-		struct hostent *hp;
-		char *s = NULL;
-
-		hostname = inet_ntop(AF_INET6, &from->sin6_addr, pa, sizeof(pa));
-
-		if ((hp = gethostbyaddr((char *)&from->sin6_addr,
-					sizeof(from->sin6_addr), AF_INET6))) {
-#ifdef USE_IDN
-			if (idna_to_unicode_lzlz(hp->h_name, &s, 0) != IDNA_SUCCESS)
-				s = NULL;
-#endif
-		}
-
-		Printf(" %s (%s)", hp ? (s ? s : hp->h_name) : hostname, pa);
+	else {
+		inet_ntop(AF_INET6, &from->sin6_addr, pa, sizeof(pa));
+		getnameinfo((struct sockaddr *) from, sizeof *from, hnamebuf, sizeof hnamebuf, NULL, 0, getnameinfo_flags);
 
-		free(s);
+		Printf(" %s (%s)", hnamebuf[0] ? hnamebuf : pa, pa);
 	}
 }
 
